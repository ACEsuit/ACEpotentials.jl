#!/usr/bin/env julia
"""
Minimal ACE model export using actual Julia code (no code generation!)

This approach:
1. Serializes the model, parameters, and state
2. Creates a thin wrapper with concrete types for trim compilation
3. Reuses ALL existing evaluation code from ACEpotentials/EquivariantTensors
4. Eliminates ~3,000 lines of duplicated/buggy generated code

For juliac --trim=safe to work, we only need:
- Concrete type annotations on entry points
- No dynamic dispatch on abstract types
- Static model/parameter data

Everything else (ACE evaluation, splines, spherical harmonics, autodiff)
can use the existing package code directly!
"""

using ACEpotentials
using ACEpotentials.ETModels
using ACEpotentials.ETModels: StackedCalculator, ETOneBody, ETACE
import EquivariantTensors as ET
using StaticArrays
using LinearAlgebra
using Serialization
using AtomsBase: ChemicalSpecies

"""
    export_ace_model_minimal(calc, output_dir; model_name="ace_model")

Export an ACE calculator to a trim-safe Julia module that reuses actual evaluation code.

# Arguments
- `calc`: ETACEPotential or StackedCalculator
- `output_dir`: Directory to write exported files
- `model_name`: Base name for generated files

# Generates
- `{model_name}_data.jls`: Serialized model data
- `{model_name}.jl`: Thin wrapper module (trim-safe)
- `Project.toml`: Dependencies
"""
function export_ace_model_minimal(calc, output_dir::String; model_name::String="ace_model")
    mkpath(output_dir)

    # Extract components
    if isa(calc, StackedCalculator)
        # Find ETOneBody and ETACE in stack
        e0_calc = nothing
        etace_calc = nothing

        for subcalc in calc.calcs
            if isa(subcalc.model, ETOneBody)
                e0_calc = subcalc
            elseif isa(subcalc.model, ETACE)
                etace_calc = subcalc
            end
        end

        if etace_calc === nothing
            error("StackedCalculator must contain an ETACE model")
        end

        # Extract E0 values
        E0_dict = if e0_calc !== nothing
            E0s = e0_calc.st.E0s
            categories = e0_calc.model.categories
            Dict(Int(cat.atomic_number) => E0s[i] for (i, cat) in enumerate(categories))
        else
            nothing
        end

        model = etace_calc.model
        ps = etace_calc.ps
        st = etace_calc.st
        rcut = etace_calc.rcut
    else
        # Direct ETACE calculator
        model = calc.model
        ps = calc.ps
        st = calc.st
        rcut = calc.rcut
        E0_dict = nothing
    end

    # Extract species list
    rembed_layer = model.rembed.layer
    trans_st = rembed_layer.trans.refstate
    zlist = trans_st.zlist
    species = [Int(z.atomic_number) for z in zlist]

    # Serialize model data
    data_file = joinpath(output_dir, "$(model_name)_data.jls")
    serialize(data_file, (; model, ps, st, rcut, species, E0_dict))

    @info "Serialized model data to $data_file"

    # Generate thin wrapper module
    wrapper_file = joinpath(output_dir, "$(model_name).jl")
    open(wrapper_file, "w") do io
        write_minimal_wrapper(io, model_name, species, E0_dict)
    end

    @info "Generated wrapper module: $wrapper_file"

    # Generate Project.toml with dependencies
    project_file = joinpath(output_dir, "Project.toml")
    write_project_toml(project_file, model_name)

    @info "Generated Project.toml: $project_file"

    println("""

Export complete!

To use this model:
1. cd $output_dir
2. julia --project=. -e 'using Pkg; Pkg.instantiate()'
3. julia --project=. $(model_name).jl

To compile with juliac:
1. cd $output_dir
2. juliac --trim=safe --output-exe=$(model_name)_exe $(model_name).jl
3. ./$(model_name)_exe

The exported module reuses ALL existing ACEpotentials code - no code generation!
""")

    return wrapper_file
end

function write_minimal_wrapper(io::IO, model_name::String, species::Vector{Int}, E0_dict)
    println(io, """
#!/usr/bin/env julia
# Minimal ACE model wrapper - reuses actual Julia code!
# Generated by export_ace_model_minimal()

module $(uppercasefirst(model_name))

using ACEpotentials
using ACEpotentials.ETModels
import EquivariantTensors as ET
using StaticArrays
using LinearAlgebra
using Serialization
using AtomsBase: ChemicalSpecies

# Load serialized model data
const DATA_FILE = joinpath(@__DIR__, "$(model_name)_data.jls")
const MODEL_DATA = deserialize(DATA_FILE)

# Extract constants (compile-time)
const MODEL = MODEL_DATA.model
const PS = MODEL_DATA.ps
const ST = MODEL_DATA.st
const RCUT = Float64(MODEL_DATA.rcut)
const SPECIES = MODEL_DATA.species
const E0_DICT = MODEL_DATA.E0_dict

# Species mapping
const I2Z = SPECIES
const NZ = length(SPECIES)

@inline function z2i(Z::Integer)
    for (i, Zi) in enumerate(I2Z)
        if Zi == Z
            return i
        end
    end
    error("Unknown atomic number: \$Z")
end

# E0 lookup (compile-time constant folding)
@inline function get_E0(Z::Int)
    if E0_DICT === nothing
        return 0.0
    else
        return get(E0_DICT, Z, 0.0)
    end
end

# ============================================================================
# CORE EVALUATION (uses actual ACEpotentials code!)
# ============================================================================

\"\"\"
    build_graph(Rs, Zs, Z0, rcut) -> ETGraph

Build interaction graph from neighbor list.
Uses concrete types for trim compilation.
\"\"\"
function build_graph(Rs::Vector{SVector{3, Float64}},
                     Zs::Vector{Int},
                     Z0::Int,
                     rcut::Float64)
    n_neigh = length(Rs)

    # Build edge data with concrete types
    z0_species = ChemicalSpecies(Z0)

    edge_data = Vector{ET.PState{@NamedTuple{ð«::SVector{3,Float64},
                                              z0::ChemicalSpecies,
                                              z1::ChemicalSpecies,
                                              ð’::SVector{3,Int}}}}(undef, n_neigh)

    for i in 1:n_neigh
        z1_species = ChemicalSpecies(Zs[i])
        edge_data[i] = ET.PState((
            ð« = Rs[i],
            z0 = z0_species,
            z1 = z1_species,
            ð’ = SVector(0, 0, 0)  # No PBC shifts for single-atom evaluation
        ))
    end

    # Node data (just the central atom)
    node_data = [ET.PState((ð« = SVector(0.0, 0.0, 0.0), z = z0_species))]

    # Edge connectivity (all edges point to node 1)
    ii = ones(Int, n_neigh)
    jj = collect(1:n_neigh)

    # Metadata
    metadata = (; pbc = (false, false, false),
                  cell = (SVector(10.0, 0.0, 0.0),
                         SVector(0.0, 10.0, 0.0),
                         SVector(0.0, 0.0, 10.0)))

    return ET.ETGraph(ii, jj; node_data=node_data, edge_data=edge_data, graph_data=metadata)
end

\"\"\"
    site_energy(Rs, Zs, Z0) -> Float64

Compute site energy using actual ETACE evaluation code.
No generated code - this calls the real model!
\"\"\"
function site_energy(Rs::Vector{SVector{3, Float64}},
                     Zs::Vector{Int},
                     Z0::Int)::Float64
    # Handle isolated atom
    if isempty(Rs)
        return get_E0(Z0)
    end

    # Build graph (concrete types)
    G = build_graph(Rs, Zs, Z0, RCUT)

    # Evaluate with actual model code (not generated!)
    E_node, _ = MODEL(G, PS, ST)

    # Extract energy (sum over nodes, though we only have 1)
    E = sum(E_node)

    # Add E0
    return E + get_E0(Z0)
end

\"\"\"
    site_energy_forces(Rs, Zs, Z0) -> (E, forces)

Compute site energy and forces using actual autodiff.
Uses Zygote to differentiate the real evaluation code!
\"\"\"
function site_energy_forces(Rs::Vector{SVector{3, Float64}},
                            Zs::Vector{Int},
                            Z0::Int)
    n_neigh = length(Rs)

    # Handle isolated atom
    if n_neigh == 0
        return get_E0(Z0), SVector{3, Float64}[]
    end

    # Build graph
    G = build_graph(Rs, Zs, Z0, RCUT)

    # Evaluate energy
    E_node, _ = MODEL(G, PS, ST)
    E = sum(E_node) + get_E0(Z0)

    # Compute forces using actual gradient code from ACEpotentials
    # This uses the site_grads function which is already implemented!
    âˆ‡E_edges = ETModels.site_grads(MODEL, G, PS, ST)

    # Extract forces from edge gradients
    forces = Vector{SVector{3, Float64}}(undef, n_neigh)
    for i in 1:n_neigh
        # Force on neighbor i is negative gradient of energy w.r.t. position
        forces[i] = -âˆ‡E_edges.edge_data[i].ð«
    end

    return E, forces
end

\"\"\"
    site_basis(Rs, Zs, Z0) -> Vector{Float64}

Compute ACE basis vector (without weight contraction).
Uses actual basis evaluation from ETACE model!
\"\"\"
function site_basis(Rs::Vector{SVector{3, Float64}},
                    Zs::Vector{Int},
                    Z0::Int)::Vector{Float64}
    n_neigh = length(Rs)

    # Handle isolated atom
    if n_neigh == 0
        # Return zero basis
        n_basis = size(PS.readout.W, 2)
        return zeros(Float64, n_basis)
    end

    # Build graph
    G = build_graph(Rs, Zs, Z0, RCUT)

    # Evaluate basis using actual model code
    # The ETACE model has a basis evaluation path
    # site_basis returns the basis for node 1, may be a row vector (Matrix)
    basis_raw = ETModels.site_basis(MODEL, G, PS, ST)

    # Convert to Vector{Float64} (handles both Vector and Matrix cases)
    basis = vec(basis_raw)

    return basis
end

# ============================================================================
# EXPORTS
# ============================================================================

export site_energy, site_energy_forces, site_basis
export I2Z, NZ, z2i

end # module

# If running as script, print model info
if abspath(PROGRAM_FILE) == @__FILE__
    println("ACE Model: $(model_name)")
    println("Species: ", I2Z)
    println("Cutoff: ", RCUT, " Ã…")
    println("E0 values: ", E0_DICT)
    println()
    println("Ready for use!")
end
""")
end

function write_project_toml(filename::String, model_name::String)
    open(filename, "w") do io
        println(io, """
name = "$(uppercasefirst(model_name))"
uuid = "$(Base.UUID(rand(UInt128)))"
version = "0.1.0"

[deps]
ACEpotentials = "d523d8c6-d3c4-4ff3-9c72-ed248b85d1e1"
EquivariantTensors = "5e107534-7145-4f8f-b06f-47a52840c895"
StaticArrays = "90137ffa-7385-5640-81b9-e52037218182"
LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
Serialization = "9e88b42a-f829-5b0c-bbe9-9e923198166b"
AtomsBase = "a963bdd2-2df7-4f54-a1ee-49d51e6be12a"
""")
    end
end

export export_ace_model_minimal
