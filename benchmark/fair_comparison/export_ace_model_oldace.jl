# Export an ACEpotentials model to trim-compatible Julia code
#
# Usage:
#   include("export_ace_model.jl")
#   export_ace_model(potential, "my_model.jl")
#
# The generated file can be compiled with:
#   julia --project=. juliac.jl --output-exe my_model --experimental --trim=safe my_model.jl

using ACEpotentials
using StaticArrays
using SparseArrays
using LinearAlgebra
using Polynomials4ML
const P4ML = Polynomials4ML
using EquivariantTensors
const ET = EquivariantTensors


"""
    export_ace_model(potential::ACEPotential, filename::String; splinify_first=true, for_library=false)

Export an ACEPotential to a trim-compatible Julia file.

Arguments:
- `potential`: The fitted ACEPotential to export
- `filename`: Output filename
- `splinify_first=true`: Splinify the model before export (recommended)
- `for_library=false`: If true, generate a shared library with C interface instead of executable
"""
function export_ace_model(potential::ACEpotentials.ACEPotential, filename::String;
                          splinify_first::Bool=true,
                          for_library::Bool=false)

    # Splinify if requested (recommended for export)
    if splinify_first && !(potential.model.rbasis isa ACEpotentials.Models.SplineRnlrzzBasis)
        @info "Splinifying model for export..."
        potential = ACEpotentials.splinify(potential, potential.ps)
    end

    model = potential.model
    ps = potential.ps

    # Extract components
    _i2z = model._i2z
    NZ = length(_i2z)

    # Tensor components
    tensor = model.tensor
    abasis_spec = tensor.abasis.spec
    aabasis = tensor.aabasis
    A2Bmaps = tensor.A2Bmaps

    # Radial basis
    rbasis = model.rbasis

    # Spherical harmonics
    ybasis = model.ybasis
    # Extract maxl from type parameter
    maxl = typeof(ybasis.scbasis).parameters[1]

    # Weights
    WB = ps.WB
    Wpair = haskey(ps, :Wpair) ? ps.Wpair : nothing

    # Vref
    Vref = model.Vref

    # Generate the export file
    open(filename, "w") do io
        _write_header(io, for_library)
        _write_species(io, _i2z)
        _write_tensor(io, tensor)
        _write_radial_basis(io, rbasis, NZ)
        _write_spherical_harmonics(io, maxl)
        _write_weights(io, WB, Wpair, NZ)
        _write_vref(io, Vref, _i2z)
        _write_evaluation_functions(io, tensor, NZ, Wpair !== nothing)
        if for_library
            _write_c_interface(io, NZ)
        else
            _write_main(io, NZ)
        end
    end

    @info "Exported model to $filename"
    return filename
end

function _write_header(io, for_library::Bool)
    if for_library
        println(io, """
# ACE Potential - Trim-compatible shared library export
# Generated by export_ace_model.jl
# Compile with: julia --project=. juliac.jl --output-lib libace.so --experimental --trim=safe model.jl

using StaticArrays
using LinearAlgebra: norm, dot
using SparseArrays: sparse, SparseMatrixCSC
using Polynomials4ML
const P4ML = Polynomials4ML
using EquivariantTensors
const ET = EquivariantTensors

# ============================================================================
# MODEL CONSTANTS - Pre-computed from fitted ACE model
# ============================================================================
""")
    else
        println(io, """
# ACE Potential - Trim-compatible export
# Generated by export_ace_model.jl
# Compile with: julia --project=. juliac.jl --output-exe model --experimental --trim=safe model.jl

using StaticArrays
using LinearAlgebra: norm, dot
using SparseArrays: sparse, SparseMatrixCSC
using Polynomials4ML
const P4ML = Polynomials4ML
using EquivariantTensors
const ET = EquivariantTensors

# ============================================================================
# MODEL CONSTANTS - Pre-computed from fitted ACE model
# ============================================================================
""")
    end
end

function _write_species(io, _i2z)
    println(io, """
# Species mapping: index -> atomic number
const I2Z = $(_i2z)
const NZ = $(length(_i2z))

# Helper to convert atomic number to index
@inline function z2i(Z::Integer)
    @inbounds for i in 1:NZ
        I2Z[i] == Z && return i
    end
    error("Unknown atomic number: \$Z")
end
""")
end

function _write_tensor(io, tensor)
    # Extract specs
    abasis_spec = tensor.abasis.spec
    aabasis = tensor.aabasis

    # Write PooledSparseProduct spec
    println(io, "# PooledSparseProduct specification")
    println(io, "const ABASIS_SPEC = $(repr(collect(abasis_spec)))")
    println(io, "const ABASIS = ET.PooledSparseProduct(ABASIS_SPEC)")
    println(io)

    # Write SparseSymmProd specs - as properly typed constants per order
    println(io, "# SparseSymmProd specification (typed per order)")
    for (ord, spec) in enumerate(aabasis.specs)
        if !isempty(spec)
            # Generate a tuple of tuples with explicit type
            tuples_str = join(["$(t)" for t in spec], ", ")
            println(io, "const AABASIS_SPECS_$(ord) = ($tuples_str,)  # Tuple of NTuple{$ord, Int}")
        end
    end
    println(io, "const AABASIS_RANGES = $(repr(aabasis.ranges))")
    println(io, "const AABASIS_HASCONST = $(aabasis.hasconst)")

    # Also keep the old format for _make_aabasis
    specs_data = []
    for spec in aabasis.specs
        push!(specs_data, [collect(t) for t in spec])
    end
    println(io, "const AABASIS_SPECS = $(repr(specs_data))")

    # Reconstruct SparseSymmProd
    println(io, """

# Reconstruct SparseSymmProd from specs
function _make_aabasis()
    specs = tuple([
        [NTuple{length(b), Int}(b) for b in spec]
        for spec in AABASIS_SPECS
    ]...)
    return ET.SparseSymmProd(specs, AABASIS_RANGES, AABASIS_HASCONST)
end
const AABASIS = _make_aabasis()
""")

    # Write A2B maps
    println(io, "# A2B coupling matrices")
    for (idx, A2B) in enumerate(tensor.A2Bmaps)
        I, J, V = findnz(A2B)
        m, n = size(A2B)
        println(io, "const A2BMAP_$(idx)_I = $(repr(I))")
        println(io, "const A2BMAP_$(idx)_J = $(repr(J))")
        println(io, "const A2BMAP_$(idx)_V = $(repr(V))")
        println(io, "const A2BMAP_$(idx)_SIZE = ($m, $n)")
    end

    nL = length(tensor.A2Bmaps)
    println(io, """

# Reconstruct A2B maps
function _make_A2Bmaps()
    return tuple($([
        "sparse(A2BMAP_$(i)_I, A2BMAP_$(i)_J, A2BMAP_$(i)_V, A2BMAP_$(i)_SIZE...)"
        for i in 1:nL
    ]...))
end
const A2BMAPS = _make_A2Bmaps()
""")

    # Write meta (ð”¸spec) - required for SparseACEbasis
    meta = tensor.meta
    ð”¸spec = meta["ð”¸spec"]
    println(io, "# Basis specification metadata")
    println(io, "const AA_SPEC = $(repr(ð”¸spec))::Vector{Vector{@NamedTuple{n::Int, l::Int, m::Int}}}")
    println(io, "const META = Dict{String, Any}(\"ð”¸spec\" => AA_SPEC)")
    println(io)

    # Assemble full tensor
    println(io, """
# Assemble full SparseACEbasis
const TENSOR = ET.SparseACEbasis(ABASIS, AABASIS, A2BMAPS, META)
""")
end

function _write_radial_basis(io, rbasis::ACEpotentials.Models.SplineRnlrzzBasis, NZ)
    println(io, """
# ============================================================================
# RADIAL BASIS (Spline-based)
# ============================================================================
""")

    # Write rin0cuts
    println(io, "# Cutoff parameters: (rin, r0, rcut) for each species pair")
    rcut_max = 0.0
    for iz in 1:NZ
        for jz in 1:NZ
            rin0cut = rbasis.rin0cuts[iz, jz]
            println(io, "const RIN0CUT_$(iz)_$(jz) = (rin=$(rin0cut.rin), r0=$(rin0cut.r0), rcut=$(rin0cut.rcut))")
            rcut_max = max(rcut_max, rin0cut.rcut)
        end
    end
    # Maximum cutoff across all species pairs (used for neighbor list construction)
    println(io, "const RCUT_MAX = $(rcut_max)")
    println(io)

    # Write spec
    println(io, "const R_SPEC = $(repr(rbasis.spec))")
    println(io, "const N_RNL = $(length(rbasis.spec))")
    println(io)

    # Write transforms
    println(io, "# Radial transforms")
    for iz in 1:NZ
        for jz in 1:NZ
            trans = rbasis.transforms[iz, jz]
            _write_transform(io, trans, iz, jz)
        end
    end

    # Write envelopes
    println(io, "# Radial envelopes")
    for iz in 1:NZ
        for jz in 1:NZ
            env = rbasis.envelopes[iz, jz]
            _write_envelope(io, env, iz, jz)
        end
    end

    # Write splines - this is the key data for evaluation
    println(io, "# Spline knots and coefficients")
    for iz in 1:NZ
        for jz in 1:NZ
            spl = rbasis.splines[iz, jz]
            _write_spline(io, spl, iz, jz)
        end
    end

    # Write evaluation function
    println(io, """

# Radial basis evaluation (returns SVector{N_RNL, T})
@inline function evaluate_Rnl(r::T, iz::Int, jz::Int)::SVector{N_RNL, T} where {T}
    # Get transform and envelope for this species pair
    # (Dispatched at compile time for small NZ)
    """)

    for iz in 1:NZ
        for jz in 1:NZ
            cond = iz == 1 && jz == 1 ? "if" : "elseif"
            println(io, "    $cond iz == $iz && jz == $jz")
            println(io, "        rcut = RIN0CUT_$(iz)_$(jz).rcut")
            println(io, "        if r >= rcut; return zero(SVector{N_RNL, T}); end")
            println(io, "        x = transform_$(iz)_$(jz)(r)")
            println(io, "        env = envelope_$(iz)_$(jz)(r, x)")
            println(io, "        return env .* spline_$(iz)_$(jz)(x)")
        end
    end
    println(io, "    end")
    println(io, "    # Fallback for unknown species pair")
    println(io, "    return zero(SVector{N_RNL, T})")
    println(io, "end")
    println(io)

    # Write evaluation with derivative function
    println(io, """
# Radial basis evaluation with derivative dRnl/dr
@inline function evaluate_Rnl_d(r::T, iz::Int, jz::Int)::Tuple{SVector{N_RNL, T}, SVector{N_RNL, T}} where {T}
    """)

    for iz in 1:NZ
        for jz in 1:NZ
            cond = iz == 1 && jz == 1 ? "if" : "elseif"
            println(io, "    $cond iz == $iz && jz == $jz")
            println(io, "        rcut = RIN0CUT_$(iz)_$(jz).rcut")
            println(io, "        if r >= rcut; return zero(SVector{N_RNL, T}), zero(SVector{N_RNL, T}); end")
            println(io, "        # Transform with derivative")
            println(io, "        x, dx_dr = transform_d_$(iz)_$(jz)(r)")
            println(io, "        # Envelope with derivative")
            println(io, "        env, denv_dx = envelope_d_$(iz)_$(jz)(r, x)")
            println(io, "        # Spline with derivative")
            println(io, "        spl, dspl_dx = spline_d_$(iz)_$(jz)(x)")
            println(io, "        # Rnl = env * spl")
            println(io, "        Rnl = env .* spl")
            println(io, "        # dRnl/dr = denv/dr * spl + env * dspl/dr")
            println(io, "        #         = denv/dx * dx/dr * spl + env * dspl/dx * dx/dr")
            println(io, "        dRnl_dr = (denv_dx * dx_dr) .* spl .+ env .* dspl_dx .* dx_dr")
            println(io, "        return Rnl, dRnl_dr")
        end
    end
    println(io, "    end")
    println(io, "    # Fallback for unknown species pair")
    println(io, "    return zero(SVector{N_RNL, T}), zero(SVector{N_RNL, T})")
    println(io, "end")
    println(io)
end

function _write_transform(io, trans::ACEpotentials.Models.NormalizedTransform, iz, jz)
    inner = trans.trans
    println(io, """
# Transform $(iz)-$(jz): NormalizedTransform
const TRANS_$(iz)_$(jz)_YIN = $(trans.yin)
const TRANS_$(iz)_$(jz)_YCUT = $(trans.ycut)
const TRANS_$(iz)_$(jz)_P = $(inner.p)
const TRANS_$(iz)_$(jz)_Q = $(inner.q)
const TRANS_$(iz)_$(jz)_R0 = $(inner.r0)
const TRANS_$(iz)_$(jz)_RIN = $(inner.rin)
const TRANS_$(iz)_$(jz)_A = $(inner.a)

@inline function transform_$(iz)_$(jz)(r::T) where {T}
    rin = TRANS_$(iz)_$(jz)_RIN
    if r <= rin
        return one(T)
    end
    r0, q, p, a = TRANS_$(iz)_$(jz)_R0, TRANS_$(iz)_$(jz)_Q, TRANS_$(iz)_$(jz)_P, TRANS_$(iz)_$(jz)_A
    s = (r - rin) / (r0 - rin)
    y = (a + s^q) / (a + s^p)
    # Normalize
    yin, ycut = TRANS_$(iz)_$(jz)_YIN, TRANS_$(iz)_$(jz)_YCUT
    return clamp(-one(T) + 2 * (y - yin) / (ycut - yin), -one(T), one(T))
end

# Transform with derivative dx/dr
@inline function transform_d_$(iz)_$(jz)(r::T) where {T}
    rin = TRANS_$(iz)_$(jz)_RIN
    if r <= rin
        return one(T), zero(T)
    end
    r0, q, p, a = TRANS_$(iz)_$(jz)_R0, TRANS_$(iz)_$(jz)_Q, TRANS_$(iz)_$(jz)_P, TRANS_$(iz)_$(jz)_A
    yin, ycut = TRANS_$(iz)_$(jz)_YIN, TRANS_$(iz)_$(jz)_YCUT

    s = (r - rin) / (r0 - rin)
    ds_dr = one(T) / (r0 - rin)

    # y = (a + s^q) / (a + s^p)
    num = a + s^q
    den = a + s^p
    y = num / den

    # dy/ds = (q*s^(q-1)*den - p*s^(p-1)*num) / den^2
    dnum_ds = q > 0 ? q * s^(q-1) : zero(T)
    dden_ds = p > 0 ? p * s^(p-1) : zero(T)
    dy_ds = (dnum_ds * den - dden_ds * num) / (den * den)
    dy_dr = dy_ds * ds_dr

    # x = -1 + 2*(y - yin)/(ycut - yin)
    scale = 2 / (ycut - yin)
    x = -one(T) + scale * (y - yin)
    dx_dr = scale * dy_dr

    # Clamp: if outside [-1, 1], derivative is zero
    if x <= -one(T) || x >= one(T)
        return clamp(x, -one(T), one(T)), zero(T)
    end
    return x, dx_dr
end
""")
end

function _write_envelope(io, env::ACEpotentials.Models.PolyEnvelope2sX, iz, jz)
    println(io, """
# Envelope $(iz)-$(jz): PolyEnvelope2sX
const ENV_$(iz)_$(jz)_X1 = $(env.x1)
const ENV_$(iz)_$(jz)_X2 = $(env.x2)
const ENV_$(iz)_$(jz)_P1 = $(env.p1)
const ENV_$(iz)_$(jz)_P2 = $(env.p2)
const ENV_$(iz)_$(jz)_S = $(env.s)

@inline function envelope_$(iz)_$(jz)(r::T, x::T) where {T}
    x1, x2 = ENV_$(iz)_$(jz)_X1, ENV_$(iz)_$(jz)_X2
    if !(x1 < x < x2)
        return zero(T)
    end
    p1, p2, s = ENV_$(iz)_$(jz)_P1, ENV_$(iz)_$(jz)_P2, ENV_$(iz)_$(jz)_S
    return s * (x - x1)^p1 * (x2 - x)^p2
end

# Envelope with derivative denv/dx
@inline function envelope_d_$(iz)_$(jz)(r::T, x::T) where {T}
    x1, x2 = ENV_$(iz)_$(jz)_X1, ENV_$(iz)_$(jz)_X2
    if !(x1 < x < x2)
        return zero(T), zero(T)
    end
    p1, p2, s = ENV_$(iz)_$(jz)_P1, ENV_$(iz)_$(jz)_P2, ENV_$(iz)_$(jz)_S

    # env = s * (x - x1)^p1 * (x2 - x)^p2
    left = (x - x1)^p1
    right = (x2 - x)^p2
    env = s * left * right

    # denv/dx = s * (p1*(x-x1)^(p1-1)*(x2-x)^p2 - p2*(x-x1)^p1*(x2-x)^(p2-1))
    dleft_dx = p1 > 0 ? p1 * (x - x1)^(p1-1) : zero(T)
    dright_dx = p2 > 0 ? -p2 * (x2 - x)^(p2-1) : zero(T)
    denv_dx = s * (dleft_dx * right + left * dright_dx)

    return env, denv_dx
end
""")
end

function _write_spline(io, spl, iz, jz)
    # Extract spline data
    # The spline is a ScaledInterpolation wrapping a BSplineInterpolation
    itp = spl.itp  # ScaledInterpolation
    inner_itp = itp.itp  # BSplineInterpolation

    # Get the knots and coefficients
    knots = itp.ranges[1]  # The x values (StepRangeLen)
    x_start = first(knots)
    x_step = step(knots)
    x_len = length(knots)

    # Get coefficients (these are SVector values)
    coeffs = inner_itp.coefs
    n_rnl = length(first(coeffs))

    # Write coefficients as a Tuple of SVectors for type stability
    println(io, """
# Spline $(iz)-$(jz)
const SPL_$(iz)_$(jz)_XSTART = $(x_start)
const SPL_$(iz)_$(jz)_XSTEP = $(x_step)
const SPL_$(iz)_$(jz)_XLEN = $(x_len)
""")

    # Write each coefficient as an SVector
    print(io, "const SPL_$(iz)_$(jz)_COEFFS = (\n")
    for (i, c) in enumerate(coeffs)
        vals = join(["$v" for v in c], ", ")
        print(io, "    SVector{$(n_rnl), Float64}($(vals))")
        if i < length(coeffs)
            println(io, ",")
        else
            println(io)
        end
    end
    println(io, ")")
    println(io)

    println(io, """
# Linear interpolation of spline coefficients
@inline function spline_$(iz)_$(jz)(x::T) where {T}
    # Find interval
    idx_f = (x - SPL_$(iz)_$(jz)_XSTART) / SPL_$(iz)_$(jz)_XSTEP + 1
    idx = floor(Int, idx_f)
    idx = clamp(idx, 1, SPL_$(iz)_$(jz)_XLEN - 1)
    t = T(idx_f - idx)

    # Linear interpolation between spline coefficients (type-stable via Tuple indexing)
    @inbounds c0 = SPL_$(iz)_$(jz)_COEFFS[idx]
    @inbounds c1 = SPL_$(iz)_$(jz)_COEFFS[idx+1]
    return (one(T) - t) .* c0 .+ t .* c1
end

# Spline with derivative dspl/dx
@inline function spline_d_$(iz)_$(jz)(x::T) where {T}
    # Find interval
    idx_f = (x - SPL_$(iz)_$(jz)_XSTART) / SPL_$(iz)_$(jz)_XSTEP + 1
    idx = floor(Int, idx_f)
    idx = clamp(idx, 1, SPL_$(iz)_$(jz)_XLEN - 1)
    t = T(idx_f - idx)

    @inbounds c0 = SPL_$(iz)_$(jz)_COEFFS[idx]
    @inbounds c1 = SPL_$(iz)_$(jz)_COEFFS[idx+1]

    # spl = (1-t)*c0 + t*c1
    spl = (one(T) - t) .* c0 .+ t .* c1

    # dspl/dx = dspl/dt * dt/dx = (c1 - c0) / step
    dspl_dx = (c1 .- c0) ./ T(SPL_$(iz)_$(jz)_XSTEP)

    return spl, dspl_dx
end
""")
end

function _write_spherical_harmonics(io, maxl)
    println(io, """
# ============================================================================
# SPHERICAL HARMONICS
# ============================================================================

const MAXL = $(maxl)
const YBASIS = P4ML.real_sphericalharmonics(MAXL)
const N_YLM = length(YBASIS)
""")
end

function _write_weights(io, WB, Wpair, NZ)
    println(io, """
# ============================================================================
# MODEL WEIGHTS
# ============================================================================
""")

    # Write basis size constant
    n_basis = size(WB, 1)
    println(io, "# Number of basis functions")
    println(io, "const N_BASIS = $(n_basis)")
    println(io)

    # Write WB weights
    println(io, "# B basis weights (per species)")
    for iz in 1:NZ
        w = WB[:, iz]
        println(io, "const WB_$(iz) = $(repr(collect(w)))")
    end
    println(io)

    # Write Wpair weights if present
    if Wpair !== nothing
        println(io, "# Pair basis weights (per species)")
        for iz in 1:NZ
            w = Wpair[:, iz]
            println(io, "const WPAIR_$(iz) = $(repr(collect(w)))")
        end
        println(io)
    end
end

function _write_vref(io, Vref, _i2z)
    println(io, """
# ============================================================================
# REFERENCE ENERGIES (E0)
# ============================================================================
""")

    # Extract E0 values
    for (iz, Z) in enumerate(_i2z)
        E0 = Vref.E0[Z]
        println(io, "const E0_$(iz) = $(E0)  # Z=$(Z)")
    end
    println(io)
end

function _write_evaluation_functions(io, tensor, NZ, has_pair)
    println(io, """
# ============================================================================
# EVALUATION FUNCTIONS
# ============================================================================

# Compute embeddings for all neighbors (values only)
function compute_embeddings(Rs::Vector{SVector{3, Float64}}, Zs::Vector{<:Integer}, Z0::Integer)
    nneigh = length(Rs)
    iz0 = z2i(Z0)

    # Allocate output arrays
    Rnl = zeros(Float64, nneigh, N_RNL)
    Ylm = zeros(Float64, nneigh, N_YLM)

    for j in 1:nneigh
        r = norm(Rs[j])
        if r > 1e-10
            jz = z2i(Zs[j])
            Rnl_j = evaluate_Rnl(r, iz0, jz)
            Rnl[j, :] .= Rnl_j

            rhat = Rs[j] / r
            P4ML.evaluate!(view(Ylm, j, :), YBASIS, rhat)
        end
    end

    return Rnl, Ylm
end

# Compute embeddings with derivatives for analytic forces
function compute_embeddings_ed(Rs::Vector{SVector{3, Float64}}, Zs::Vector{<:Integer}, Z0::Integer)
    nneigh = length(Rs)
    iz0 = z2i(Z0)

    # Allocate output arrays
    Rnl = zeros(Float64, nneigh, N_RNL)
    dRnl = zeros(Float64, nneigh, N_RNL)  # dRnl/dr (scalar)
    Ylm = zeros(Float64, nneigh, N_YLM)
    dYlm = zeros(SVector{3, Float64}, nneigh, N_YLM)  # dYlm/drÌ‚ (3-vector)

    # Also store radii and unit vectors for force assembly
    rs = zeros(Float64, nneigh)
    rhats = zeros(SVector{3, Float64}, nneigh)

    for j in 1:nneigh
        r = norm(Rs[j])
        rs[j] = r
        if r > 1e-10
            rhat = Rs[j] / r
            rhats[j] = rhat
            jz = z2i(Zs[j])

            # Radial basis with derivative
            Rnl_j, dRnl_j = evaluate_Rnl_d(r, iz0, jz)
            Rnl[j, :] .= Rnl_j
            dRnl[j, :] .= dRnl_j

            # Spherical harmonics with derivatives
            Ylm_j, dYlm_j = P4ML.evaluate_ed(YBASIS, rhat)
            Ylm[j, :] .= Ylm_j
            dYlm[j, :] .= dYlm_j
        end
    end

    return Rnl, dRnl, Ylm, dYlm, rs, rhats
end

# Site energy evaluation
function site_energy(Rs::Vector{SVector{3, Float64}}, Zs::Vector{<:Integer}, Z0::Integer)
    iz0 = z2i(Z0)

    if length(Rs) == 0
        # Return E0 for isolated atom
""")

    # Write E0 lookup
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "        $cond iz0 == $iz; return E0_$iz")
    end
    println(io, "        end")

    println(io, """
    end

    # Compute embeddings
    Rnl, Ylm = compute_embeddings(Rs, Zs, Z0)

    # Evaluate tensor
    BB = ET.evaluate(TENSOR, Rnl, Ylm, NamedTuple(), NamedTuple())
    B = BB[1]

    # Contract with weights
""")

    # Write weight contraction
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "    $cond iz0 == $iz")
        println(io, "        val = dot(B, WB_$iz)")
    end
    println(io, "    end")

    # Add E0
    println(io, """

    # Add reference energy
""")
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "    $cond iz0 == $iz; val += E0_$iz")
    end
    println(io, "    end")

    println(io, """

    return val
end

# Site basis evaluation (returns raw basis vector without weight contraction)
function site_basis(Rs::Vector{SVector{3, Float64}}, Zs::Vector{<:Integer}, Z0::Integer)
    if length(Rs) == 0
        # Return zeros for isolated atom
        return zeros(Float64, N_BASIS)
    end

    # Compute embeddings
    Rnl, Ylm = compute_embeddings(Rs, Zs, Z0)

    # Evaluate tensor
    BB = ET.evaluate(TENSOR, Rnl, Ylm, NamedTuple(), NamedTuple())
    B = BB[1]

    return collect(B)
end

# ============================================================================
# MANUAL PULLBACK FUNCTIONS (trim-safe)
# ============================================================================

# Static product with gradient (for SparseSymmProd pullback)
@inline function _static_prod_ed(b::NTuple{1, T}) where {T}
    return b[1], (one(T),)
end

@inline function _static_prod_ed(b::NTuple{2, T}) where {T}
    return b[1] * b[2], (b[2], b[1])
end

@inline function _static_prod_ed(b::NTuple{3, T}) where {T}
    p12 = b[1] * b[2]
    return p12 * b[3], (b[2] * b[3], b[1] * b[3], p12)
end

@inline function _static_prod_ed(b::NTuple{4, T}) where {T}
    p12 = b[1] * b[2]
    p34 = b[3] * b[4]
    return p12 * p34, (b[2] * p34, b[1] * p34, p12 * b[4], p12 * b[3])
end

# Manual pullback through PooledSparseProduct (abasis): âˆ‚A -> (âˆ‚Rnl, âˆ‚Ylm)
# This is the key function that replaces ET.pullback for the abasis
function pullback_abasis!(âˆ‚Rnl::Matrix{T}, âˆ‚Ylm::Matrix{T},
                          âˆ‚A::Vector{T},
                          Rnl::Matrix{T}, Ylm::Matrix{T}) where {T}
    fill!(âˆ‚Rnl, zero(T))
    fill!(âˆ‚Ylm, zero(T))
    nX = size(Rnl, 1)

    @inbounds for (iA, Ï•) in enumerate(ABASIS_SPEC)
        Ï•1, Ï•2 = Ï•  # (Rnl index, Ylm index)
        âˆ‚A_iA = âˆ‚A[iA]
        @simd ivdep for j = 1:nX
            âˆ‚Rnl[j, Ï•1] += âˆ‚A_iA * Ylm[j, Ï•2]
            âˆ‚Ylm[j, Ï•2] += âˆ‚A_iA * Rnl[j, Ï•1]
        end
    end
    return âˆ‚Rnl, âˆ‚Ylm
end
""")

    # Write the aabasis pullback with the correct order
    aabasis = tensor.aabasis
    max_order = length(aabasis.specs)

    println(io, """
# Manual pullback through SparseSymmProd (aabasis): âˆ‚AA -> âˆ‚A
function pullback_aabasis!(âˆ‚A::Vector{T}, âˆ‚AA::Vector{T}, A::Vector{T}) where {T}
    fill!(âˆ‚A, zero(T))
""")

    # Generate pullback code for each order
    for ord in 1:max_order
        spec = aabasis.specs[ord]
        range_start = aabasis.ranges[ord].start
        range_stop = aabasis.ranges[ord].stop

        if isempty(spec)
            continue
        end

        println(io, "    # Order $ord terms (indices $range_start:$range_stop)")
        println(io, "    @inbounds for (i_local, Ï•) in enumerate(AABASIS_SPECS_$ord)")
        println(io, "        i = $(range_start - 1) + i_local")
        println(io, "        âˆ‚AA_i = âˆ‚AA[i]")

        if ord == 1
            println(io, "        âˆ‚A[Ï•[1]] += âˆ‚AA_i")
        elseif ord == 2
            println(io, "        a1, a2 = A[Ï•[1]], A[Ï•[2]]")
            println(io, "        âˆ‚A[Ï•[1]] += âˆ‚AA_i * a2")
            println(io, "        âˆ‚A[Ï•[2]] += âˆ‚AA_i * a1")
        elseif ord == 3
            println(io, "        a1, a2, a3 = A[Ï•[1]], A[Ï•[2]], A[Ï•[3]]")
            println(io, "        âˆ‚A[Ï•[1]] += âˆ‚AA_i * a2 * a3")
            println(io, "        âˆ‚A[Ï•[2]] += âˆ‚AA_i * a1 * a3")
            println(io, "        âˆ‚A[Ï•[3]] += âˆ‚AA_i * a1 * a2")
        elseif ord == 4
            println(io, "        a1, a2, a3, a4 = A[Ï•[1]], A[Ï•[2]], A[Ï•[3]], A[Ï•[4]]")
            println(io, "        âˆ‚A[Ï•[1]] += âˆ‚AA_i * a2 * a3 * a4")
            println(io, "        âˆ‚A[Ï•[2]] += âˆ‚AA_i * a1 * a3 * a4")
            println(io, "        âˆ‚A[Ï•[3]] += âˆ‚AA_i * a1 * a2 * a4")
            println(io, "        âˆ‚A[Ï•[4]] += âˆ‚AA_i * a1 * a2 * a3")
        else
            # General case using _static_prod_ed
            println(io, "        aa = ntuple(t -> A[Ï•[t]], Val($ord))")
            println(io, "        _, gi = _static_prod_ed(aa)")
            println(io, "        for t in 1:$ord")
            println(io, "            âˆ‚A[Ï•[t]] += âˆ‚AA_i * gi[t]")
            println(io, "        end")
        end
        println(io, "    end")
        println(io)
    end

    println(io, "    return âˆ‚A")
    println(io, "end")
    println(io)

    # Write the full tensor pullback
    println(io, """
# Full manual pullback through tensor: âˆ‚B -> (âˆ‚Rnl, âˆ‚Ylm)
# This replaces ET.pullback with a trim-safe implementation
function tensor_pullback!(âˆ‚Rnl::Matrix{T}, âˆ‚Ylm::Matrix{T},
                          âˆ‚B::Vector{T},
                          Rnl::Matrix{T}, Ylm::Matrix{T},
                          A::Vector{T}) where {T}
    nA = length(A)
    nAA = length(AABASIS)

    # Step 1: âˆ‚AA = A2Bmap' * âˆ‚B (sparse transpose multiplication)
    âˆ‚AA = zeros(T, nAA)
    @inbounds for (I_idx, I) in enumerate(A2BMAP_1_I)
        J = A2BMAP_1_J[I_idx]
        V = A2BMAP_1_V[I_idx]
        âˆ‚AA[J] += V * âˆ‚B[I]  # Transpose: A2Bmap'[J,I] = A2Bmap[I,J]
    end

    # Step 2: âˆ‚A = pullback_aabasis(âˆ‚AA, A)
    âˆ‚A = zeros(T, nA)
    pullback_aabasis!(âˆ‚A, âˆ‚AA, A)

    # Step 3: (âˆ‚Rnl, âˆ‚Ylm) = pullback_abasis(âˆ‚A, Rnl, Ylm)
    pullback_abasis!(âˆ‚Rnl, âˆ‚Ylm, âˆ‚A, Rnl, Ylm)

    return âˆ‚Rnl, âˆ‚Ylm
end

# Site energy with ANALYTIC forces using manual pullback (trim-safe)
function site_energy_forces(Rs::Vector{SVector{3, Float64}}, Zs::Vector{<:Integer}, Z0::Integer)
    iz0 = z2i(Z0)
    nneigh = length(Rs)

    if nneigh == 0
        # Return E0 for isolated atom, no forces
""")

    # Write E0 lookup for forces function
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "        $cond iz0 == $iz; return E0_$iz, SVector{3, Float64}[]")
    end
    println(io, "        end")

    println(io, """
    end

    # Compute embeddings with derivatives
    Rnl, dRnl, Ylm, dYlm, rs, rhats = compute_embeddings_ed(Rs, Zs, Z0)

    # Forward pass: compute A basis (needed for pullback)
    A = zeros(Float64, length(TENSOR.abasis))
    ET.evaluate!(A, TENSOR.abasis, (Rnl, Ylm))

    # Evaluate tensor (using ET for forward pass)
    BB = ET.evaluate(TENSOR, Rnl, Ylm, NamedTuple(), NamedTuple())
    B = BB[1]

    # Contract with weights to get energy
""")

    # Write weight contraction for forces
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "    $cond iz0 == $iz")
        println(io, "        Ei = dot(B, WB_$iz)")
        println(io, "        âˆ‚B = collect(WB_$iz)  # âˆ‚Ei/âˆ‚B = WB (as Vector)")
    end
    println(io, "    end")

    println(io, """

    # Backward pass through tensor using MANUAL pullback (trim-safe)
    âˆ‚Rnl = zeros(Float64, size(Rnl))
    âˆ‚Ylm = zeros(Float64, size(Ylm))
    tensor_pullback!(âˆ‚Rnl, âˆ‚Ylm, âˆ‚B, Rnl, Ylm, A)

    # Assemble forces: âˆ‚Ei/âˆ‚Râ±¼
    forces = Vector{SVector{3, Float64}}(undef, nneigh)
    for j in 1:nneigh
        f = zero(SVector{3, Float64})
        r = rs[j]
        if r > 1e-10
            rhat = rhats[j]
            # Contribution from radial basis: âˆ‚Ei/âˆ‚Rnl * dRnl/dr * rÌ‚
            for t in 1:N_RNL
                f = f + (âˆ‚Rnl[j, t] * dRnl[j, t]) * rhat
            end
            # Contribution from spherical harmonics: âˆ‚Ei/âˆ‚Ylm * dYlm/drÌ‚
            for t in 1:N_YLM
                f = f + âˆ‚Ylm[j, t] * dYlm[j, t]
            end
        end
        forces[j] = -f  # Force is negative gradient
    end

    # Add reference energy
""")

    # Add E0
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "    $cond iz0 == $iz; Ei += E0_$iz")
    end
    println(io, "    end")

    println(io, """

    return Ei, forces
end

# Site energy with forces AND virial stress using manual pullback (trim-safe)
function site_energy_forces_virial(Rs::Vector{SVector{3, Float64}}, Zs::Vector{<:Integer}, Z0::Integer)
    iz0 = z2i(Z0)
    nneigh = length(Rs)

    # Initialize virial tensor (3x3 symmetric)
    virial = zeros(SMatrix{3, 3, Float64, 9})

    if nneigh == 0
        # Return E0 for isolated atom, no forces/virial
""")

    # Write E0 lookup for virial function
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "        $cond iz0 == $iz; return E0_$iz, SVector{3, Float64}[], virial")
    end
    println(io, "        end")

    println(io, """
    end

    # Compute embeddings with derivatives
    Rnl, dRnl, Ylm, dYlm, rs, rhats = compute_embeddings_ed(Rs, Zs, Z0)

    # Forward pass: compute A basis (needed for pullback)
    A = zeros(Float64, length(TENSOR.abasis))
    ET.evaluate!(A, TENSOR.abasis, (Rnl, Ylm))

    # Evaluate tensor (using ET for forward pass)
    BB = ET.evaluate(TENSOR, Rnl, Ylm, NamedTuple(), NamedTuple())
    B = BB[1]

    # Contract with weights to get energy
""")

    # Write weight contraction for virial
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "    $cond iz0 == $iz")
        println(io, "        Ei = dot(B, WB_$iz)")
        println(io, "        âˆ‚B = collect(WB_$iz)  # âˆ‚Ei/âˆ‚B = WB (as Vector)")
    end
    println(io, "    end")

    println(io, """

    # Backward pass through tensor using MANUAL pullback (trim-safe)
    âˆ‚Rnl = zeros(Float64, size(Rnl))
    âˆ‚Ylm = zeros(Float64, size(Ylm))
    tensor_pullback!(âˆ‚Rnl, âˆ‚Ylm, âˆ‚B, Rnl, Ylm, A)

    # Assemble forces and virial
    forces = Vector{SVector{3, Float64}}(undef, nneigh)
    for j in 1:nneigh
        f = zero(SVector{3, Float64})
        r = rs[j]
        if r > 1e-10
            rhat = rhats[j]
            Rj = Rs[j]
            # Contribution from radial basis
            for t in 1:N_RNL
                df = (âˆ‚Rnl[j, t] * dRnl[j, t]) * rhat
                f = f + df
                # Virial: -Râ±¼ âŠ— fâ±¼ (outer product)
                virial = virial - Rj * df'
            end
            # Contribution from spherical harmonics
            for t in 1:N_YLM
                df = âˆ‚Ylm[j, t] * dYlm[j, t]
                f = f + df
                virial = virial - Rj * df'
            end
        end
        forces[j] = -f
    end

    # Add reference energy
""")

    # Add E0 for virial
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "    $cond iz0 == $iz; Ei += E0_$iz")
    end
    println(io, "    end")

    println(io, """

    return Ei, forces, virial
end
""")
end

function _write_main(io, NZ)
    println(io, """
# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

function (@main)(ARGS)
    println(Core.stdout, "=== ACE Potential Evaluation ===")
    println(Core.stdout, "Number of species: ", NZ)
    println(Core.stdout, "Tensor length: ", length(TENSOR))
    println(Core.stdout, "Radial basis size: ", N_RNL)
    println(Core.stdout, "Spherical harmonics: L=", MAXL, " (", N_YLM, " functions)")

    # Example evaluation with test data
    Rs = [
        SVector(2.35, 0.0, 0.0),
        SVector(-0.78, 2.22, 0.0),
        SVector(-0.78, -1.11, 1.92),
    ]
    Zs = fill(I2Z[1], length(Rs))  # Same species as center
    Z0 = I2Z[1]  # Center atom species

    println(Core.stdout, "")
    println(Core.stdout, "Test evaluation:")
    println(Core.stdout, "  Center species: Z=", Z0)
    println(Core.stdout, "  Number of neighbors: ", length(Rs))

    # Energy only
    E = site_energy(Rs, Zs, Z0)
    println(Core.stdout, "  Site energy: ", E, " eV")

    # Analytic forces
    println(Core.stdout, "")
    println(Core.stdout, "Analytic forces:")
    E2, F = site_energy_forces(Rs, Zs, Z0)
    for (j, f) in enumerate(F)
        println(Core.stdout, "  F[", j, "] = [", f[1], ", ", f[2], ", ", f[3], "]")
    end

    # Forces + Virial
    println(Core.stdout, "")
    println(Core.stdout, "With virial stress:")
    E3, F3, V = site_energy_forces_virial(Rs, Zs, Z0)
    println(Core.stdout, "  Energy: ", E3, " eV")
    println(Core.stdout, "  Virial tensor:")
    println(Core.stdout, "    [", V[1,1], ", ", V[1,2], ", ", V[1,3], "]")
    println(Core.stdout, "    [", V[2,1], ", ", V[2,2], ", ", V[2,3], "]")
    println(Core.stdout, "    [", V[3,1], ", ", V[3,2], ", ", V[3,3], "]")

    # Verify analytic vs finite difference forces
    println(Core.stdout, "")
    println(Core.stdout, "Force verification (analytic vs finite difference):")
    h = 1e-5
    max_err = 0.0
    for j in 1:length(Rs)
        f_fd = zeros(3)
        for Î± in 1:3
            Rs_p = copy(Rs)
            Rs_m = copy(Rs)
            e_Î± = zeros(3); e_Î±[Î±] = h
            Rs_p[j] = Rs[j] + SVector{3}(e_Î±)
            Rs_m[j] = Rs[j] - SVector{3}(e_Î±)
            Ep = site_energy(Rs_p, Zs, Z0)
            Em = site_energy(Rs_m, Zs, Z0)
            f_fd[Î±] = -(Ep - Em) / (2h)
        end
        err = sqrt(sum((F[j] - SVector{3}(f_fd)).^2))
        max_err = max(max_err, err)
        println(Core.stdout, "  F[", j, "] err = ", err)
    end
    println(Core.stdout, "  Max force error: ", max_err)

    println(Core.stdout, "")
    println(Core.stdout, "Evaluation successful!")

    return 0
end
""")
end

function _write_c_interface(io, NZ)
    println(io, """
# ============================================================================
# C INTERFACE FOR SHARED LIBRARY
# ============================================================================
#
# Two API levels:
# 1. SITE-LEVEL (for LAMMPS): Works with pre-computed neighbor lists
# 2. SYSTEM-LEVEL (for Python/ASE): Computes neighbor list internally

# ============================================================================
# HELPER FUNCTIONS FOR C INTERFACE
# ============================================================================

@inline function c_read_Rij(ptr::Ptr{Cdouble}, nneigh::Int)::Vector{SVector{3, Float64}}
    Rs = Vector{SVector{3, Float64}}(undef, nneigh)
    @inbounds for j in 1:nneigh
        x = unsafe_load(ptr, 3*(j-1) + 1)
        y = unsafe_load(ptr, 3*(j-1) + 2)
        z = unsafe_load(ptr, 3*(j-1) + 3)
        Rs[j] = SVector(x, y, z)
    end
    return Rs
end

@inline function c_read_species(ptr::Ptr{Cint}, n::Int)::Vector{Int}
    species = Vector{Int}(undef, n)
    @inbounds for i in 1:n
        species[i] = unsafe_load(ptr, i)
    end
    return species
end

@inline function c_write_forces!(ptr::Ptr{Cdouble}, forces::Vector{SVector{3, Float64}})
    @inbounds for j in 1:length(forces)
        unsafe_store!(ptr, forces[j][1], 3*(j-1) + 1)
        unsafe_store!(ptr, forces[j][2], 3*(j-1) + 2)
        unsafe_store!(ptr, forces[j][3], 3*(j-1) + 3)
    end
end

@inline function c_write_virial!(ptr::Ptr{Cdouble}, virial::SMatrix{3,3,Float64,9})
    # Voigt notation: xx, yy, zz, yz, xz, xy (LAMMPS convention)
    unsafe_store!(ptr, virial[1,1], 1)  # xx
    unsafe_store!(ptr, virial[2,2], 2)  # yy
    unsafe_store!(ptr, virial[3,3], 3)  # zz
    unsafe_store!(ptr, virial[2,3], 4)  # yz
    unsafe_store!(ptr, virial[1,3], 5)  # xz
    unsafe_store!(ptr, virial[1,2], 6)  # xy
end

# ============================================================================
# SITE-LEVEL C INTERFACE (for LAMMPS)
# ============================================================================
# These work directly with LAMMPS neighbor lists.
# Forces returned are forces ON the neighbors (not on the center atom).
# LAMMPS handles force accumulation via Newton's 3rd law.

Base.@ccallable function ace_site_energy(
    z0::Cint,
    nneigh::Cint,
    neighbor_z::Ptr{Cint},
    neighbor_Rij::Ptr{Cdouble}
)::Cdouble
    if nneigh == 0
        # Return E0 for isolated atom
        iz0 = z2i(z0)
""")

    # Generate E0 lookup for each species
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "        $cond iz0 == $iz; return E0_$iz")
    end
    println(io, "        end")
    println(io, "        return 0.0")
    println(io, "    end")

    println(io, """

    Zs = c_read_species(neighbor_z, Int(nneigh))
    Rs = c_read_Rij(neighbor_Rij, Int(nneigh))

    return site_energy(Rs, Zs, Int(z0))
end

Base.@ccallable function ace_site_energy_forces(
    z0::Cint,
    nneigh::Cint,
    neighbor_z::Ptr{Cint},
    neighbor_Rij::Ptr{Cdouble},
    forces::Ptr{Cdouble}
)::Cdouble
    if nneigh == 0
        iz0 = z2i(z0)
""")

    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "        $cond iz0 == $iz; return E0_$iz")
    end
    println(io, "        end")
    println(io, "        return 0.0")
    println(io, "    end")

    println(io, """

    Zs = c_read_species(neighbor_z, Int(nneigh))
    Rs = c_read_Rij(neighbor_Rij, Int(nneigh))

    Ei, Fi = site_energy_forces(Rs, Zs, Int(z0))

    # Write forces (these are -dE/dRj, the force ON neighbor j)
    c_write_forces!(forces, Fi)

    return Ei
end

Base.@ccallable function ace_site_energy_forces_virial(
    z0::Cint,
    nneigh::Cint,
    neighbor_z::Ptr{Cint},
    neighbor_Rij::Ptr{Cdouble},
    forces::Ptr{Cdouble},
    virial::Ptr{Cdouble}
)::Cdouble
    if nneigh == 0
        iz0 = z2i(z0)
        # Zero virial for isolated atom
        for k in 1:6
            unsafe_store!(virial, 0.0, k)
        end
""")

    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "        $cond iz0 == $iz; return E0_$iz")
    end
    println(io, "        end")
    println(io, "        return 0.0")
    println(io, "    end")

    println(io, """

    Zs = c_read_species(neighbor_z, Int(nneigh))
    Rs = c_read_Rij(neighbor_Rij, Int(nneigh))

    Ei, Fi, Vi = site_energy_forces_virial(Rs, Zs, Int(z0))

    c_write_forces!(forces, Fi)
    c_write_virial!(virial, Vi)

    return Ei
end

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

Base.@ccallable function ace_get_cutoff()::Cdouble
    return RCUT_MAX
end

Base.@ccallable function ace_get_n_species()::Cint
    return Cint(NZ)
end

Base.@ccallable function ace_get_species(idx::Cint)::Cint
    if idx < 1 || idx > NZ
        return Cint(-1)
    end
    return Cint(I2Z[idx])
end

Base.@ccallable function ace_get_n_basis()::Cint
    return Cint(N_BASIS)
end

# ============================================================================
# BASIS EVALUATION (for descriptor computation)
# ============================================================================

Base.@ccallable function ace_site_basis(
    z0::Cint,
    nneigh::Cint,
    neighbor_z::Ptr{Cint},
    neighbor_Rij::Ptr{Cdouble},
    basis_out::Ptr{Cdouble}
)::Cint
    if nneigh == 0
        # Return zeros for isolated atom
        for k in 1:N_BASIS
            unsafe_store!(basis_out, 0.0, k)
        end
        return Cint(0)
    end

    Zs = c_read_species(neighbor_z, Int(nneigh))
    Rs = c_read_Rij(neighbor_Rij, Int(nneigh))

    B = site_basis(Rs, Zs, Int(z0))

    # Write basis to output buffer
    for k in 1:N_BASIS
        unsafe_store!(basis_out, B[k], k)
    end

    return Cint(0)  # Success
end

# ============================================================================
# BATCH API
# ============================================================================
# Process multiple atoms at once, reducing Python-Julia FFI call overhead.
# Note: Threads.@threads doesn't work with --trim=safe (closures are trimmed).
# For multi-threaded evaluation, use LAMMPS (OpenMP) or IPICalculator.

Base.@ccallable function ace_batch_energy_forces_virial(
    natoms::Cint,
    z::Ptr{Cint},
    neighbor_counts::Ptr{Cint},
    neighbor_offsets::Ptr{Cint},
    neighbor_z::Ptr{Cint},
    neighbor_Rij::Ptr{Cdouble},
    energies::Ptr{Cdouble},
    forces::Ptr{Cdouble},
    virials::Ptr{Cdouble}
)::Cvoid
    # Process atoms sequentially
    for i in 1:Int(natoms)
        z0 = unsafe_load(z, i)
        nneigh = Int(unsafe_load(neighbor_counts, i))
        offset = Int(unsafe_load(neighbor_offsets, i))  # 0-indexed from C

        if nneigh == 0
            # Isolated atom - return E0
            iz0 = z2i(z0)
""")

    # Generate E0 lookup for each species for batch API
    for iz in 1:NZ
        cond = iz == 1 ? "if" : "elseif"
        println(io, "            $cond iz0 == $iz; E0 = E0_$iz")
    end
    println(io, """            else; E0 = 0.0
            end
            unsafe_store!(energies, E0, i)
            # Zero virial
            for k in 1:6
                unsafe_store!(virials, 0.0, (i-1)*6 + k)
            end
        else
            # Read neighbor data for this atom
            Zs = Vector{Int}(undef, nneigh)
            Rs = Vector{SVector{3, Float64}}(undef, nneigh)

            @inbounds for j in 1:nneigh
                idx = offset + j  # 1-indexed from 0-indexed offset
                Zs[j] = unsafe_load(neighbor_z, idx)
                x = unsafe_load(neighbor_Rij, 3*(idx-1) + 1)
                y = unsafe_load(neighbor_Rij, 3*(idx-1) + 2)
                z_coord = unsafe_load(neighbor_Rij, 3*(idx-1) + 3)
                Rs[j] = SVector(x, y, z_coord)
            end

            # Compute energy, forces, virial
            Ei, Fi, Vi = site_energy_forces_virial(Rs, Zs, Int(z0))

            # Write outputs
            unsafe_store!(energies, Ei, i)

            # Forces for this atom's neighbors
            @inbounds for j in 1:nneigh
                idx = offset + j
                unsafe_store!(forces, Fi[j][1], 3*(idx-1) + 1)
                unsafe_store!(forces, Fi[j][2], 3*(idx-1) + 2)
                unsafe_store!(forces, Fi[j][3], 3*(idx-1) + 3)
            end

            # Virial in Voigt notation: xx, yy, zz, yz, xz, xy
            vbase = (i-1)*6
            unsafe_store!(virials, Vi[1,1], vbase + 1)
            unsafe_store!(virials, Vi[2,2], vbase + 2)
            unsafe_store!(virials, Vi[3,3], vbase + 3)
            unsafe_store!(virials, Vi[2,3], vbase + 4)
            unsafe_store!(virials, Vi[1,3], vbase + 5)
            unsafe_store!(virials, Vi[1,2], vbase + 6)
        end
    end
    return nothing
end

""")
end

# Fallback for non-spline basis
function _write_radial_basis(io, rbasis, NZ)
    error("Only SplineRnlrzzBasis is currently supported for export. Use splinify_first=true or call splinify() on your model first.")
end

# Additional envelope types
function _write_envelope(io, env, iz, jz)
    error("Envelope type $(typeof(env)) not yet supported for export")
end
