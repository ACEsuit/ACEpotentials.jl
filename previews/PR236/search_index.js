var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/saving-and-loading/#Saving-and-Loading-Potentials","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/#Saving-Potentials-for-Julia-use","page":"Saving and Loading Potentials","title":"Saving Potentials for Julia use","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"To save potentials for future Julia use can use","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"save_potential(\"my-potential-file.json\", potential)","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"This will save the potential in json format. You can also use yml and yace suffixes.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"The format used for saving can be either ACEmodel from acemodel function, JuLIP style potentials or ACEmd style ACEpotential.","category":"page"},{"location":"gettingstarted/saving-and-loading/#Loading-Potentials","page":"Saving and Loading Potentials","title":"Loading Potentials","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"To load potential use","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"potential = load_potential(\"my-potential-file.json\")","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"By default this should print information about version in use when the potential was saved. E.g. like following","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"This potential was saved with following versions:\n\nJuLIP v0.14.5\nACEbase v0.4.3\nACE1x v0.1.8\nACE1 v0.11.16\nACEmd v0.1.7\nACEpotentials v0.6.3\nACEfit v0.1.4\n\nIf you have problems using this potential, pin your installation to above versions.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"If you have problems with the potential, you can use the given version numbers to build an installation that should have the potential working.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"By default the loaded potential is in JuLIP style format. To load a new ACEmd style ACEpotential you can give keyword new_format=true","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"potential = load_potential(\"my-potential-file.json\"; new_format=true)","category":"page"},{"location":"gettingstarted/saving-and-loading/#Exporting-Potentials-for-Other-Programs","page":"Saving and Loading Potentials","title":"Exporting Potentials for Other Programs","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"LAMMPS export is described in section ACEpotentials potentials in LAMMPS.","category":"page"},{"location":"tutorials/AtomsBase_interface/#AtomsBase-Interface","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"ACEpotentials has a new AtomsBase based interface in addition to JuLIP based interface.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"AtomsBase allows easy communication between different Julia programs. In the future this interface will became the default one and JuLIP interface will be retired.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"AtomsBase interface has not been rigorously tested yet. So, expect some issues here and there. But you are recommended to git it a try.","category":"page"},{"location":"tutorials/AtomsBase_interface/#Loading-Training-Data","page":"AtomsBase Interface","title":"Loading Training Data","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"With AtomsBase you can use AtomsIO to load training data","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"using AtomsIO\n\ndata = load_trajectory(\"path to training data\")","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"You can also use ExtXYZ directly (exported by ACEpotentials) to load training data","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"data = ExtXYZ.load(\"path to training data\")","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"To use AtomsBase with the examples you can load the training data in AtomsBase format by giving a keyword argument atoms_base=true","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"data, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\"; atoms_base=true)","category":"page"},{"location":"tutorials/AtomsBase_interface/#Training-with-AtomsBase","page":"AtomsBase Interface","title":"Training with AtomsBase","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"There are no changes to the training methods when using AtomsBase. You only need to have the training data in AtomsBase format for the training to work. Here is the acemodel style training tutorial using AtomsBase","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"using ACEpotentials\n\n\ndata, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\"; atoms_base=true)\n\nmodel = acemodel(\n    elements = [:Ti, :Al],\n\torder = 3,\n\ttotaldegree = 6,\n\trcut = 5.5,\n\tEref = [:Ti => -1586.0195, :Al => -105.5954]\n)\n@show length(model.basis);\n\n\nweights = Dict(\n    \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n    \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 )\n);\n\nsolver = ACEfit.LSQR(damp = 1e-2, atol = 1e-6);\ndata_train = data[1:5:end]\nP = smoothness_prior(model; p = 4) \n\nacefit!(model, data_train; solver=solver, weights=weights, prior = P);\n\n@info(\"Training Error Table\")\nACEpotentials.linear_errors(data_train, model; weights=weights);","category":"page"},{"location":"tutorials/AtomsBase_interface/#Training-data-in-AtomsBase-structures","page":"AtomsBase Interface","title":"Training data in AtomsBase structures","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"In AtomsBase you have system wide features accesses with haskey(some_key) or atom features accesses with hasatomkey(some_key). Energy (scalar) and virial (matrix) are expected to be system features while force (vector) should be a atom feature. They should be unitless. The fitting process does not have internal units. But in the data the units are implicitely expected to be in eV and eV/Å, when units are stripped.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"By default all these should be true","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"haskey(system, :energy)     # default energy key\nhaskey(system, :virial)     # default virial key\nhasatomkey(system, :force)  # default force key","category":"page"},{"location":"tutorials/AtomsBase_interface/#Weights-with-AtomsBase","page":"AtomsBase Interface","title":"Weights with AtomsBase","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"With AtomsBase weights are stored in AtomsBase structures and there is no need to create AtomsData structures. Weights can be given for either energy, forces or virial and for structure itself. Each of these have an associated keyword","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":":energy_weight for energy\n:force_weight for forces\nvirial_weight for virial\n:weight a general weight for the structure that multiply other weights","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"To access the weights you can call","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"data_point[:energy_weight]\ndata_point[:force_weight]\ndata_point[:virial_weight] \ndata_point[:weight]","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"To set a weight by hand on an individual structure you can use","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"# Set general weight\ndata_point[:weight] = 60\n## AtomsCalculators support\n# Set weight for energy\ndata_point[:energy_weight] = 60\n\n# etc.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"When you use acemodel interface (call acefit!) the weights are applied by overwriting any existing weights.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"You can look for what keys AtomsBase structures support by calling","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"# whole structure features\nkeys(data_point)\n\n# features per atom\natomkeys(data_point)","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"You can give keyword group_key to acefit! to determine what group weights are used. Make sure that corresponding haskey call returns true.","category":"page"},{"location":"tutorials/AtomsBase_interface/#New-Assemble-Backend","page":"AtomsBase Interface","title":"New Assemble Backend","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"AtomsBase interface uses new assemble backend that is faster than the old one. You can you the new backend with old JuLIP interface by giving keyword new_assembly=true. E.g.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"# acefit interface\nacefit!(model, data_train; solver=solver, weights=weights, prior = P, new_assembly=true);\n\n# acebasis interface\nACEfit.assemble(data_train, basis; new_assembly=true)","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"You can control what keys are used for energy, forces and virial by using keyword arguments energy_key, force_key and virial_key. Look for document sting for more details and more contron options.","category":"page"},{"location":"tutorials/AtomsBase_interface/#AtomsCalculators-Interface","page":"AtomsBase Interface","title":"AtomsCalculators Interface","text":"","category":"section"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"To use AtomsBase structures as an input for calculations you need to create ACEpotential structure. If you use acemodel interface (like above) you can do this with","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"pot = ACEpotential(model)","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"If you use acebasis interface you can create potential with","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"pot_1 = ACEpotential(basis, results[\"C\"])","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"Alternatively you can load the potential from a file","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"pot = load_potential(\"my-potential.json\"; new_format=true)","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"ACEpotential stucture implements AtomsCalculators interface","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"using AtomsCalculators\n\nE = AtomsCalculators.potential_energy(system, pot)\nF = AtomsCalculators.forces(system, pot)\nV = AtomsCalculators.virial(system, pot)","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"where system is an AtomsBase structure.","category":"page"},{"location":"tutorials/AtomsBase_interface/","page":"AtomsBase Interface","title":"AtomsBase Interface","text":"The current ACE1 based implemetation to AtomsBase and AtomsCalculators is implemented in ACEmd. Take a look onto it, if you need further information.","category":"page"},{"location":"gettingstarted/pkg/#Using-the-Julia-Package-Manager","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This is a very brief introduction to the Julia package manager, intended for newcomers to Julia who are here primarily to use the ACEsuit. But it is not really ACE specific at all. ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"<!-- If you plan to use `ACEpotentials.jl` from Python or the command line, then you need not read this. -->","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The package manager provides functionality to organize reproducable Julia projects. A project is specified by a Project.toml where the user specifies which packages are required, and version bounds on those packages. The Package manager can then resolve these dependencies which results in a Manifest.toml where the full Julia environment is precisely specified. This can be used in a workflow as follows:","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"To start a new project that uses ACEpotentials.jl, e.g. to develop a new interatomic potential for TiAl we first create a new folder where the project will live, e.g., ace_TiAl_project. Change to that folder and start the Julia REPL. Type ] to switch to the package manager, then activate a new project in the current directory via activate .\nYou now have an empty project. Start adding the packages you need, often just   add ACEpotentials  will suffice.   Type status to see your required packages listed. (Note this is only a subset of the installed packages!). Exit the REPL and type ls; you will then see a new file Project.toml which lists the project requirements, and a Manifest.toml which lists the actually packages and the version that have been installed.\nSpecify version bounds: We strongly encourage doing this rigorously! Open Project.toml in an editor and under the [compat] section you can now add version bounds, e.g. ACEpotentials = \"0.6.1\" following semver. Please see the Pkg.jl docs for details on how to specify those bounds. Start a Julia REPL again, type ] to switch to the package manager and then up to up- or down-grade all installed packages to the latest version compatible with your bounds.","category":"page"},{"location":"gettingstarted/pkg/#Using-a-Development-Branch-(rarely-required)","page":"Using the Julia Package Manager","title":"Using a Development Branch (rarely required)","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"If you are a user rather than developer it should almost never be required for you to check out a package (or, dev it in the package manager). When developers make changes to - say - ACEpotentials.jl they will always immediately tag another version and then you can adjust your version bounds in your project to update as well as enforce which version to use. However a developer would frequently do this, and occasionally it might be required when iterating between a user and developer for testing. There are multiple ways to achieve this; the following is our recommended procedure: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Suppose for example that a development branch co/dev of ACE1.jl is needed in a project project. Then one should perform the following steps: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Make sure ACE1 has been added to project/Project.toml \nIn a separate folder, /path/to/ , clone ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"cd /path/to\ngit clone git@github.com:ACEsuit/ACE1.jl.git\ngit checkout co/dev","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"so that the repo will now live in /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Go to and activate project, then in a Julia REPL switch to the package manager ] and execute","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"dev /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This will replace the ACE1 package in the Manifest with the version that lives in /path/to/ACE1.jl ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Later on, when you want to go back to the standad Pkg versin control you can simply free ACE1.","category":"page"},{"location":"gettingstarted/pkg/#Further-Notes","page":"Using the Julia Package Manager","title":"Further Notes","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The Project.toml should always be committed to your project git repo. Whether Manifest.toml is also committed is a matter of taste or context. Tracking the Manifest will (normally) ensure future compatibility since it allows you to reconstruct the precise Julia environment that was used when the Manifest was created.","category":"page"},{"location":"gettingstarted/pkg/#Links","page":"Using the Julia Package Manager","title":"Links","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"https://pkgdocs.julialang.org/v1/\nhttps://pkgdocs.julialang.org/v1/compatibility/","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"EditURL = \"../tutorials/TiAl_basis.jl\"","category":"page"},{"location":"literate_tutorials/TiAl_basis/#The-ace_basis-interface","page":"The ace_basis interface","title":"The ace_basis interface","text":"","category":"section"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Start by importing the required libraries","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"using ACEpotentials","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"We need a dataset TiAl_tutorial.xyz for this tutorial. Normally we would get the path to a datset and then use read_extxyz to load in the training set.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"data_file = \"path/to/TiAl_tutorial.xyz\"\ndata = read_extxyz(data_file)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"For convenience we provide this dataset as a Julia artifact and make it conveniently accessible via ACEpotentials.example_dataset. We keep only a small subset of the training structures to keep the regression problem small.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"data, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ntrain_data = data[1:5:end];\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The next step is to generate a basis set:","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"order = 3 : We take 3-correlation, i.e. a 4-body potential,\ntotaldegree = 6 : a very low polynomial degree just for testing\nrcut = 5.5 : this is a typical cutoff radius, there is also a good default which is a bit higher","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"These three are the most important approximation parameters to explore when trying to improve the fit-accuracy. In addition there is","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The parameter r0 is just a scaling parameter and the fits should not be very sensitive to its choice. A rough estimate for the nearest-neighbour distance is usually ok. (NB: if you change to a non-trivial distance transform, then the parameter r0 may become important.)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"r0 = 2.88\nbasis = ACE1x.ace_basis(elements = [:Ti, :Al],\n                  order = 3,\n                  totaldegree = 6,\n                  rcut = 5.5,\n                  r0 = r0,)\n@show length(basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Vref specifies a reference potential, which is subtracted from the training data and the ACE parameters are then estimated from the difference. This reference potential will in the end be added to the ACE model. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Vref = OneBody(:Ti => -1586.0195, :Al => -105.5954);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The next line specifies the regression weights: in the least squares loss different observations are given different weights,","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"  sum_R Big( w^E_R  E(R) - y_R^E ^2\n           + w^F_R  rm forces(R) - y_R^F ^2\n           + w^V_R  rm virial(R) - y_R^V ^2 Big)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"and this is specificed via the following dictionary. The keys correspond to the config_type of the training structures.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"weights = Dict(\n        \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The next step is to evaluate the basis on the training set. Precomputing the basis once (and possibly save it to disk) makes experimenting with different regression parameters much more efficient. This is demonstrated below by showing various different solver options. Similarly once could also explore different data weights (see weights below).","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"datakeys = (energy_key = \"energy\", force_key = \"force\", virial_key = \"virial\")\ntrain = [ACEpotentials.AtomsData(t; weights=weights, v_ref=Vref, datakeys...) for t in train_data]\nA, Y, W = ACEfit.assemble(train, basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"ACE1.jl has a heuristic smoothness prior built in which assigns to each basis function Bi a scaling parameter si that estimates how \"rough\" that basis function is. The following line generates a regularizer (prior) with si^q on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"P = smoothness_prior(basis; p = 4)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Once all the solver parameters have been determined, we use ACEfit to estimate the parameters. This routine will return the fitted interatomic potential IP as well as the a dictionary lsqfit with some information about the fitting process.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"solver = ACEfit.LSQR(damp = 1e-2, atol = 1e-6, P = P)\nresults = ACEfit.solve(solver, W .* A, W .* Y)\npot_1 = JuLIP.MLIPs.SumIP(Vref, JuLIP.MLIPs.combine(basis, results[\"C\"]));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The advantage of working with the ACE basis rather than the ACE model interface is that we can now make some changes to the fitting parameters and refit. For example, we might want different weights, change the smoothness prior, and switch to a RRQR solver.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"weights[\"FLD_TiAl\"][\"E\"] = 20.0\nW = ACEfit.assemble_weights(train)\nsolver = ACEfit.RRQR(; rtol = 1e-8, P = smoothness_prior(basis; p = 2))\nresults = ACEfit.solve(solver, W .* A, W .* Y)\npot_2 = JuLIP.MLIPs.SumIP(Vref, JuLIP.MLIPs.combine(basis, results[\"C\"]));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"We can now compare the errors in a nice table. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"test = [ACEpotentials.AtomsData(t; weights=weights, v_ref=Vref, datakeys...) for t in data[2:10:end]]\n\n@info(\"Test Error Tables\")\n@info(\"First Potential: \")\nACEpotentials.linear_errors(test, pot_1);\n\n@info(\"Second Potential: \")\nACEpotentials.linear_errors(test, pot_2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"If we want to save the fitted potentials to disk to later use we can use one of the following commands: the first saves the potential as an ACE1.jl compatible potential, while the second line exports it to a format that can be ready by the pacemaker code to be used within LAMMPS. This functionality is currently disabled.","category":"page"},{"location":"literate_tutorials/TiAl_basis/#save*potential(\"./TiAl*tutorial*pot.json\",-pot*1)","page":"The ace_basis interface","title":"savepotential(\"./TiAltutorialpot.json\", pot1)","text":"","category":"section"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The fitted potential can also be exported to a format compatible with LAMMPS (ML-PACE). This functionality is currently disabled.","category":"page"},{"location":"literate_tutorials/TiAl_basis/#export2lammps(\"./TiAl*tutorial*pot.yace\",-pot_1)","page":"The ace_basis interface","title":"export2lammps(\"./TiAltutorialpot.yace\", pot_1)","text":"","category":"section"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Solvers/#Least-squares-solvers","page":"Least squares solvers","title":"Least squares solvers","text":"","category":"section"},{"location":"tutorials/Solvers/#LSQR","page":"Least squares solvers","title":"LSQR","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The :lsqr solver solves the linear system with l^2 regularisation:","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"mathbfc = textarg min_mathbfc  mathbfy - Psi mathbfc ^2 + lambda^2  mathbfc ^2","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The solver dictionary should have the following arguments:","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :lsqr,\n        \"damp\" => 5e-3,\n        \"atol\" => 1e-6)","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"where damp is lambda in the equation above. The implementation is iterative and atol is a convergence tolerance at which to stop the alogrithm.","category":"page"},{"location":"tutorials/Solvers/#RRQR","page":"Least squares solvers","title":"RRQR","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"Rank-revealing QR factorisation determines a low rank solution to the linear system. Smaller \"gctol\" means less regularisation. ","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :rrqr,\n        \"tol\" => 1e-5)","category":"page"},{"location":"tutorials/Solvers/#Baysian-Ridge-Regression-(BRR)","page":"Least squares solvers","title":"Baysian Ridge Regression (BRR)","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The :brr - Bayesian Ridge Regression - is a wrapper for scikit learn's BayseianRidge linear model see here. A Gaussian prior on the parameter vector, and a Gaussian likelihood function are used to copmute the maximum posterior probability parameter vector. Following this, the hyperparamters of the Gaussian priors are optimised by maximising the marginal log likelihood of the obsrevations. ","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :brr, \n        \"tol\" => 1e-3)","category":"page"},{"location":"tutorials/Solvers/#Automatic-Relevance-Determination-(ARD)","page":"Least squares solvers","title":"Automatic Relevance Determination (ARD)","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver= Dict(\n         \"solver\" => :ard,\n         \"tol\" => 1e-3,\n         \"threshold_lambda\" => 10000)","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"Automatic Relevance Determination performing evidence maximisation. tol sets the convergence for the marginal log likelihood convergence, default is1e-3. threshold_lambda is the threshold for removing the basis functions with low relevance, default is 10000.","category":"page"},{"location":"tutorials/python_ase/#python-ase","page":"python-ase","title":"python-ase","text":"","category":"section"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"An ACEpotentials.jl model can be used in python as an ase calculator. To do this, you will need to install two python packages, julia and pyjulip as documented on the installation page. ","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Python reads the potential.json file directly. To load an ACE potential as an ase calculator, use the following syntax:","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"import pyjulip\ncalc = pyjulip.ACE1(\"first_potential.json\")","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Using that calculator, we can then evaluatuate energies, forces, etc, e.g., ","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"ats = ase.io.read('atoms_object.xyz')\nats.calc = calc\nprint(ats.get_potential_energy())","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"See the ase documentation for more details.","category":"page"},{"location":"tutorials/python_ase/#Another-option:-ASE's-LAMMPSlib-calculator","page":"python-ase","title":"Another option: ASE's LAMMPSlib calculator","text":"","category":"section"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Alternatively, to avoid direct Julia-Python interaction, one can export to LAMMPS (see LAMMPS) and utilize ASE's LAMMPSlib calculator.","category":"page"},{"location":"using_ace/python_ase/#Python-ASE","page":"Python ASE","title":"Python ASE","text":"","category":"section"},{"location":"tutorials/#Tutorials-Overview","page":"Tutorials Overview","title":"Tutorials Overview","text":"","category":"section"},{"location":"tutorials/#Fitting-potentials-from-Julia-scripts","page":"Tutorials Overview","title":"Fitting potentials from Julia scripts","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"These tutorials use the direct Julia interface provided by ACEpotentials.jl (interfacing with ACE1.jl, ACE1x.jl, ACEfit.jl). They are provided in Literate.jl format and can also be run as scripts if that is preferred. ","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"First Example\nModel Interface\nBasis Interface","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"The next two tutorials show some additional techniques to better understand how to make good hyperparameter choices. ","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"Smoothness Priors : a basic introduction to smoothness priors \nDataset Analysis : some basic techniques to visualize training datasets and correlate such observations to the choice of geometric priors","category":"page"},{"location":"tutorials/#Using-ACEpotentials-Potentials-in-External-Software","page":"Tutorials Overview","title":"Using ACEpotentials Potentials in External Software","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"LAMMPS\nPython with ase\nMolly.jl","category":"page"},{"location":"tutorials/#Structure-analysis-with-ACE1-descriptors","page":"Tutorials Overview","title":"Structure analysis with ACE1 descriptors","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"ACE descriptors","category":"page"},{"location":"tutorials/#Committee-Potentials","page":"Tutorials Overview","title":"Committee Potentials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"Committee Potentials","category":"page"},{"location":"tutorials/#Experimental-Features","page":"Tutorials Overview","title":"Experimental Features","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"Experimental Features","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"<!---\n### JSON Interface and Command line (OUTDATED)\n\nACE potentials can be fitted from the command line using a dictionary stored in a `.json` or `.yaml` file to specify the parameters:\n\n* [TiAl Potential (ACEpotentials)](../literate_tutorials/ACEpotentials_TiAl.md)\n* [TiAl Potential (command line JSON)](../outdated/first_example_json.md)\n\n-->","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"EditURL = \"../tutorials/experimental.jl\"","category":"page"},{"location":"literate_tutorials/experimental/#Some-Experimental-Features","page":"Some Experimental Features","title":"Some Experimental Features","text":"","category":"section"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"This tutorial will go through a few experimental features that are made available but may not be fully tested and should note be relied upon.","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"using ACEpotentials","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"We do a quick fit of a TiAl potential following the same steps as in the  TiAl model tutorial.","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"model = acemodel(elements = [:Ti, :Al], order = 3, totaldegree = 6,\n\t\t\t\t\t  rcut = 5.5, Eref = [:Ti => -1586.0195, :Al => -105.5954])\nweights = Dict(\"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n               \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ))\nsolver = ACEfit.LSQR(damp = 1e-2, atol = 1e-6);\nP = smoothness_prior(model; p = 4)\ndata, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ndata_train = data[1:5:end]\nacefit!(model, data_train; solver=solver, prior = P);\nnothing #hide","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"Next we convert the model to a new experimental evaluator that should be a lot faster - at least for small models.","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"fpot = ACEpotentials.Experimental.fast_evaluator(model);\nnothing #hide","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"The predictions should be correct to within 10-13 digits.","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"for ntest = 1:10\n   at = rattle!(rand(data), 0.01)\n   E = JuLIP.energy(model.potential, at)\n   E_fast = JuLIP.energy(fpot, at)\n   @show abs(E - E_fast)\nend;\nnothing #hide","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"Now let's look at timings, they should be significantly faster for the new evaluator. Note that the speedup will be different depending on the size of the model and the architecture of the computer.","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"JuLIP.forces(model.potential, data[1]);\nJuLIP.forces(fpot, data[1]);\nprint(\"Energy, old evaluator: \")\n@time for d in data; JuLIP.energy(model.potential, d); end\nprint(\"Energy, new evaluator: \")\n@time for d in data; JuLIP.energy(fpot, d); end\nprint(\"Forces, old evaluator: \")\n@time for d in data; JuLIP.forces(model.potential, d); end\nprint(\"Forces, new evaluator: \")\n@time for d in data; JuLIP.forces(fpot, d); end","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"","category":"page"},{"location":"literate_tutorials/experimental/","page":"Some Experimental Features","title":"Some Experimental Features","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"EditURL = \"../tutorials/dataset_analysis.jl\"","category":"page"},{"location":"literate_tutorials/dataset_analysis/#Elementary-Dataset-Analysis","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"","category":"section"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"In this tutorial we show some basic tools in ACEpotentials to analyze a dataset and how this connects to a model construction. As usual we start by importing the relevant packages. For plotting we will use Plots.jl and LaTexStrings for nice labels.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"using ACEpotentials, Plots, LaTeXStrings","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"Let's generate a naive dataset, just some random bulk Si structures that are rattled a bit.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"rand_Si() = rattle!(bulk(:Si, cubic=true) * rand([2,3,4]), 0.25)\nSi_data = [ rand_Si() for _=1:50 ];\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"Two basic distributions we can look at to see how well the data fills in space are the radial and angular distribution functions. For the radial distribution function we use the cutoff of the model (see below). For the angular distribution we use a cutoff just above the nearest neighbour distance to we can clearly see the equilibrium bond-angles.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"r_cut = 6.0  #\nrdf = ACEpotentials.get_rdf(Si_data, r_cut; rescale = true)\n\nr_cut_adf = 1.25 * rnn(:Si)\nadf = ACEpotentials.get_adf(Si_data, 1.25 * rnn(:Si));\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"We can plot these distributions using the histogram function in Plots.jl. For the RDF we add some vertical lines to indicate the distances and first, second neighbours and so forth to confirm that the peaks are in the right place. For the ADF we add a vertical line to indicate the equilibrium bond angle.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"plt_rdf = histogram(rdf[(:Si, :Si)], bins=150, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\", yticks = [])\nvline!(rnn(:Si) * [1.0, 1.633, 1.915, 2.3, 2.5], label = \"r1, r2, ...\", lw=3)\n\neq_angle = 1.91 # radians\nplt_adf = histogram(adf, bins=25, label = \"adf\", yticks = [], c = 3,\n                  xlabel = L\"\\theta\", ylabel = \"ADF\", xlims = (0, π))\nvline!([ eq_angle,], label = \"109.5˚\", lw=3)\n\nplot(plt_rdf, plt_adf, layout = (2,1), size = (800, 400))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"One way we can use these distribution functions is to look at fitted potentials relative to where data is given. But even before a potential is fitted we can illustrate some properties of the basis functions used in ACEpotentials. E.g. we can illustrate why we have chosen the distance transforms. First, we generate a default Si model and a second one with modified transform.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"model1 = acemodel(elements = [:Si,], order = 3,\n                  totaldegree = 10, rcut = r_cut )\n\nmodel2 = acemodel(elements = [:Si,], order = 3,\n                  totaldegree = 10, rcut = r_cut,\n                  transform = (:agnesi, 2, 2) );\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"We have a utility function get_transforms that extracts the transforms from the model. We can then plot the transform gradients. In regions of r space with high gradient we have higher resolution. We see that the transforms concentrate resolution near the nearest neighbour distance and ensure there is no resolution at all near r = 0. The transform for the second model distributes resolution much more evenly across the radial domain.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"using ACE1.Transforms: transform_d\ntrans1, trans1_pair = ACEpotentials.get_transforms(model1)\ntrans2, trans2_pair = ACEpotentials.get_transforms(model2)\nt1 = trans1[(:Si, :Si)]\nt2 = trans2[(:Si, :Si)]\nrp = range(0.0, r_cut, length = 200)\n\nplt_t = plot(rp, abs.(transform_d.(Ref(t1), rp)), lw=3,\n             xlabel = L\"r [\\AA]\", label = L\"|t_1'(r)|\",\n             yticks = [], ylabel = \"\", xlims = (0, r_cut))\nplot!(plt_t, rp, abs.(transform_d.(Ref(t2), rp)), lw=3, label = L\"|t_2'(r)\")\nvline!([rnn(:Si),], lw=2, label = L\"r_{\\rm nn}\")\n\nplt_rdf = histogram(rdf[(:Si, :Si)], bins=100, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\",\n                     yticks = [], xlims = (0, r_cut))\nvline!([rnn(:Si),], label = L\"r_{\\rm nn}\", lw=3)\n\nplot(plt_t, plt_rdf, layout=grid(2, 1, heights=[0.7, 0.3]), size = (800, 400))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"To finish this tutorial, we quickly demonstrate what happens when there is more than one chemical species present in a dataset.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"tial_data, _, _ = ACEpotentials.example_dataset(\"TiAl_tutorial\")\n\nrdf = ACEpotentials.get_rdf(tial_data, r_cut)\nplt_TiTi = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 1,\n         ylabel = \"RDF - TiTi\", label = \"\", yticks = [], xlims = (0, r_cut) )\nplt_TiAl = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 2,\n         ylabel = \"RDF - TiAl\", label = \"\", yticks = [], xlims = (0, r_cut) )\nplt_AlAl = histogram(rdf[(:Al, :Al)], bins=100, xlabel = L\"r [\\AA]\", c = 3,\n         ylabel = \"RDF - AlAl\", label = \"\", yticks = [], xlims = (0, r_cut), )\nplot(plt_TiTi, plt_TiAl, plt_AlAl, layout = (3,1), size = (700, 700))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/lammps/#ACEpotentials-potentials-in-LAMMPS","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"","category":"section"},{"location":"tutorials/lammps/#Install-LAMMPS-with-the-ML-PACE-package","page":"ACEpotentials potentials in LAMMPS","title":"Install LAMMPS with the ML-PACE package","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"An ACEpotentials.jl potential can be used in LAMMPS if the latter is built with the ML-PACE package. At present, a patched version of that package is required which may be installed as follows:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"git clone -b release https://github.com/lammps/lammps\ncd lammps\nmkdir build\ncd build\nwget -O libpace.tar.gz https://github.com/wcwitt/lammps-user-pace/archive/main.tar.gz\ncmake \\\n    -D PKG_ML-PACE=yes \\\n    -D PACELIB_MD5=$(md5sum libpace.tar.gz | awk '{print $1}') \\\n    ../cmake\nmake -j 4","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"See the LAMMPS documentation for more build options.","category":"page"},{"location":"tutorials/lammps/#Convert-an-ACEpotentials-model-to-yace-format","page":"ACEpotentials potentials in LAMMPS","title":"Convert an ACEpotentials model to yace format","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The ML-PACE package requires a potential in the .yace format. To convert a model saved as .json, use the following:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"using ACEpotentials\npotential_json = \"Si.json\"    # example json filename\npotential_yace = \"Si.yace\"    # example yace filename\nexport2lammps(potential_yace, read_dict(load_dict(potential_json)[\"IP\"]))","category":"page"},{"location":"tutorials/lammps/#Using-yace-potentials-in-LAMMPS","page":"ACEpotentials potentials in LAMMPS","title":"Using yace potentials in LAMMPS","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The syntax for the PACE pair style in LAMMPS, for a potential for I, Cs and Pb, is:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"pair_style      pace\npair_coeff      * * potential.yace I Cs Pb","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The species ordering after pair_coeff must match the numerical ordering in any .data geometry file. ","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"By default, ACEpotentials models have separate two-body and many-body components. At present, the two-body component is exported via a lookup table which LAMMPs reads directly, meaning two files are created: a potentialname_pairpot.table file for the two-body contribution and a potentialname.yace file for the many-body contribution. The .table file contains a set of lookup tables with a fixed number N (written in the file) of interpolation points. To use the full model in LAMMPS, read N from the file and use the syntax:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"pair_style      hybrid/overlay pace table spline <N>\npair_coeff      * * pace potential.yace I Cs Pb\npair_coeff      1 1 table potential_pairpot.table I_I\npair_coeff      1 2 table potential_pairpot.table I_Cs\npair_coeff      1 3 table potential_pairpot.table I_Pb\npair_coeff      2 2 table potential_pairpot.table Cs_Cs\npair_coeff      2 3 table potential_pairpot.table Cs_Pb\npair_coeff      3 3 table potential_pairpot.table Pb_Pb","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"where we are using the ordering I, Cs, Pb.","category":"page"},{"location":"gettingstarted/parallel-fitting/#Parallel-Fitting","page":"Parallel Fitting","title":"Parallel Fitting","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"ACEpotentials and ACEfit may be accelerated with one or more parallelization options.","category":"page"},{"location":"gettingstarted/parallel-fitting/#Distributed-fitting-(multiple-processes)","page":"Parallel Fitting","title":"Distributed fitting (multiple processes)","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Some routines (particularly those that assemble the linear problem) make use of Julia's multi-processing capabilities. These routines automatically utilize any available worker processes, which are initiated in one of two ways.","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"First, one may generate the workers when starting Julia. Setting JULIA_PROJECT beforehand is crucial in this case. The example starts Julia with seven additional worker processes (so, eight processes in total).","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"export JULIA_PROJECT=/path/to/project\njulia --project=path/to/project -p 7","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Alternatively, one may create workers directly within a Julia script. The exeflags argument to addprocs propagates project information, and the @everywhere macro is necessary to ensure all processes load the module. ","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"using Distributed\naddprocs(7, exeflags=\"--project=$(Base.active_project())\")\n@everywhere using ACEpotentials","category":"page"},{"location":"gettingstarted/parallel-fitting/#Parallel-BLAS-or-LAPACK","page":"Parallel Fitting","title":"Parallel BLAS or LAPACK","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Many ACEfit solvers, and possibly other routines, utilize BLAS or LAPACK. To see benefits from threading, one should set one or more of the following environment variables, depending on the particular library used.","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"export OMP_NUM_THREADS=8\nexport MKL_NUM_THREADS=8\nexport OPENBLAS_NUM_THREADS=8\nexport VECLIB_MAXIMUM_THREADS=8","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Distributed solution of the linear least squares systems is currently not supported. We would welcome collaboration on this with interested developers. ","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"EditURL = \"../tutorials/smoothness_priors.jl\"","category":"page"},{"location":"literate_tutorials/smoothness_priors/#Smoothness-Priors","page":"Smoothness Priors","title":"Smoothness Priors","text":"","category":"section"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"using ACEpotentials, LinearAlgebra, Plots, LaTeXStrings","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"ACEpotentials models make heavy use of smoothness priors, i.e., prior parameter distributions that impose smoothness on the fitted potential. This tutorial demonstrates how to use the smoothness priors implemented in ACEpotentials. We start by reading in a tiny testing dataset, and bring the data into a format that ACEfit likes. Note that using a very limited dataset makes the use of priors particularlty important. In general, the larger and more diverse the dataset, the less important the prior becomes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"rawdata, _, _ = ACEpotentials.example_dataset(\"Si_tiny\")\ndatakeys = (energy_key = \"dft_energy\", force_key = \"dft_force\", virial_key = \"dft_virial\")\n\nrcut = 6.0     # cut off distance\nr_nn = 2.3     # typical nearest neighbour distance\n\nmodel = ACE1x.acemodel(elements = [:Si],\n                       order = 3, totaldegree = 12,\n                       rcut = rcut, r0 = r_nn,\n                       Eref = Dict(\"Si\" => -158.54496821))\n\ndata = [ AtomsData(at; datakeys..., v_ref = model.Vref) for at in rawdata ]\nA, Y, W = ACEfit.assemble(data, model.basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"A positive definite matrix P specifies a normal prior distribution in the Bayesian framework, but for the purpose of this tutorial it is maybe more intuitive to simply think of it as a regularisation operator. The regularised linear least squares problem is","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"   A c - y ^2 + lambda  P c ^2","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"where A is the design matrix, y is the vector of observations, c is the vector of parameters, and lambda is a regularisation parameter. The prior matrix P is specified by the user. At present we support diagonal operators P. The diagonal elements of P are the prior variances. The larger the prior variance, the smoother the fitted potential. Although not strictly true, we can think of each basis function as specified by a the parameters (n_t l_t)_t = 1^N, where N is the correlation-order. The corresponding prior matrix element must be a function of those n_t l_t values. We currently support three classes: algebraic, exponential and gaussian.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"TODO: write down the precise definitions.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"In the following we demonstrate the usage of algebraic and gaussian priors. The choices for σl, σn made here may seem \"magical\", but there is a good justification and we plan to automate this in future releases.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Pa2 = ACE1x.algebraic_smoothness_prior(model.basis; p=2)\nPa4 = ACE1x.algebraic_smoothness_prior(model.basis; p=4)\nPg  = ACE1x.gaussian_smoothness_prior( model.basis, σl = (2/r_nn)^2, σn = (0.5/r_nn)^2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Each of these object Pa2, Pa4, Pg are diagonal matrices. For each prior constructed above we now solve the regularised least squares problem. Note how design matrix need only be assembled once if we want to play with many different priors. Most of the time we would just use defaults however and then these steps are all taken care of behind the scenes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"priors = Dict(\"Id\" => I, \"Algebraic(2)\" => Pa2, \"Algebraic(4)\" => Pa4,\"Gaussian\" => Pg)\nrmse = Dict()\npots = Dict()\n\nfor (prior_name, P) in priors\n    print(\"Solving with \", prior_name, \" prior ... \")\n\n    # solve the regularized least squares problem\n    Ã = Diagonal(W) * (A / P)\n    ỹ = Diagonal(W) * Y\n    c̃ = ACEfit.solve(ACEfit.BLR(; verbose=false), Ã, ỹ)[\"C\"]\n    ACE1x._set_params!(model, P \\ c̃)\n\n    # compute errors and store them for later use (don't print them here)\n    errs = ACEpotentials.linear_errors(rawdata, model; verbose=false, datakeys...)\n    rmse[prior_name] = errs[\"rmse\"][\"set\"][\"F\"]\n    pots[prior_name] = model.potential\n    println(\" force=rmse = \", rmse[prior_name])\nend","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"The force RMSE errors are comparable for the three priors, though slightly better for the weaker smoothness priors Algebraic(2) and Id. This is unsurprising, since those priors are less restrictive.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"On the other hand, we expect the stronger priors to generalize better. A typical intuition is that smooth potentials with similar accuracy will be more transferable than rougher potentials. We will show three one-dimensional slices through the fitted potentials: dimer curves, trimer curves and a decohesion curve.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"First, the dimer curves: the utility function ACEpotentials.dimers can be used to generate the data for those curves, which are then plotted using Plots.jl. We also add a vertical line to indicate the nearest neighbour distance. The standard identity prior gives a completely unrealistic dimer curve. The Algebraic(2) regularised potential is missing a repulsive core behaviour. The two remaining smoothness priors give physically sensible dimer curve shapes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"labels = sort(collect(keys(priors)))[[4,1,2,3]]\nplt_dim = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"E [eV]\",\n               xlims = (0, rcut), ylims = (-2, 5))\nfor l in labels\n    D = ACEpotentials.dimers(pots[l], [:Si,])\n    plot!(plt_dim, D[(:Si, :Si)]..., label = l, lw=2)\nend\nvline!([r_nn,], lw=2, ls=:dash, label = L\"r_{\\rm nn}\")\nplt_dim","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Next, we look at a trimer curve. This is generated using ACEpotentials.trimers. Both the Id and Algebraic(2) regularised models contain fairly significant oscillations while the Algebraic(4) and Gaussian models are much smoother. In addition, it appears that the Gaussian regularised model is somewhat more physically realistic on this slice with high energy at small bond-angles (thought the low energy at angle π seems somewhat strange).","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"plt_trim = plot(legend = :topright, xlabel = L\"\\theta\", ylabel = \"E [eV]\",\n               xlims = (0, pi), ylims = (-0.35, 0.8))\nfor l in labels\n    D = ACEpotentials.trimers(pots[l], [:Si,], r_nn,  r_nn)\n    plot!(plt_trim, D[(:Si, :Si, :Si)]..., label = l, lw=2)\nend\nvline!(plt_trim, [1.90241,], lw=2, label = \"equilibrium angle\")\nplt_trim","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Finally, we plot a decohesion curve, which contains more significant many-body effects. Arguably, none of our potentials perform very well on this test. Usually larger datasets, and longer cutoffs help in this case.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"at0 = bulk(:Si, cubic=true)\nplt_dec = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"strain [eV/Å]\",\n                xlim = (0.0, 5.0))\nfor l in labels\n    aa, E, dE = ACEpotentials.decohesion_curve(at0, pots[l])\n    plot!(plt_dec, aa, dE, label = l, lw=2)\nend\nplt_dec","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"EditURL = \"../tutorials/committee.jl\"","category":"page"},{"location":"literate_tutorials/committee/#Committee-Potentials","page":"Committee Potentials","title":"Committee Potentials","text":"","category":"section"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"using Plots, ACEpotentials, Statistics","category":"page"},{"location":"literate_tutorials/committee/#Perform-the-fit","page":"Committee Potentials","title":"Perform the fit","text":"","category":"section"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"load some example training data","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"train, _, _ = ACEpotentials.example_dataset(\"Si_tiny\")\ndata_keys = (energy_key = \"dft_energy\", force_key = \"dft_force\");\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"create model","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"model = acemodel(elements = [:Si,], order = 3, totaldegree = 8);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"create solver, setting a nonzero committee size at present, the SVD factorization is required for committees","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"solver = ACEfit.BLR(committee_size=10, factorization=:svd);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"perform the fit","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"acefit!(model, train; solver=solver, data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"Inspect the total energies vs committee energies and error bars for a few perturbed structures. Note the training set is so small that we don't expect these committees to be particularly useful; this is only to illustrate how they might be used. Also note that the energy E is not in general the mean of co_E but it is the mean of the exact posterior distribution.","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"atoms = bulk(:Si, cubic=true) * 2; rattle = [0.03, 0.1, 0.3]\nplot(; size = (300, 300), xlabel = \"rattle\", ylabel = \"energy [eV]\", ylims = (-10650, -10250),\n      xlims = (0.015, 0.6), xticks = (rattle, string.(rattle)), xscale = :log10)\nfor (i, rt) in enumerate(rattle)\n   rattle!(atoms, rt)\n   E, co_E = ACE1.co_energy(model.potential, atoms)\n   scatter!(rt*ones(10), co_E, c = 1, label=(i==1 ? \"committee\" : \"\"))\n   scatter!([rt,], [E,], yerror = [std(co_E),], c = 2, ms=6, label=(i==1 ? \"mean\" : \"\"))\nend\nplot!()","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"Committee forces are computed analogously. F is a vector of mean forces (i.e. a vector of 3-vectors), while co_F is a list of vectors of committe forces (i.e. a vector of vectors of 3-vectors).","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"F, co_F = ACE1.co_forces(model.potential, atoms)\n@show typeof(F)\n@show typeof(co_F);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"The situation is analogous for committee virials","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"V, co_V = ACE1.co_virial(model.potential, atoms)\n@show typeof(V)\n@show typeof(co_V);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"EditURL = \"../tutorials/first_example_model.jl\"","category":"page"},{"location":"literate_tutorials/first_example_model/#First-example","page":"First example","title":"First example","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"This very simple tutorial constructs an ACE1 model for Si by fitting to an empirical potential.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Make sure to first read the installation notes. Now start by importing the required packages:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"using ACEpotentials\nimport Random\nusing LinearAlgebra: norm, Diagonal","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-1:-specify-the-ACE-Model","page":"First example","title":"Step 1: specify the ACE Model","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"The parameters have the following meaning:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"elements: list of chemical species, symbols\norder : correlation order\ntotaldegree: maximum total polynomial degree used for the basis\nrcut : cutoff radius (optional, defaults are provided)","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"model = acemodel(elements = [:Si,],\n                 order = 3,\n                 totaldegree = 10,\n                 rcut = 5.0)\n@show length(model.basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-2:-Generate-a-training-set","page":"First example","title":"Step 2: Generate a training set","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Next we need to generate some training data to estimate the model parameters. Normally one would generate a training set using DFT data, stored as an .xyz file. Here, we create a random training set for simplicity. Please note that this is generally not a good strategy to generate data!","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"gen_dat() generates a single training configuration wrapped in an ACEpotentials.AtomsData structure. Each d::AtomsData contains the structure d.atoms, and energy value and a force vector to train against.\ntrain is then a collection of such random training configurations.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"data_keys = (energy_key = \"energy\", force_key = \"forces\")\n\nfunction gen_dat()\n   sw = StillingerWeber()\n   at = rattle!(bulk(:Si, cubic=true) * rand(2:3), 0.3)\n   set_data!(at, data_keys.energy_key, JuLIP.energy(sw,at))\n   set_data!(at, data_keys.force_key, JuLIP.forces(sw,at))\n   return at\nend\n\nRandom.seed!(0)\ntrain = [gen_dat() for _=1:20];\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-3:-Estimate-Parameters","page":"First example","title":"Step 3: Estimate Parameters","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"We specify a solver and then let ACEfit.jl to do all the work for us. More fine-grained control is possible; see the ACEfit.jl documentation. For sake of illustration we use a Bayesian Ridge Regression solver. This will automatically determine the regularisation for us.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"solver = ACEfit.BLR()\nacefit!(model, train; solver=solver, data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"To see the training errors we can use","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"@info(\"Training Errors\")\nACEpotentials.linear_errors(train, model; data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-4:-Run-some-tests","page":"First example","title":"Step 4: Run some tests","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"At a minimum one should have a test set, check the errors on that test set, and confirm that they are similar as the training errors.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"@info(\"Test Errors\")\ntest =  [gen_dat() for _=1:20]\nACEpotentials.linear_errors(test, model; data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"If we wanted to perform such a test ``manually'' it might look like this:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"@info(\"Manual RMSE Test\")\npotential = model.potential\ntest_energies = [ JuLIP.get_data(at, \"energy\") / length(at) for at in test]\nmodel_energies = [energy(potential, at) / length(at) for at in test]\nrmse_energy = norm(test_energies - model_energies) / sqrt(length(test))\n@show rmse_energy;\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"But in practice, one should run more extensive test simulations to check how robust the fitted potential is.","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-5:-export-the-model","page":"First example","title":"Step 5: export the model","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"The fitted model can be exported to a JSON or YAML file, or to a LAMMPs compatible yace file. We won't go through that in this tutoral. See export2json and export2lammps for further information.","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-6:-Using-the-model","page":"First example","title":"Step 6: Using the model","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Let's do something very simple: relax a vacancy.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"We create a small Si cell, delete an atom and rattle the rest","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"at = bulk(:Si, cubic=true) * 3\ndeleteat!(at, 1)\nrattle!(at, 0.03 * rnn(:Si))","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"we can now minimize the ACE energy.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"set_calculator!(at, potential);\nminimise!(at)\nE_ace = energy(at)","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"If we want a formation energy, we could get it like this.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"at0 = bulk(:Si)\nE0_ace = energy(potential, at0);\nEvac_ace = E_ace - (length(at)-1)/length(at0) * E0_ace\n@show Evac_ace;\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Note that there are no vacancy structures in the training set, so this is a prediction out of sample. We have no guarantee of the accuracy of this prediction. In fact the prediction is quite far off:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"sw = StillingerWeber()\nset_calculator!(at, sw)\nminimise!(at; verbose=false);\nE_sw = energy(at)\nE0_sw = energy(sw, bulk(:Si))\nEvac_sw = E_sw - (length(at)-1)/length(at0) * E0_sw\n@show Evac_sw;\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"To obtain accurate predictions on a vacancy structure, we must add it to the training set. This iterative model development process goes beyond the scope of this tutorial.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gettingstarted/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/installation/#Short-Version","page":"Installation","title":"Short Version","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"These short instructions are intended for users who are already familiar with Julia.  If these instructions don't make sense please see the detailed instructions below. ","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Install Julia if you haven't already. Make sure the General registry is installed and up to date. \nSetup a new project: create a folder to develop your new project, and cd into the folder. This folder will track the packages and versions which the ACEpotentials code requires. Start julia, activate the project and add ACEregistry that includes ACEpotentials, which is the package that we want to install:\nusing Pkg\nPkg.activate(\".\")\nPkg.Registry.add(\"General\")  # only needed when installing Julia for the first time\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/ACEsuit/ACEregistry\"))\nPkg.add(\"ACEpotentials\")\nACEpotentials will come with the most important packages you need, in particular ACE1.jl and ACEfit.jl.\nYou need to activate the project folder when starting julia.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"This can be done by starting julia with julia --project=pathtoproject command, using environment variable export JULIA_PROJECT=pathtoproject or by after starting julia calling","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"activate pathtoproject\"","category":"page"},{"location":"gettingstarted/installation/#Setting-up-the-Python-ASE-calculator","page":"Installation","title":"Setting up the Python ASE calculator","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"warning: Warning\nAt present, it is necessary to have ASE, JuLIP and ACE1 installed in your Julia project to use pyjulip.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"We use a wrapper called pyjulip to call julia and evaluate ACE potentials. In a terminal, with the correct julia project and python environment selected, run the following code:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"python -m pip install julia\npython -c \"import julia; julia.install()\"","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Make sure to use the correct python and pip, e.g. the ones that are in the correct Conda environment. Then, to set up pyjulip:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"git clone https://github.com/casv2/pyjulip.git\ncd pyjulip\npip install .","category":"page"},{"location":"gettingstarted/installation/#Detailed-Instructions","page":"Installation","title":"Detailed Instructions","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"If you have any difficulties with the following setup process, please file an issue. We highly recommend familiarizing oneself with the Julia package manager and how Project management is best done in Julia (there is also a summary in this section of these docs). In particular all projects should manage their own Project.toml file with appropriate version bounds, and where appropriate the Manifest.toml file can be tracked in order to guarantee reproducibility of results.","category":"page"},{"location":"gettingstarted/installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Download and unpack Julia. We require v1.9 or upwards. Add the julia executable to your path with something like export PATH=<julia-directory>/bin:$PATH.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Start the Julia REPL (type julia followed by Enter), switch to package manager by typing ], then install the General registry and the ACE registry:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"registry add https://github.com/JuliaRegistries/General\nregistry add https://github.com/ACEsuit/ACEregistry","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Press Backspace or Ctrl-c to exit the package manager. Use Ctrl-d, or exit() followed by Enter, to close the Julia REPL.","category":"page"},{"location":"gettingstarted/installation/#Setting-up-a-new-ACE1.jl-project","page":"Installation","title":"Setting up a new ACE1.jl project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Create a folder for your new project and change to it. Start the Julia REPL and activate a new project by switching to the package manager with ], and then running","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"activate .","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Now you can install ACEpotentials. Remaining in the package manager, use","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"add ACEpotentials","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Depending on your usage you may also need to add other packages. ","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"<!-- the following packages: `ACE1, JuLIP, ACEfit, ASE`. -->","category":"page"},{"location":"gettingstarted/installation/#Returning-to-a-project","page":"Installation","title":"Returning to a project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"When returning to a project, there are several methods for reactivating it. One is to simply activate . in the package manager, as above. Alternatively set the JULIA_PROJECT environment variable to the directory with Project.toml before starting julia, or call julia as julia --project=<dir>. Special syntax like JULIA_PROJECT=@. or julia --project=@. searches the current directory and its parents for a Project.toml file.","category":"page"},{"location":"gettingstarted/installation/#Trouble-shooting","page":"Installation","title":"Trouble-shooting","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"On some systems ASE.jl and ACEfit.jl is unable to automatically install python dependencies. We found that installing Anaconda and then pointing PyCall.jl to the Anaconda installation (cf PyCall Readme) resolves this. After installing Anaconda, it should then be sufficient to build ASE.jl again.\nIf you cannot use Anaconda python, or if the last point failed, then you can try to install the python dependencies manually before trying to build ASE.jl again. Specifically, it should be sufficient to just install the ase package. Please follow the installation instructions on their website.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"EditURL = \"../tutorials/descriptor.jl\"","category":"page"},{"location":"literate_tutorials/descriptor/#ACE-Descriptors","page":"ACE Descriptors","title":"ACE Descriptors","text":"","category":"section"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"This tutorial demonstrates a simple use of ACE descriptors.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"using ACEpotentials, MultivariateStats, Plots","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Load a tiny silicon dataset, which has the isolated atom, 25 diamond-like (dia) configurations, 25 beta-tin-like (bt) configurations, and 2 liquid (liq) configurations.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"dataset, _, _ = ACEpotentials.example_dataset(\"Si_tiny\");\nnothing #hide","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"An ACE basis specifies a vector of invariant features of atomic environments and can therefore be used as a general descriptor.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"basis = ACE1x.ace_basis(elements = [:Si],\n                        rcut = 5.5,\n                        order = 3,        # body-order - 1\n                        totaldegree = 8);\nnothing #hide","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Compute an averaged structural descriptor for each configuration.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"descriptors = []\nconfig_types = []\nfor atoms in dataset\n    struct_descriptor = sum(site_descriptors(basis, atoms)) / length(atoms)\n    push!(descriptors, struct_descriptor)\n    push!(config_types, atoms.data[\"config_type\"].data)\nend","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Finally, extract the descriptor principal components and plot. Note the segregation by configuration type.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"descriptors = hcat(descriptors...)\nM = fit(PCA, descriptors; maxoutdim=3, pratio=1)\ndescriptors_trans = transform(M, descriptors)\np = scatter(\n    descriptors_trans[1,:], descriptors_trans[2,:], descriptors_trans[3,:],\n    marker=:circle, linewidth=0, group=config_types, legend=:right)\nplot!(p, xlabel=\"PC1\", ylabel=\"PC2\", zlabel=\"PC3\", camera=(20,10))","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"The basis used above uses defaults that are suitable for regression of a potential energy surface, but other defaults might be better when using the ACE descriptor for other tasks such as classification. The following short script shows how to make some changes of this kind:","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"model = acemodel(elements = [:Si,], order = 3, totaldegree = 10,\n       pair_transform = (:agnesi, 1, 4, 0.0),\n       pair_envelope = (:x, 0, 2),\n       transform = (:agnesi, 1, 4, 0.0),\n       envelope = (:x, 0, 2),\n       r0 = :bondlen, # default, could specify explicitly\n       )\nbasis = model.basis","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"[pair_]transfor = (:agnesi, 1, 4, 0.0) : this generates a transform that behaves as t' ~ r^3 near zero and t' ~ r^-2 near the cutoff, but then actually enforces t' = 0 at the cutoff.\n[pair_]envelope = (:x, 0, 2) : this generates an envelope that is ~ (x - xcut)^2 at the cutoff and just ~ 1 for r -> 0.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"using_ace/lammps/#LAMMPS","page":"LAMMPS","title":"LAMMPS","text":"","category":"section"},{"location":"ACEpotentials/all_exported/#ACEpotentials.jl-API","page":"ACEpotentials.jl API","title":"ACEpotentials.jl API","text":"","category":"section"},{"location":"ACEpotentials/all_exported/#Exported","page":"ACEpotentials.jl API","title":"Exported","text":"","category":"section"},{"location":"ACEpotentials/all_exported/","page":"ACEpotentials.jl API","title":"ACEpotentials.jl API","text":"Modules = [ACEpotentials, ACEpotentials.Models, ACEpotentials.ACE1compat]\nPrivate = false","category":"page"},{"location":"ACEpotentials/all_exported/#ACEpotentials.acefit!-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.acefit!","text":"function acefit!(model, data; kwargs...) :  provides a simplified interface to fitting the  parameters of a model specified via ACE1Model. The data should be  provided as a collection (AbstractVector) of JuLIP.Atoms structures. \n\nKeyword arguments:\n\nenergy_key, force_key, virial_key specify \n\nthe label of the data to which the parameters will be fitted. \n\nweights specifies the regression weights, default is 30 for energy, 1 for forces and virials\nsolver specifies the lsq solver, default is BLR (BayesianLinearRegression)\nsmoothness specifies the smoothness prior, i.e. how strongly damped   parameters corresponding to high polynomial degrees are; is 2.\nprior specifies a covariance of the prior, if nothing then a smoothness prior   is used, using the smoothness parameter \nrepulsion_restraint specifies whether to add artificial data to the training   set that effectively introduces a restraints encouraging repulsion   in the limit rij -> 0.\nrestraint_weight specifies the weight of the repulsion restraint.\nexport_lammps : path to a file to which the fitted potential will be exported   in a LAMMPS compatible format (yace)\nexport_json : path to a file to which the fitted potential will be exported   in a JSON format, which can be read from Julia or Python\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.export2lammps-Tuple{Any, ACE1x.ACE1Model}","page":"ACEpotentials.jl API","title":"ACEpotentials.export2lammps","text":"export2lammps(pathtofile, model::ACE1Model) : exports the potential to the .yace format for use in LAMMPS.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.site_descriptor-Tuple{Any, AbstractAtoms, Integer}","page":"ACEpotentials.jl API","title":"ACEpotentials.site_descriptor","text":"site_descriptor(basis, atoms::AbstractAtoms, i::Integer)\n\nCompute the site descriptor for the ith atom in atoms.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.site_descriptors","page":"ACEpotentials.jl API","title":"ACEpotentials.site_descriptors","text":"site_descriptors(basis, atoms::AbstractAtoms[, domain])\n\nCompute site descriptors for all atoms in atoms, returning them as a vector of vectors. If the optional argument domain is passed as a list of  integers (atom indices), then only the site descriptors for those atoms are  computed and returned. \n\n\n\n\n\n","category":"function"},{"location":"ACEpotentials/all_exported/#Not-exported","page":"ACEpotentials.jl API","title":"Not exported","text":"","category":"section"},{"location":"ACEpotentials/all_exported/","page":"ACEpotentials.jl API","title":"ACEpotentials.jl API","text":"Modules = [ACEpotentials, ACEpotentials.Models, ACEpotentials.ACE1compat]\nPublic = false","category":"page"},{"location":"ACEpotentials/all_exported/#ACEpotentials.at_dimer-Tuple{Any, Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.at_dimer","text":"function at_dimer(r, z1, z0) : generates a dimer with separation r and  atomic numbers z1 and z0.  (can also use symbols or strings)\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.at_trimer-NTuple{6, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.at_trimer","text":"function at_trimer(r1, r2, θ, z0, z1, z2) : generates a trimer with separations r1 and r2, angle θ and atomic numbers z0, z1 and z2  (can also use symbols or strings),  where z0 is the species of the central  atom, z1 at distance r1 and z2 at distance r2.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.atom_energy-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.atom_energy","text":"function atom_energy(IP, z0) : energy of an isolated atom\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.decohesion_curve-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.decohesion_curve","text":"Generate a decohesion curve for testing the smoothness of a potential.  Arguments:\n\nat0 : unit cell \npot : potential implementing energy\n\nKeyword Arguments: \n\ndim = 1 : dimension into which to expand\nmult = 10 : multiplicative factor for expanding the cell in dim direction\naa = :auto : array of stretch values of the lattice parameter to use\nnpoints = 100 : number of points to use in the stretch array (for auto aa)\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.dimer_energy-NTuple{4, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.dimer_energy","text":"function dimer_energy(pot, r, z1, z0) : energy of a dimer  with separation r and atomic numbers z1 and z0 using the potential pot;  subtracting the 1-body contributions. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.dimers-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.dimers","text":"dimers(potential, elements; kwargs...) :  Generate a dictionary of dimer curves for a given potential. \n\npotential : potential to use to evaluate energy\nelements : list of chemical species, symbols for which the dimers are to be computed\n\nThe function returns a dictionary Ddim such that D[(s1, s2)] contains pairs or arrays (rr, E) which can be plotted plot(rr, E). \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.get_adf-Tuple{AbstractVector{<:Atoms}, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.get_adf","text":"function get_adf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) :\n\nAngular distribution, i.e. list of angles in [0, π] between all pairs of bonds  of length at most r_cut. Keyword arguments:\n\nskip = 3 : only consider every skipth atom in the dataset.\nmaxsamples = 100_000 : maximum number of samples to return.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.get_rdf-Tuple{AbstractVector{<:Atoms}, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.get_rdf","text":"function get_rdf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) : \n\nProduce a list of r values that occur in the dataset, restricted to the cutoff  radius r_cut. Keyword arguments: \n\nrescale = true : resample the data to account for volume scaling, i.e. a distance r will be kept with probability min(1, (r0/r)^2).\nr0 = :min : parameter for resampling. If :min then the minimum r occuring in the dataset is taken. \nmaxsamples = 100_000 : maximum number of samples to return. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.trimer_energy-NTuple{7, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.trimer_energy","text":"function trimer_energy(IP, r1, r2, θ, z0, z1, z2) : computes the energy of a trimer, subtracting the 2-body and 1-body contributions.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.trimers-NTuple{4, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.trimers","text":"trimers(potential, elements, r1, r2; kwargs...) :  Generate a dictionary of trimer curves for a given potential. \n\npotential : potential to use to evaluate energy \nelements : list of chemical species, symbols for which the trimers are to be computed\nr1, r2 : distance between the central atom and the first, second neighbour\n\nThe function returns a dictionary Dtri such that D[(s1, s2, s3)] contains  pairs or arrays (θ, E) which can be plotted plot(θ, E). \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.ACE1_PolyEnvelope1sR","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.ACE1_PolyEnvelope1sR","text":"The pair basis radial envelope implemented in ACE1.jl \n\n\n\n\n\n","category":"type"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.NormalizedTransform","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.NormalizedTransform","text":"Maps the transform trans to the standardized interval [-1, 1]\n\n\n\n\n\n","category":"type"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.OneBody","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.OneBody","text":"mutable struct OneBody{T}\n\nthis should not normally be constructed by a user, but instead E0 should be passed to the relevant model constructor, which will construct it.\n\n\n\n\n\n","category":"type"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models._make_smatrix-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.Models._make_smatrix","text":"Takes an object and converts it to an SMatrix{NZ, NZ} via the following rules: \n\nif obj is already an SMatrix{NZ, NZ} then it just return obj\nif obj is an AbstractMatrix and size(obj) == (NZ, NZ) then it   converts it to an SMatrix{NZ, NZ} with the same entries.\notherwise it generates an SMatrix{NZ, NZ} filled with the value obj.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.agnesi_transform-NTuple{4, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.agnesi_transform","text":"function agnesi_transform: constructs a generalized agnesi transform. \n\ntrans = agnesi_transform(r0, p, q)\n\nwith q >= p. This generates an AnalyticTransform object that implements \n\n   x(r) = frac11 + a (rr_0)^q  (1 + (rr0)^(q-p))\n\nwith default a chosen such that x(r) is maximised at r = r_0. But a may also be specified directly as a keyword argument. \n\nThe transform satisfies \n\n   x(r) sim frac11 + a (rr_0)^p quad textas quad r to 0 \n   quad textand \n   quad \n   x(r) sim frac11 + a (rr_0)^p  quad textas r to infty\n\nAs default parameters we recommend p = 2, q = 4 and the defaults for a.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.get_nnll_spec-Tuple{ACEpotentials.Models.ACEModel}","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.get_nnll_spec","text":"Get the specification of the BBbasis as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int}.\n\nParameters\n\nmodel : an ACEModel\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.get_nnll_spec-Union{Tuple{ACEpotentials.Models.SparseEquivTensor{T}}, Tuple{T}} where T","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.get_nnll_spec","text":"Get the specification of the BBbasis as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int}.\n\nParameters\n\ntensor : a SparseEquivTensor, possibly from ACEModel\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.set_onehot_weights!-Tuple{ACEpotentials.Models.LearnableRnlrzzBasis, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.set_onehot_weights!","text":"Set the radial weights as they would be in a linear ACE model. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.Models.sparse_AA_spec-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.Models.sparse_AA_spec","text":"This is one of the most important functions to generate an ACE model with  sparse AA basis. It generates the AA basis specification as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int, m::Int}.\n\nParameters\n\norder : maximum correlation order \nr_spec : radial basis specification in the format Vector{@NamedTuple{a::Int64, b::Int64}}\nmax_level : maximum level of the basis, either a single scalar, or an iterable (one for each order)\nlevel : a function that computes the level of a basis element; see e.g. TotalDegree and EuclideanDegree\n\n\n\n\n\n","category":"method"},{"location":"gettingstarted/readinglist/#Reading-List","page":"Reading List","title":"Reading List","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"This page contains a curated list of articles that we recommend as initial reading / background reading towards research on MLPs in general, and ACE in particular. The list naturally reflects the authors' personal perspectives and preferences.","category":"page"},{"location":"gettingstarted/readinglist/#General-Background-/-Classics","page":"Reading List","title":"General Background / Classics","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"Bowman/Braams\nBehler/Parinello \nGAP \nMTPs \nANI ","category":"page"},{"location":"gettingstarted/readinglist/#ACE","page":"Reading List","title":"ACE","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]\nPACE","category":"page"},{"location":"gettingstarted/readinglist/#Review-articles","page":"Reading List","title":"Review articles","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"Chem Rev","category":"page"},{"location":"gettingstarted/aceintro/#Introduction-to-ACE-Models","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The purpose of this section is to give a brief summary of the mathematics behind linear ACE parameterisations of invariant atomic properties. It is not required to use the ACEpotentials and ACE1 packages and can be skipped on a first reading.","category":"page"},{"location":"gettingstarted/aceintro/#Invariant-Properties","page":"Introduction to ACE Models","title":"Invariant Properties","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To explain the main ideas in the simplest non-trivial setting, we consider systems of indistinguishable particles. A configuration is an mset R =  bm r_j _j subset mathbbR^3 with arbitary numbers of particles and we wish to develop representation of properties ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   varphibig(R) in mathbbR","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"which are invariant under permutations (already implicit in the fact that R is an mset) and under isometries O(3). To make this explicit we can write this as","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"varphibig(  Q bm r_sigma j _j big)\n=\nvarphibig(  bm r_j _j big) qquad forall Q in O(3) \nquad sigma text a permutation","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To that end we proceed in three steps: ","category":"page"},{"location":"gettingstarted/aceintro/#Density-Projection-/-Atomic-Base","page":"Introduction to ACE Models","title":"Density Projection / Atomic Base","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"We define the \"atomic density\"","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"rho(bm r) = sum_j delta(bm r - bm r_j)","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Then we choose a one-particle basis ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"phi_v(bm r) = phi_nlm(bm r) = R_n(r) Y_l^m(hatbm r)","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"and project rho` onto that basis, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"A_v = A_nlm = langle phi_nlm rho rangle = \n   sum_j phi_nlm(bm r_j)","category":"page"},{"location":"gettingstarted/aceintro/#Density-correlations","page":"Introduction to ACE Models","title":"Density correlations","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Next, we form the N-correlations of the density, rho^otimes N and project them onto the tensor project basis, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   bm A_bm nlm \n   = Biglangle otimes_t = 1^N phi_n_t l_t m_t rho^otimes N Bigrangle \n   = prod_t = 1^N A_n_t l_t m_t","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The reason to introduce these is that in the next step, the symmetrisation step the density project would loose all angular information while the N-correlations retain most (though not all) of it. ","category":"page"},{"location":"gettingstarted/aceintro/#Symmetrisation","page":"Introduction to ACE Models","title":"Symmetrisation","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Finally, we symmetrize the N-correlations, by integrating over the O(3)-Haar measure, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  B_bm nlm propto \n  int_O(3) bm A_bm nlm circ Q  dQ ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of properties of the spherical harmonics one can write this as ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  bm B = mathcalU bm A","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"where bm A is the vector of 1, 2, ..., N correlations (the maximal N is an approximation parameter!) and mathcalU is a sparse matrix (the coupling coefficients).","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"If one symmetrised all possible N-correlations then this would create a spanning set, but one can easily reduce this to an actual basis. This construction then yields a basis of the space of symmetric polynomials. ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Notes: ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of permutation symmetry only ordered bm v tuples are retained","category":"page"},{"location":"gettingstarted/aceintro/#Linear-Dependence","page":"Introduction to ACE Models","title":"Linear Dependence","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The construction described above introduces a lot of linear dependence which is removed in the ACE basis construction in a mixed symbolic / numerical procedure. In the end we no longer index the symmetrized basis functions as B_bm nlm but as B_bm nli with i indexing the linearly independent basis functions from the bm nl block. ","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"EditURL = \"../tutorials/TiAl_model.jl\"","category":"page"},{"location":"literate_tutorials/TiAl_model/#The-acemodel-interface","page":"The acemodel interface","title":"The acemodel interface","text":"","category":"section"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"For most people, this is the easiest interface to work with. The alternative acebasis interface is useful for exploring many different options.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"Start by importing the required libraries","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"using ACEpotentials","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We need a dataset TiAl_tutorial.xyz for this tutorial. Normally we would get the path to a datset and then use read_extxyz to load in the training set.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"# (don't execute this block)\ndata_file = \"path/to/TiAl_tutorial.xyz\"\ndata = read_extxyz(data_file)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"For convenience we provide this dataset as a Julia artifact and make it conveniently accessible via ACEpotentials.example_dataset. We keep only a small subset of the training structures to keep the regression problem small.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"data, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ntrain_data = data[1:5:end];\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"The next step is to generate a model","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"order = 3 : We take 3-correlation, i.e. a 4-body potential,\ntotaldegree = 6 : a very low polynomial degree just for testing\nrcut = 5.5 : this is a typical cutoff radius for metals","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"These three are the most important approximation parameters to explore when trying to improve the fit-accuracy. There are many other parameters to explore, which are documented in ?acemodel. Even further model refinements are possible by studying the internals of ACE1.jl and ACE1x.jl. We also specify a reference potential that will be added to the learned 2-body and many-body potential components. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape and improved robustness in predictions.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"model = acemodel(elements = [:Ti, :Al],\n\t\t\t\t\t  order = 3,\n\t\t\t\t\t  totaldegree = 6,\n\t\t\t\t\t  rcut = 5.5,\n\t\t\t\t\t  Eref = [:Ti => -1586.0195, :Al => -105.5954])\n@show length(model.basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"The next line specifies the regression weights: in the least squares loss different observations are given different weights,","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"  sum_R Big( w^E_R  E(R) - y_R^E ^2\n           + w^F_R  rm forces(R) - y_R^F ^2\n           + w^V_R  rm virial(R) - y_R^V ^2 Big)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"and this is specificed via the following dictionary. The keys correspond to the config_type of the training structures.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"weights = Dict(\n        \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"To estimate the parameters we still need to choose a solver for the least squares system. In this tutorial we use the LSQR algorithm, for no specific reason at all. Many other solvers are available, and can be explored by looking at the documentation of ACEfit.jl.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"solver = ACEfit.LSQR(damp = 1e-2, atol = 1e-6);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"ACE1.jl has a heuristic smoothness prior built in which assigns to each basis function Bi a scaling parameter si that estimates how \"rough\" that basis function is. The following line generates a regularizer (prior) with si^q on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"P = smoothness_prior(model; p = 4)    #  (p = 4 is in fact the default)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We are now ready to estimate the parameters. We take a subset of the training data to speed up the tutorial. The prior is passed to the acefit! function via the prior keyword argument.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"data_train = data[1:5:end]\nacefit!(model, data_train; solver=solver, prior = P);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We can display an error table as follows:","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"@info(\"Training Error Table\")\nACEpotentials.linear_errors(data_train, model; weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We should of course also look at test errors, which can be done as follows. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"@info(\"Test Error Table\")\ntest_data = data[2:10:end]\nACEpotentials.linear_errors(test_data, model; weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"If we want to save the fitted potentials to disk to later use we can use one of the following commands: the first saves the potential as an ACE1.jl compatible potential, while the second line exports it to a format that can be ready by the pacemaker code to be used within LAMMPS.  (currently disabled)","category":"page"},{"location":"literate_tutorials/TiAl_model/#save*potential(\"./TiAl*tutorial_pot.json\",-model)","page":"The acemodel interface","title":"savepotential(\"./TiAltutorial_pot.json\", model)","text":"","category":"section"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"export to lammps (ML-PACE): (currently disabled)","category":"page"},{"location":"literate_tutorials/TiAl_model/#export2lammps(\"./TiAl*tutorial*pot.yace\",-model)","page":"The acemodel interface","title":"export2lammps(\"./TiAltutorialpot.yace\", model)","text":"","category":"section"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ACEpotentials","category":"page"},{"location":"#ACEpotentials.jl-Documentation","page":"Home","title":"ACEpotentials.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACEpotentials.jl facilitates the creation and use of atomic cluster expansion (ACE) interatomic potentials. For a quick start, we recommend reading the installation instructions, followed by the tutorials. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ACE models are defined in terms of body-ordered invariant features of atomic environments. For mathematical details, see this brief introduction and the references listed below.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACEpotentials.jl ties together several Julia packages implementing different aspects of ACE modelling and fitting (e.g., JuLIP.jl, ACE1.jl, ACE1x.jl, ACEfit.jl, and ACEmd.jl). ACEpotentials re-exports their features, ensuring version compatibility, and provides additional fitting and analysis tools. For example, it provides routines for parsing and manipulating the data to which interatomic potentials are fit (total energies, forces, virials, etc). These pages document ACEpotentialstogether with the relevant parts of the wider ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"JuLIP.jl is simple pure-Julia molecular simulation package that provides infrastructure for interatomic potentials. It is the foundation on which the other packages build.\nACE1.jl parameterizes interatomic potentials in terms of the (linear) atomic cluster expansion. It provides generate invariant basis sets and functions that evaluate the resulting interatomic potentials.\nACE1x.jl is an extension of ACE1.jl incorporating new experimental features. We expect to merge these packages over time.\nACEfit.jl supplies the functionality for parameter estimation. Presently, it focuses purely on linear models and linear observations. A broad range of solvers are available. \nACEmd.jl is a new implementation of ACE calculators compatible with Molly.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: JSON and command line interfaces\nAn earlier version of ACEpotentials.jl contained JSON and command line interfaces that can be used to fit ACE potentials without needing to write Julia scripts. These have not been updated to include the most recent features available from the Julia interfaces. Until this changes, we recommend using ACEpotentials.jl only through the Julia interfaces. If this is a feature important to you, please file an issue or bump an existing issue to accelerate us updating this feature.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]","category":"page"},{"location":"tutorials/molly/#Using-ACE-potentials-in-Molly","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"Molly is pure Julia MD program that is in development. ACE support for Molly is currently in ACEmd package, which is exported by ACEpotentials.","category":"page"},{"location":"tutorials/molly/#Things-to-know-about-Molly","page":"Using ACE potentials in Molly","title":"Things to know about Molly","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"Molly expects units to be defined. Our fitting procedure does not define units (implicitly we use eV for energy and Å length), so in order to use Molly, units need to be defined. This is done by wrapping potentials to a structure that holds units in addition to the potential. The units used are defined in Unitful, which is exported by default.","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To wrap units for a potential you can use load_ace_model function, which can take in a potential you have just fitted as an input. You can also load json or yace potential files exported from ACEpotentials.jl or ACE1.jl.","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"using ACEpotentials\n\n# Load potential from file\npotential = load_potential( \"path to potential file\"; new_format=true )","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"The default units are eV for energy and Å for length. You can change these with","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"pot_new_units = ACEpotential(\n    old_potential.potentials;\n    energy_unit = u\"hartree\",\n    length_unit = u\"bohr\",\n    cutoff_unit = u\"pm\"\n)","category":"page"},{"location":"tutorials/molly/#System-setup","page":"Using ACE potentials in Molly","title":"System setup","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To start Molly you need to prepare the Molly system. There are still some ACE specific complications with this. But please refer to Molly documentation","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"using Molly\nusing ACEpotentials\nusing AtomsIO\n\n# Load initial structure\ndata = AtomsIO.load_system(\"initial structure file\")\n# or use whatever AtomsBase structure\n# need to have velocity return other than missing\n\n# Load ACE potential\npot = load_potential(\"some ace potential file\"; new_format=true)\n\n# Pack data to Molly compatible format\nsys = Molly.System(data, pot)\n\n# Set up temperature and velocities\ntemp = 298.0u\"K\"\nvel = random_velocities!(sys, temp)\n\n# Add loggers\n# need at least Molly v0.17 for this\nsys = Molly.System(\n    sys;\n    loggers=(temp=TemperatureLogger(100),) # add more loggers here\n)","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"You can also customize system more. For details refer Molly documentation.","category":"page"},{"location":"tutorials/molly/#Set-up-simulation","page":"Using ACE potentials in Molly","title":"Set up simulation","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To setup Molly simulation you need to create simulation object","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"# Set up simulator\nsimulator = VelocityVerlet(\n    dt=1.0u\"fs\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"After this you can run the simulation by","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"# Perform MD for 1000 steps\nsimulate!(sys, simulator, 1000)","category":"page"},{"location":"using_ace/openmm/#OpenMM","page":"OpenMM","title":"OpenMM","text":"","category":"section"}]
}
