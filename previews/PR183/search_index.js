var documenterSearchIndex = {"docs":
[{"location":"using_ace/openmm/#OpenMM","page":"OpenMM","title":"OpenMM","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/#Saving-and-Loading-Potentials","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/#Saving-Potentials-for-Julia-use","page":"Saving and Loading Potentials","title":"Saving Potentials for Julia use","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"To save potentials for future Julia use can use","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"save_ace_potential(\"my-potential-file.json\", potential)","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"This will save the potential in json format. You can also use yml and yace suffixes.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"The format used for saving can be either ACEmodel from acemodel function, JuLIP style potentials or ACEmd style ACEpotential.","category":"page"},{"location":"gettingstarted/saving-and-loading/#Loading-Potentials","page":"Saving and Loading Potentials","title":"Loading Potentials","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"To load potential use","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"potential = load_ace_potential(\"my-potential-file.json\")","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"By default this should print information about version in use when the potential was saved. E.g. like following","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"This potential was saved with following versions:\n\nJuLIP v0.14.5\nACEbase v0.4.3\nACE1x v0.1.8\nACE1 v0.11.16\nACEmd v0.1.7\nACEpotentials v0.6.3\nACEfit v0.1.4\n\nIf you have problems with using this potential, pin your installation to above versions.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"If you have problems with the potential, you can use the given version numbers to build an installation that should have the potential working.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"By default the loaded potential is in JuLIP style format. To load a new ACEmd style ACEpotential you can give keyword new_format=true","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"potential = load_ace_potential(\"my-potential-file.json\"; new_format=true)","category":"page"},{"location":"gettingstarted/saving-and-loading/#Exporting-Potentials-for-Other-Programs","page":"Saving and Loading Potentials","title":"Exporting Potentials for Other Programs","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"LAMMPS export is described in section ACEpotentials potentials in LAMMPS.","category":"page"},{"location":"tutorials/python_ase/#python-ase","page":"python-ase","title":"python-ase","text":"","category":"section"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"An ACEpotentials.jl model can be used in python as an ase calculator. To do this, you will need to install two python packages, julia and pyjulip as documented on the installation page. ","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Python reads the potential.json file directly. To load an ACE potential as an ase calculator, use the following syntax:","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"import pyjulip\ncalc = pyjulip.ACE1(\"first_potential.json\")","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Using that calculator, we can then evaluatuate energies, forces, etc, e.g., ","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"ats = ase.io.read('atoms_object.xyz')\nats.calc = calc\nprint(ats.get_potential_energy())","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"See the ase documentation for more details. ","category":"page"},{"location":"gettingstarted/pkg/#Using-the-Julia-Package-Manager","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This is a very brief introduction to the Julia package manager, intended for newcomers to Julia who are here primarily to use the ACEsuit. But it is not really ACE specific at all. ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"<!-- If you plan to use `ACEpotentials.jl` from Python or the command line, then you need not read this. -->","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The package manager provides functionality to organize reproducable Julia projects. A project is specified by a Project.toml where the user specifies which packages are required, and version bounds on those packages. The Package manager can then resolve these dependencies which results in a Manifest.toml where the full Julia environment is precisely specified. This can be used in a workflow as follows:","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"To start a new project that uses ACEpotentials.jl, e.g. to develop a new interatomic potential for TiAl we first create a new folder where the project will live, e.g., ace_TiAl_project. Change to that folder and start the Julia REPL. Type ] to switch to the package manager, then activate a new project in the current directory via activate .\nYou now have an empty project. Start adding the packages you need, often just   add ACEpotentials  will suffice.   Type status to see your required packages listed. (Note this is only a subset of the installed packages!). Exit the REPL and type ls; you will then see a new file Project.toml which lists the project requirements, and a Manifest.toml which lists the actually packages and the version that have been installed.\nSpecify version bounds: We strongly encourage doing this rigorously! Open Project.toml in an editor and under the [compat] section you can now add version bounds, e.g. ACEpotentials = \"0.6.1\" following semver. Please see the Pkg.jl docs for details on how to specify those bounds. Start a Julia REPL again, type ] to switch to the package manager and then up to up- or down-grade all installed packages to the latest version compatible with your bounds.","category":"page"},{"location":"gettingstarted/pkg/#Using-a-Development-Branch-(rarely-required)","page":"Using the Julia Package Manager","title":"Using a Development Branch (rarely required)","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"If you are a user rather than developer it should almost never be required for you to check out a package (or, dev it in the package manager). When developers make changes to - say - ACEpotentials.jl they will always immediately tag another version and then you can adjust your version bounds in your project to update as well as enforce which version to use. However a developer would frequently do this, and occasionally it might be required when iterating between a user and developer for testing. There are multiple ways to achieve this; the following is our recommended procedure: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Suppose for example that a development branch co/dev of ACE1.jl is needed in a project project. Then one should perform the following steps: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Make sure ACE1 has been added to project/Project.toml \nIn a separate folder, /path/to/ , clone ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"cd /path/to\ngit clone git@github.com:ACEsuit/ACE1.jl.git\ngit checkout co/dev","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"so that the repo will now live in /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Go to and activate project, then in a Julia REPL switch to the package manager ] and execute","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"dev /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This will replace the ACE1 package in the Manifest with the version that lives in /path/to/ACE1.jl ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Later on, when you want to go back to the standad Pkg versin control you can simply free ACE1.","category":"page"},{"location":"gettingstarted/pkg/#Further-Notes","page":"Using the Julia Package Manager","title":"Further Notes","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The Project.toml should always be committed to your project git repo. Whether Manifest.toml is also committed is a matter of taste or context. Tracking the Manifest will (normally) ensure future compatibility since it allows you to reconstruct the precise Julia environment that was used when the Manifest was created.","category":"page"},{"location":"gettingstarted/pkg/#Links","page":"Using the Julia Package Manager","title":"Links","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"https://pkgdocs.julialang.org/v1/\nhttps://pkgdocs.julialang.org/v1/compatibility/","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"EditURL = \"../tutorials/TiAl_basis.jl\"","category":"page"},{"location":"literate_tutorials/TiAl_basis/#The-ace_basis-interface","page":"The ace_basis interface","title":"The ace_basis interface","text":"","category":"section"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Start by importing the required libraries","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"using ACEpotentials","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"We need a dataset TiAl_tutorial.xyz for this tutorial. Normally we would get the path to a datset and then use read_extxyz to load in the training set.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"data_file = \"path/to/TiAl_tutorial.xyz\"\ndata = read_extxyz(data_file)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"For convenience we provide this dataset as a Julia artifact and make it conveniently accessible via ACEpotentials.example_dataset. We keep only a small subset of the training structures to keep the regression problem small.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"data, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ntrain_data = data[1:5:end];\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The next step is to generate a basis set:","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"order = 3 : We take 3-correlation, i.e. a 4-body potential,\ntotaldegree = 6 : a very low polynomial degree just for testing\nrcut = 5.5 : this is a typical cutoff radius, there is also a good default which is a bit higher","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"These three are the most important approximation parameters to explore when trying to improve the fit-accuracy. In addition there is","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The parameter r0 is just a scaling parameter and the fits should not be very sensitive to its choice. A rough estimate for the nearest-neighbour distance is usually ok. (NB: if you change to a non-trivial distance transform, then the parameter r0 may become important.)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"r0 = 2.88\nbasis = ACE1x.ace_basis(elements = [:Ti, :Al],\n                  order = 3,\n                  totaldegree = 6,\n                  rcut = 5.5,\n                  r0 = r0,)\n@show length(basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Vref specifies a reference potential, which is subtracted from the training data and the ACE parameters are then estimated from the difference. This reference potential will in the end be added to the ACE model. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Vref = OneBody(:Ti => -1586.0195, :Al => -105.5954);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The next line specifies the regression weights: in the least squares loss different observations are given different weights,","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"  sum_R Big( w^E_R  E(R) - y_R^E ^2\n           + w^F_R  rm forces(R) - y_R^F ^2\n           + w^V_R  rm virial(R) - y_R^V ^2 Big)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"and this is specificed via the following dictionary. The keys correspond to the config_type of the training structures.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"weights = Dict(\n        \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The next step is to evaluate the basis on the training set. Precomputing the basis once (and possibly save it to disk) makes experimenting with different regression parameters much more efficient. This is demonstrated below by showing various different solver options. Similarly once could also explore different data weights (see weights below).","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"datakeys = (energy_key = \"energy\", force_key = \"force\", virial_key = \"virial\")\ntrain = [ACEpotentials.AtomsData(t; weights=weights, v_ref=Vref, datakeys...) for t in train_data]\nA, Y, W = ACEfit.assemble(train, basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"ACE1.jl has a heuristic smoothness prior built in which assigns to each basis function Bi a scaling parameter si that estimates how \"rough\" that basis function is. The following line generates a regularizer (prior) with si^q on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"P = smoothness_prior(basis; p = 4)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"Once all the solver parameters have been determined, we use ACEfit to estimate the parameters. This routine will return the fitted interatomic potential IP as well as the a dictionary lsqfit with some information about the fitting process.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"solver = ACEfit.LSQR(damp = 1e-2, atol = 1e-6, P = P)\nresults = ACEfit.solve(solver, W .* A, W .* Y)\npot_1 = JuLIP.MLIPs.SumIP(Vref, JuLIP.MLIPs.combine(basis, results[\"C\"]));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The advantage of working with the ACE basis rather than the ACE model interface is that we can now make some changes to the fitting parameters and refit. For example, we might want different weights, change the smoothness prior, and switch to a RRQR solver.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"weights[\"FLD_TiAl\"][\"E\"] = 20.0\nW = ACEfit.assemble_weights(train)\nsolver = ACEfit.RRQR(; rtol = 1e-8, P = smoothness_prior(basis; p = 2))\nresults = ACEfit.solve(solver, W .* A, W .* Y)\npot_2 = JuLIP.MLIPs.SumIP(Vref, JuLIP.MLIPs.combine(basis, results[\"C\"]));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"We can now compare the errors in a nice table. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"test = [ACEpotentials.AtomsData(t; weights=weights, v_ref=Vref, datakeys...) for t in data[2:10:end]]\n\n@info(\"Test Error Tables\")\n@info(\"First Potential: \")\nACEpotentials.linear_errors(test, pot_1);\n\n@info(\"Second Potential: \")\nACEpotentials.linear_errors(test, pot_2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"If we want to save the fitted potentials to disk to later use we can use one of the following commands: the first saves the potential as an ACE1.jl compatible potential, while the second line exports it to a format that can be ready by the pacemaker code to be used within LAMMPS.","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"save_ace_potential(\"./TiAl_tutorial_pot.json\", pot_1)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"The fitted potential can also be exported to a format compatible with LAMMPS (ML-PACE)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"export2lammps(\"./TiAl_tutorial_pot.yace\", pot_1)","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"","category":"page"},{"location":"literate_tutorials/TiAl_basis/","page":"The ace_basis interface","title":"The ace_basis interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"outdated/first_example_json/#Command-Line-JSON-(TiAl)","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"","category":"section"},{"location":"outdated/first_example_json/","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"In this tutorial we will fit a TiAl potential using the ACE fitting script of ACEpotentials and a JSON file with all the mandatory and non-default parameters. The fitting itself is simply","category":"page"},{"location":"outdated/first_example_json/","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"julia .../ACEpotentials.jl/scripts/ace_fit.jl --params ace_params.json","category":"page"},{"location":"outdated/first_example_json/","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"For this example, the parameters file contains the following. For more details see section on \"Command line interface\" and \"ACEpotentials Internals\". ","category":"page"},{"location":"outdated/first_example_json/","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"{\n    \"ACE_fname\": \"ACE.json\",\n    \"e0\": {\n        \"Ti\": -1586.0195,\n        \"Al\": -105.5954},\n    \"weights\": {\n        \"FLD_TiAl\": {\n            \"V\": 1.0,\n            \"E\": 30.0,\n            \"F\": 1.0},\n        \"TiAl_T5000\": {\n            \"V\": 1.0,\n            \"E\": 5.0,\n            \"F\": 1.0}\n    },\n    \"P\": {\"type\": \"laplacian\"},\n    \"data\": {\n        \"force_key\": \"force\",\n        \"energy_key\": \"energy\",\n        \"fname\": \"TiAl_tutorial.xyz\",\n        \"virial_key\": \"virial\"},\n    \"solver\": {\n        \"lsqr_damp\": 0.01,\n        \"type\": \"lsqr\"},\n    \"basis\": {\n        \"main_ace\": {\n            \"N\": 3,\n            \"maxdeg\": 6,\n            \"radial\": {\n                \"rcut\": 5.5,\n                \"rin\": 1.728},\n            \"type\": \"ace\",\n            \"transform\": {\n                \"r0\": 2.88,\n                \"type\": \"polynomial\"},\n            \"species\": [\"Ti\", \"Al\"]},\n        \"main_pair\": {\n            \"rcut\": 7.0,\n            \"rin\": 0.0,\n            \"maxdeg\": 6,\n            \"type\": \"pair\",\n            \"transform\": {\n                \"r0\": 2.88,\n                \"type\": \"polynomial\"},\n            \"species\": [\"Ti\", \"Al\"]\n        }\n    }\n}","category":"page"},{"location":"outdated/first_example_json/","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"Brief explanation of the main entries:","category":"page"},{"location":"outdated/first_example_json/","page":"Command Line JSON (TiAl)","title":"Command Line JSON (TiAl)","text":"ACE_fname - filename for the fitted potential. The script will produce a file called ACE.json which can be read by julia and python, and a file called ACE.yace which can be read by lammps. \ne0 - isolated atom energies\nweights - weights for the loss function, for the specific structures. The labels (e.g. \"TiAlT5000\") correspond to the \"configtype\" entry in the .xyz's \"info\" field. \nP - specifies (a part of) the regularisation (optional).  \ndata - .xyz filename with atomic structures and the specific energy/force/virial entries to fit to. \nsolver - specifies the LSQR solver\n`basis \n\"main_ace\" - defines the ACE basis\n\"main_pair\" - defines the pair basis","category":"page"},{"location":"outdated/command_line_old/#OLD-(!)-Command-line-interface","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"","category":"section"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"The (most likely) easiest way to fit an ACE potential is via the command line from a JSON or YAML parameters file: ","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"julia .../outdated/scripts/ace_fit.jl --params ace_params.json","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"In addition to parameters' file, ace_fit.jl takes an optional --dry-run flag. If it is given, a .size file is produced with the shape of the design matrix, useful for estimating the time and memory requirements before submitting an actual fit. Finally, there is a --num-blas-threads option for setting the number of BLAS threads to use (for fitting). ","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"For the script to use the correct Julia environment, JULIA_PROJECT (a path) must be set to the folder where Julia's Project.toml and Manifest.toml are. ","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"Below are examples of the parameters' files. The first one gives only the mandatory values and the second one has all of the default values filled in. For details on specific values see the appropriate pages of ACEpotentials Internals. Explanation of the top-level dictionary, with links to the nested dictionaries therein are in Fitting ACE. ","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"Mandatory parameters","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"\n{\n    \"e0\": {\n        \"Ti\": -1586.0195,\n        \"Al\": -105.5954},\n    \"data\": {\n        \"fname\": \"training_set.xyz\"},\n    \"solver\": {\"type\": \"rrqr\"},\n    \"basis\": {\n        \"main_ace\": {\n            \"type\": \"ace\",\n            \"species\": [\"Ti\", \"Al\"]},\n            \"N\": 2,\n            \"maxdeg\": 10,\n        \"main_pair\": {\n            \"species\": [\"Ti\",\"Al\"]\n            \"maxdeg\": 4,\n        }\n    }\n}\n","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"Parameters with all default values","category":"page"},{"location":"outdated/command_line_old/","page":"OLD (!) Command line interface","title":"OLD (!) Command line interface","text":"\n{\n    \"e0\": {\n        \"Ti\": -1586.0195,\n        \"Al\": -105.5954},\n    \"weights\": {\n        \"default\": {\n            \"E\": 1.0,\n            \"F\": 1.0}},\n            \"V\": 1.0,\n    \"P\": null,\n    \"fit_from_LSQ_DB\": false,\n    \"data\": {\n        \"fname\": \"training_set.xyz\",\n        \"energy_key\": \"dft_energy\",\n        \"force_key\": \"dft_force\",\n        \"virial_key\": \"dft_virial\"},\n    \"solver\": {\n        \"type\": \"rrqr\"},\n        \"tol\": 1.0e-5,\n    \"basis\": {\n        \"main_ace\": {\n            \"type\": \"ace\",\n            \"species\": [\"Ti\", \"Al\"]},\n            \"N\": 2,\n            \"maxdeg\": 10,\n            \"r0\": 2.5,\n            \"radial\": {\n                \"rcut\": 5.0,\n                \"rin\": 0.5,\n                \"r0\": 2.5,\n                \"pin\": 2,\n                \"pcut\": 2,\n                \"type\": \"radial\"},\n            \"degree\": \"degree\",\n            \"transform\": {\n                \"r0\": 2.5,\n                \"type\": \"polynomial\",\n                \"p\": 2},\n        \"main_pair\": {\n            \"type\": \"pair\",\n            \"species\": [\"Ti\", \"Al\"]}},\n            \"rcut\": 5.0,\n            \"rin\": 0.0,\n            \"maxdeg\": 4,\n            \"r0\": 2.5,\n            \"pin\": 0,\n            \"pcut\": 2,\n            \"transform\": {\n                \"r0\": 2.5,\n                \"type\": \"polynomial\",\n                \"p\": 2},\n    \"LSQ_DB_fname_stem\": \"\",\n    \"ACE_fname\": \"ACE_fit.json\"\n}\n","category":"page"},{"location":"outdated/fit/#Fitting-ACE","page":"Fitting ACE","title":"Fitting ACE","text":"","category":"section"},{"location":"outdated/fit/#Top-level-overview","page":"Fitting ACE","title":"Top-level overview","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"The most minimal way of generating an ACE potential is ","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"using ACEpotentials\nparams = ... # see below \nfit_ace()","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"In the first instance, the parameters' dictionary (params) is generated by the *params() functions described in the rest of these pages. It can also be read from a .json or .yaml file. ","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"fit_ace() takes the dictionary generated by fit_params()","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"ACEpotentials.fit_ace\nACEpotentials.fit_params","category":"page"},{"location":"outdated/fit/#ACEpotentials.fit_ace","page":"Fitting ACE","title":"ACEpotentials.fit_ace","text":"fit_ace(params::Dict) -> IP, lsqinfo \n\nFunction to set up and fit the least-squares  problem of \"atoms' positions\" -> \"energy, forces, virials\". Takes in a  dictionary with all the parameters. See ?fit_params for details. \n\n\n\n\n\n","category":"function"},{"location":"outdated/fit/#ACEpotentials.fit_params","page":"Fitting ACE","title":"ACEpotentials.fit_params","text":"fit_params(; kwargs...) \n\nReturns a dictionary containing all of the parameters needed to make an ACE potential. All parameters are passed  as keyword argumts. \n\nParameters\n\ndata : data parameters, see ?data_params for details (mandatory)\nbasis : dictionary containing dictionaries that specify the basis used in fitting.     For example \n\nbasis = Dict(\n    \"pair_short\" => Dict( \"type\" => \"pair\", ...), \n    \"pair_long\" => Dict(\"type\" => \"pair\", ...), \n    \"manybody\" => Dict(\"type\" => \"ace\", ...), \n    \"nospecies\" => Dict(\"type\" => \"ace\", species = [\"X\",], ...)\n\nkeys of basis are ignored, so that multiple basis with different specifications  (e.g. smaller and larger cutoffs) can be combined. See ?basis_params for more detail.  \n\nsolver : dictionary containing parameters that specify the solver for    least squares problem (mandatory). See ?solver_params.\ne0 : Dict{String, Float} containing reference values for isolated atoms'   energies (mandatory). \nweights : dictionary of Dict(\"config_type\" => Dict(\"E\" => Float, \"F => Float))entries specifying fitting weights. \"default\" is set to1.0` for all of \"E\", \"F\",   and \"V\" weights. \nP : regularizer parameters (optional), see ?regularizer_params.\nACE_fname = \"ACE_fit.json\" : filename to save ACE to. Potential & info   do not get saved if ACE_fname isnothing() or is set to \"\". Files already parseentry   are renamed and not overwritten. \nLSQ_DB_fname_stem = \"\" : stem to save LsqDB to. Doesn't get saved if set to an empty    string (\"\"). If the file is already present, but fit_from_LSQ_DB is set to false,   the old database is renamed, a new one constructed and saved under the given name. \nfit_from_LSQ_DB = false: whether to fit from a least squares database specified with   LSQ_DB_fname_stem. If LSQ_DB_fname_stem * \"_kron.h5\" file is not present, LsqDB is    constructed from scratch and saved.  \n\n\n\n\n\n","category":"function"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"Parameters LSQ_DB_fname_stem and fit_from_LSQ_DB determine if the least-squares gets saved and/or where/how it gets fit from. ","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"LSQ_DB_fname_stem is set to \"\": LsqDB is neither saved to nor read from file;\nLSQ_DB_fname_stem is given:\nfile not present: LsqDB saved to disk and fit to;\nfile present:\nfit_from_LSQ_DB is true: fit to the LsqDB on disk;\nfit_from_LSQ_DB is false: rename old LsqDB; make, save and fit to a new LsqDB.    ","category":"page"},{"location":"outdated/fit/#TODO","page":"Fitting ACE","title":"TODO","text":"","category":"section"},{"location":"outdated/fit/#Create-LsqDB-and-fit-it-separately","page":"Fitting ACE","title":"Create LsqDB & fit it separately","text":"","category":"section"},{"location":"outdated/fit/#","page":"Fitting ACE","title":"","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"#It is also possible to decouple making the least-squares database from fitting to it. ","category":"page"},{"location":"outdated/fit/#-2","page":"Fitting ACE","title":"","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"#@docs #make_ace_db #fit_ace_db #","category":"page"},{"location":"outdated/fit/#-3","page":"Fitting ACE","title":"","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"#In fact, fit_ace() just calls both of these in one go.","category":"page"},{"location":"outdated/fit/#Reading-parameters-in-from-file","page":"Fitting ACE","title":"Reading parameters in from file","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"Dictionaries may be read in from file with","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"params = load_dict(\"params.json\")\n# or \nparams = load_dict(\"params.yaml\")","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"There is a convenience function fill_defaults() that recursively fills in any missing values with defaults, so that only mandatory or non-default values have to be saved in the files.","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"ACEpotentials.fill_defaults","category":"page"},{"location":"outdated/fit/#ACEpotentials.fill_defaults","page":"Fitting ACE","title":"ACEpotentials.fill_defaults","text":"fill_defaults(params::Dict; param_key = \"fit_params\") -> params\n\nRecursively updates any missing entries with default parameters. Accepted param_key values and corresponding functions: \n\n    \"fit_params\" => ACEpotentials.fit_params,\n    \"data\" => ACEpotentials.data_params,\n    \"solver\" => ACEpotentials.solver_params,\n    \"basis\" => ACEpotentials.basis_params,\n    \"ace\" => ACEpotentials.ace_basis_params,  \n    \"pair\" => ACEpotentials.pair_basis_params,\n    \"radial\" => ACEpotentials.radial_basis_params,\n    \"transform\" => ACEpotentials.transform_params, \n    \"degree\" => ACEpotentials.degree_params,\n    \"P\" => ACEpotentials.regularizer_params\n\n\n\n\n\n","category":"function"},{"location":"outdated/fit/#Examples-of-minimal-set-of-parameters","page":"Fitting ACE","title":"Examples of minimal set of parameters","text":"","category":"section"},{"location":"outdated/fit/#Minimal-set","page":"Fitting ACE","title":"Minimal set","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"To give an overview of the structure of the parameters' dictionary below is an example with only the mandatory values filled in. ","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"mandatory_params = Dict(\n    \"data\" => Dict(\n        \"fname\" => \"training_set.xyz\"),\n    \"basis\" => Dict(\n        \"main_ace\" => Dict(\n            \"species\" => [\"Ti\", \"Al\"],  \n            \"N\" => 2,                   # correlation order\n            \"maxdeg\" => 10,             # polynomial degree\n            \"type\" => \"ace\"),           # specifies many-body/ace basis functions \n        \"main_pair\" => Dict(\n            \"species\" => [\"Ti\", \"Al\"],  \n            \"maxdeg\" => 4,              # polynomial degree for the 2-body functions\n            \"type\" => \"pair\"            # specify 2-body basis\n            ),),\n    \"solver\" => Dict(\n        \"type\" => \"rrqr\"),              # use rank-revealing QR factorisation \n    \"e0\" => Dict(                       # isolated atom energies, eV\n        \"Ti\" => -1586.0195,\n        \"Al\" => -105.5954))","category":"page"},{"location":"outdated/fit/#With-all-default-values","page":"Fitting ACE","title":"With all default values","text":"","category":"section"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"The following is the full set of parameters, including the default values. ","category":"page"},{"location":"outdated/fit/","page":"Fitting ACE","title":"Fitting ACE","text":"params_with_defaults = Dict(\n    \"data\" => Dict(\n        \"fname\" => \"training_set.xyz\", # mandatory\n        \"energy_key\" => \"dft_energy\",\n        \"force_key\" => \"dft_force\",\n        \"virial_key\" => \"dft_virial\"),\n    \"basis\" => Dict(\n        \"main_ace\" => Dict(\n            \"species\" => [\"Ti\", \"Al\"],  # mandatory\n            \"N\" => 2,                   # mandatory \n            \"maxdeg\" => 10,             # mandatory \n            \"type\" => \"ace\",            # mandatory/defines this as the many-body basis & params\n            \"r0\" => 2.5,                # poly transform parameter, Å\n            \"radial\" => Dict(           # parameters for radial basis of ACE \n                \"r0\" => 2.5,            # from \"main_ace\" dictionary\n                \"rcut\" => 5.0,          # outter cutoff, Å\n                \"rin\" => 0.5 * r0,      # inner cutoff, Å\n                \"pcut\" => 2,            # outter cutoff parameter\n                \"pin\" => 2,             # inner cutoff parameter\n                \"type\" => \"radial\" ),   # mandatory/defines this as radial basis\n            \"transform\" => Dict(        # radial transform to use\n                \"type\" => \"polynomial\", # of 1/(1+r/r0)^2 - type\n                \"p\" => 2, \n                \"r0\" => 2.5),\n            \"degree\" => ...),           # way to specify the total polynomial degree\n        \"main_pair\" => Dict(\n            \"species\" => [\"Ti\", \"Al\"],  # mandatory \n            \"maxdeg\" => 4,              # mandatory \n            \"type\" => \"pair\",           # mandatory/defines this as pair basis \n            \"r0\" => 2.5,                # poly transform parameter, Å\n            \"rcut\" => 5.0,              # outer cutoff, Å\n            \"rin\" => 0.0,               # inner cutoff, Å\n            \"pcut\" => 2,                # outter cutoff parameter \n            \"pin\" => 0,                 # inner cutoff parameter\n            \"transform\" => Dict(        # radial transform to use\n                \"type\" => \"polynomial\", # of 1/(1+r/r0)^2 - type\n                \"p\" => 2, \n                \"r0\" => 2.5),),),\n    \"solver\" => Dict(\n        \"type\" => \"rrqr\",               # mandatory/defines this as rrqr solver\n        \"rrqr_tol\" => 1e-5),            # convergence tolerance parameter\n    \"e0\" => Dict(                       # mandatory\n        \"Ti\" => -1586.0195,\n        \"Al\" => -105.5954), \n    \"weights\" => Dict(                  # defines relative importance of energy vs weight vs virial observations\n        \"default\" => Dict(              \n            \"E\" => 1.0,\n            \"F\" => 1.0, \n            \"V\" => 1.0)),\n    \"P\" => nothing,                     # additional regularizer/prior\n    \"ACE_fname\" => \"ACE_fit.json\",      # filename to save ACE model to\n    \"LSQ_DB_fname_stem\" => \"\",          # do not save ACE LsqDB\n    \"fit_from_LSQ_DB\" => false          # do not refit to a present database\n    )","category":"page"},{"location":"tutorials/Solvers/#Least-squares-solvers","page":"Least squares solvers","title":"Least squares solvers","text":"","category":"section"},{"location":"tutorials/Solvers/#LSQR","page":"Least squares solvers","title":"LSQR","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The :lsqr solver solves the linear system with l^2 regularisation:","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"mathbfc = textarg min_mathbfc  mathbfy - Psi mathbfc ^2 + lambda^2  mathbfc ^2","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The solver dictionary should have the following arguments:","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :lsqr,\n        \"damp\" => 5e-3,\n        \"atol\" => 1e-6)","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"where damp is lambda in the equation above. The implementation is iterative and atol is a convergence tolerance at which to stop the alogrithm.","category":"page"},{"location":"tutorials/Solvers/#RRQR","page":"Least squares solvers","title":"RRQR","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"Rank-revealing QR factorisation determines a low rank solution to the linear system. Smaller \"gctol\" means less regularisation. ","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :rrqr,\n        \"tol\" => 1e-5)","category":"page"},{"location":"tutorials/Solvers/#Baysian-Ridge-Regression-(BRR)","page":"Least squares solvers","title":"Baysian Ridge Regression (BRR)","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The :brr - Bayesian Ridge Regression - is a wrapper for scikit learn's BayseianRidge linear model see here. A Gaussian prior on the parameter vector, and a Gaussian likelihood function are used to copmute the maximum posterior probability parameter vector. Following this, the hyperparamters of the Gaussian priors are optimised by maximising the marginal log likelihood of the obsrevations. ","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :brr, \n        \"tol\" => 1e-3)","category":"page"},{"location":"tutorials/Solvers/#Automatic-Relevance-Determination-(ARD)","page":"Least squares solvers","title":"Automatic Relevance Determination (ARD)","text":"","category":"section"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver= Dict(\n         \"solver\" => :ard,\n         \"tol\" => 1e-3,\n         \"threshold_lambda\" => 10000)","category":"page"},{"location":"tutorials/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"Automatic Relevance Determination performing evidence maximisation. tol sets the convergence for the marginal log likelihood convergence, default is1e-3. threshold_lambda is the threshold for removing the basis functions with low relevance, default is 10000.","category":"page"},{"location":"using_ace/python_ase/#Python-ASE","page":"Python ASE","title":"Python ASE","text":"","category":"section"},{"location":"outdated/data/#Handling-Data","page":"Handling Data","title":"Handling Data","text":"","category":"section"},{"location":"outdated/data/","page":"Handling Data","title":"Handling Data","text":"Atomic structures and corresponding energy, force and virial values are read from .xyz files. Filename and target property fields are specified via data_params()","category":"page"},{"location":"outdated/data/","page":"Handling Data","title":"Handling Data","text":"ACEpotentials.data_params","category":"page"},{"location":"outdated/data/#ACEpotentials.data_params","page":"Handling Data","title":"ACEpotentials.data_params","text":"data_params(; kwargs...)` : returns a dictionary containing the  complete set of parameters required to read data from an .xyz file. j  All parameters are passed as keyword arguments.\n\nParameters\n\nfname : a \"*.xyz\" file with atomistic data (mandatory).\nenergy_key = \"energy\" : key identifying energy for fitting.\nforce_key = \"forces\" : key identifying forces for fitting.\nvirial_key = \"virial\" : key identifying virial tensor for fitting.\nweight_key = \"config_type` : key identifying label for setting the correct weight from weights dictionary. \n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials-Overview","page":"Tutorials Overview","title":"Tutorials Overview","text":"","category":"section"},{"location":"tutorials/#Fitting-potentials-from-Julia-scripts","page":"Tutorials Overview","title":"Fitting potentials from Julia scripts","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"These tutorials use the direct Julia interface provided by ACEpotentials.jl (interfacing with ACE1.jl, ACE1x.jl, ACEfit.jl). They are provided in Literate.jl format and can also be run as scripts if that is preferred. ","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"First Example\nModel Interface\nBasis Interface","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"The next two tutorials show some additional techniques to better understand how to make good hyperparameter choices. ","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"Smoothness Priors : a basic introduction to smoothness priors \nDataset Analysis : some basic techniques to visualize training datasets and correlate such observations to the choice of geometric priors","category":"page"},{"location":"tutorials/#Using-ACEpotentials-Potentials-in-External-Software","page":"Tutorials Overview","title":"Using ACEpotentials Potentials in External Software","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"LAMMPS\nPython with ase\nMolly.jl","category":"page"},{"location":"tutorials/#Structure-analysis-with-ACE1-descriptors","page":"Tutorials Overview","title":"Structure analysis with ACE1 descriptors","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"ACE descriptors","category":"page"},{"location":"tutorials/#Committee-Potentials","page":"Tutorials Overview","title":"Committee Potentials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"Committee Potentials","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"<!---\n### JSON Interface and Command line (OUTDATED)\n\nACE potentials can be fitted from the command line using a dictionary stored in a `.json` or `.yaml` file to specify the parameters:\n\n* [TiAl Potential (ACEpotentials)](../literate_tutorials/ACEpotentials_TiAl.md)\n* [TiAl Potential (command line JSON)](../outdated/first_example_json.md)\n\n-->","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"EditURL = \"../tutorials/dataset_analysis.jl\"","category":"page"},{"location":"literate_tutorials/dataset_analysis/#Elementary-Dataset-Analysis","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"","category":"section"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"In this tutorial we show some basic tools in ACEpotentials to analyze a dataset and how this connects to a model construction. As usual we start by importing the relevant packages. For plotting we will use Plots.jl and LaTexStrings for nice labels.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"using ACEpotentials, Plots, LaTeXStrings","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"Let's generate a naive dataset, just some random bulk Si structures that are rattled a bit.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"rand_Si() = rattle!(bulk(:Si, cubic=true) * rand([2,3,4]), 0.25)\nSi_data = [ rand_Si() for _=1:50 ];\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"Two basic distributions we can look at to see how well the data fills in space are the radial and angular distribution functions. For the radial distribution function we use the cutoff of the model (see below). For the angular distribution we use a cutoff just above the nearest neighbour distance to we can clearly see the equilibrium bond-angles.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"r_cut = 6.0  #\nrdf = ACEpotentials.get_rdf(Si_data, r_cut; rescale = true)\n\nr_cut_adf = 1.25 * rnn(:Si)\nadf = ACEpotentials.get_adf(Si_data, 1.25 * rnn(:Si));\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"We can plot these distributions using the histogram function in Plots.jl. For the RDF we add some vertical lines to indicate the distances and first, second neighbours and so forth to confirm that the peaks are in the right place. For the ADF we add a vertical line to indicate the equilibrium bond angle.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"plt_rdf = histogram(rdf[(:Si, :Si)], bins=150, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\", yticks = [])\nvline!(rnn(:Si) * [1.0, 1.633, 1.915, 2.3, 2.5], label = \"r1, r2, ...\", lw=3)\n\neq_angle = 1.91 # radians\nplt_adf = histogram(adf, bins=25, label = \"adf\", yticks = [], c = 3,\n                  xlabel = L\"\\theta\", ylabel = \"ADF\", xlims = (0, π))\nvline!([ eq_angle,], label = \"109.5˚\", lw=3)\n\nplot(plt_rdf, plt_adf, layout = (2,1), size = (800, 400))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"One way we can use these distribution functions is to look at fitted potentials relative to where data is given. But even before a potential is fitted we can illustrate some properties of the basis functions used in ACEpotentials. E.g. we can illustrate why we have chosen the distance transforms. First, we generate a default Si model and a second one with modified transform.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"model1 = acemodel(elements = [:Si,], order = 3,\n                  totaldegree = 10, rcut = r_cut )\n\nmodel2 = acemodel(elements = [:Si,], order = 3,\n                  totaldegree = 10, rcut = r_cut,\n                  transform = (:agnesi, 2, 2) );\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"We have a utility function get_transforms that extracts the transforms from the model. We can then plot the transform gradients. In regions of r space with high gradient we have higher resolution. We see that the transforms concentrate resolution near the nearest neighbour distance and ensure there is no resolution at all near r = 0. The transform for the second model distributes resolution much more evenly across the radial domain.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"using ACE1.Transforms: transform_d\ntrans1, trans1_pair = ACEpotentials.get_transforms(model1)\ntrans2, trans2_pair = ACEpotentials.get_transforms(model2)\nt1 = trans1[(:Si, :Si)]\nt2 = trans2[(:Si, :Si)]\nrp = range(0.0, r_cut, length = 200)\n\nplt_t = plot(rp, abs.(transform_d.(Ref(t1), rp)), lw=3,\n             xlabel = L\"r [\\AA]\", label = L\"|t_1'(r)|\",\n             yticks = [], ylabel = \"\", xlims = (0, r_cut))\nplot!(plt_t, rp, abs.(transform_d.(Ref(t2), rp)), lw=3, label = L\"|t_2'(r)\")\nvline!([rnn(:Si),], lw=2, label = L\"r_{\\rm nn}\")\n\nplt_rdf = histogram(rdf[(:Si, :Si)], bins=100, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\",\n                     yticks = [], xlims = (0, r_cut))\nvline!([rnn(:Si),], label = L\"r_{\\rm nn}\", lw=3)\n\nplot(plt_t, plt_rdf, layout=grid(2, 1, heights=[0.7, 0.3]), size = (800, 400))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"To finish this tutorial, we quickly demonstrate what happens when there is more than one chemical species present in a dataset.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"tial_data, _, _ = ACEpotentials.example_dataset(\"TiAl_tutorial\")\n\nrdf = ACEpotentials.get_rdf(tial_data, r_cut)\nplt_TiTi = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 1,\n         ylabel = \"RDF - TiTi\", label = \"\", yticks = [], xlims = (0, r_cut) )\nplt_TiAl = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 2,\n         ylabel = \"RDF - TiAl\", label = \"\", yticks = [], xlims = (0, r_cut) )\nplt_AlAl = histogram(rdf[(:Al, :Al)], bins=100, xlabel = L\"r [\\AA]\", c = 3,\n         ylabel = \"RDF - AlAl\", label = \"\", yticks = [], xlims = (0, r_cut), )\nplot(plt_TiTi, plt_TiAl, plt_AlAl, layout = (3,1), size = (700, 700))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Elementary Dataset Analysis","title":"Elementary Dataset Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"outdated/solver/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"outdated/solver/","page":"Solvers","title":"Solvers","text":"LSQR, RRQR, BRR & ARD solvers that solve the Ax=b problem with some regularisation are available via ACEfit module. solver_params() is the way these are define and selected in ACEpotentials.","category":"page"},{"location":"outdated/solver/","page":"Solvers","title":"Solvers","text":"ACEpotentials.solver_params","category":"page"},{"location":"outdated/solver/#ACEpotentials.solver_params","page":"Solvers","title":"ACEpotentials.solver_params","text":"solver_params(; kwargs...) : returns a dictionary containing the complete set of parameters required to construct one of the solvers. All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\".\n\nQR Parameters\n\n'type = \"qr\"`\n\nLSQR Parameters\n\ntype = \"lsqr\"\ndamp = 5e-3\natol = 1e-6\ncolim = 1e8\nmaxiter = 1e5\nverbose = false\n\nRRQR Parameters\n\ntype = \"rrqr\"\nrtol = 1e-5\n\nSKLEARN_BRR\n\ntype = \"sklearn_brr\"\nn_iter = 300\ntol = 1e-3\n\nSKLEARN_ARD\n\ntype = \"sklearn_ard\"\nn_iter = 300\ntol = 1e-3\nthreshold_lambda = 1e4 \n\nBLR\n\ntype = \"blr\"\nverbose = false\n\n\n\n\n\n","category":"function"},{"location":"outdated/solver/","page":"Solvers","title":"Solvers","text":"Additional regularizers (currently only \"laplacian\") are given via regularizer_params()","category":"page"},{"location":"outdated/solver/","page":"Solvers","title":"Solvers","text":"ACEpotentials.regularizer_params","category":"page"},{"location":"outdated/solver/#ACEpotentials.regularizer_params","page":"Solvers","title":"ACEpotentials.regularizer_params","text":"regularizer_params(; type = \"laplacian\", kwargs...) : returns a dictionary containing the complete set of parameters required to construct one of the solvers. All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\".\n\nLSQR Parameters (default)\n\ntype = \"laplacian\"\nrlap_scal = 3.0\n\n\n\n\n\n","category":"function"},{"location":"tutorials/lammps/#ACEpotentials-potentials-in-LAMMPS","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"","category":"section"},{"location":"tutorials/lammps/#Install-LAMMPS-with-the-ML-PACE-package","page":"ACEpotentials potentials in LAMMPS","title":"Install LAMMPS with the ML-PACE package","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"An ACEpotentials.jl potential can be used in LAMMPS if the latter is built with the ML-PACE package. At present, a patched version of that package is required which may be installed as follows:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"git clone -b release https://github.com/lammps/lammps\ncd lammps\nmkdir build\ncd build\nwget -O libpace.tar.gz https://github.com/wcwitt/lammps-user-pace/archive/main.tar.gz\ncmake \\\n    -D PKG_ML-PACE=yes \\\n    -D PACELIB_MD5=$(md5sum libpace.tar.gz | awk '{print $1}') \\\n    ../cmake\nmake -j 4","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"See the LAMMPS documentation for more build options.","category":"page"},{"location":"tutorials/lammps/#Convert-an-ACEpotentials-model-to-yace-format","page":"ACEpotentials potentials in LAMMPS","title":"Convert an ACEpotentials model to yace format","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The ML-PACE package requires a potential in the .yace format. To convert a model saved as .json, use the following:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"using ACEpotentials\npotential_json = \"Si.json\"    # example json filename\npotential_yace = \"Si.yace\"    # example yace filename\nexport2lammps(potential_yace, read_dict(load_dict(potential_json)[\"IP\"]))","category":"page"},{"location":"tutorials/lammps/#Using-yace-potentials-in-LAMMPS","page":"ACEpotentials potentials in LAMMPS","title":"Using yace potentials in LAMMPS","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The syntax for the PACE pair style in LAMMPS, for a potential for I, Cs and Pb, is:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"pair_style      pace\npair_coeff      * * potential.yace I Cs Pb","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The species ordering after pair_coeff must match the numerical ordering in any .data geometry file. ","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"By default, ACEpotentials models have separate two-body and many-body components. At present, the two-body component is exported via a lookup table which LAMMPs reads directly, meaning two files are created: a potentialname_pairpot.table file for the two-body contribution and a potentialname.yace file for the many-body contribution. The .table file contains a set of lookup tables with a fixed number N (written in the file) of interpolation points. To use the full model in LAMMPS, read N from the file and use the syntax:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"pair_style      hybrid/overlay pace table spline <N>\npair_coeff      * * pace potential.yace I Cs Pb\npair_coeff      1 1 table potential_pairpot.table I_I\npair_coeff      1 2 table potential_pairpot.table I_Cs\npair_coeff      1 3 table potential_pairpot.table I_Pb\npair_coeff      2 2 table potential_pairpot.table Cs_Cs\npair_coeff      2 3 table potential_pairpot.table Cs_Pb\npair_coeff      3 3 table potential_pairpot.table Pb_Pb","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"where we are using the ordering I, Cs, Pb.","category":"page"},{"location":"gettingstarted/parallel-fitting/#Parallel-Fitting","page":"Parallel Fitting","title":"Parallel Fitting","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"ACEpotentials and ACEfit may be accelerated with one or more parallelization options.","category":"page"},{"location":"gettingstarted/parallel-fitting/#Distributed-fitting-(multiple-processes)","page":"Parallel Fitting","title":"Distributed fitting (multiple processes)","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Some routines (particularly those that assemble the linear problem) make use of Julia's multi-processing capabilities. These routines automatically utilize any available worker processes, which are initiated in one of two ways.","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"First, one may generate the workers when starting Julia. Setting JULIA_PROJECT beforehand is crucial in this case. The example starts Julia with seven additional worker processes (so, eight processes in total).","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"export JULIA_PROJECT=/path/to/project\njulia --project=path/to/project -p 7","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Alternatively, one may create workers directly within a Julia script. The exeflags argument to addprocs propagates project information, and the @everywhere macro is necessary to ensure all processes load the module. ","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"using Distributed\naddprocs(7, exeflags=\"--project=$(Base.active_project())\")\n@everywhere using ACEpotentials","category":"page"},{"location":"gettingstarted/parallel-fitting/#Parallel-BLAS-or-LAPACK","page":"Parallel Fitting","title":"Parallel BLAS or LAPACK","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Many ACEfit solvers, and possibly other routines, utilize BLAS or LAPACK. To see benefits from threading, one should set one or more of the following environment variables, depending on the particular library used.","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"export OMP_NUM_THREADS=8\nexport MKL_NUM_THREADS=8\nexport OPENBLAS_NUM_THREADS=8\nexport VECLIB_MAXIMUM_THREADS=8","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Distributed solution of the linear least squares systems is currently not supported. We would welcome collaboration on this with interested developers. ","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"EditURL = \"../tutorials/smoothness_priors.jl\"","category":"page"},{"location":"literate_tutorials/smoothness_priors/#Smoothness-Priors","page":"Smoothness Priors","title":"Smoothness Priors","text":"","category":"section"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"using ACEpotentials, LinearAlgebra, Plots, LaTeXStrings","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"ACEpotentials models make heavy use of smoothness priors, i.e., prior parameter distributions that impose smoothness on the fitted potential. This tutorial demonstrates how to use the smoothness priors implemented in ACEpotentials. We start by reading in a tiny testing dataset, and bring the data into a format that ACEfit likes. Note that using a very limited dataset makes the use of priors particularlty important. In general, the larger and more diverse the dataset, the less important the prior becomes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"rawdata, _, _ = ACEpotentials.example_dataset(\"Si_tiny\")\ndatakeys = (energy_key = \"dft_energy\", force_key = \"dft_force\", virial_key = \"dft_virial\")\n\nrcut = 6.0     # cut off distance\nr_nn = 2.3     # typical nearest neighbour distance\n\nmodel = ACE1x.acemodel(elements = [:Si],\n                       order = 3, totaldegree = 12,\n                       rcut = rcut, r0 = r_nn,\n                       Eref = Dict(\"Si\" => -158.54496821))\n\ndata = [ AtomsData(at; datakeys..., v_ref = model.Vref) for at in rawdata ]\nA, Y, W = ACEfit.assemble(data, model.basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"A positive definite matrix P specifies a normal prior distribution in the Bayesian framework, but for the purpose of this tutorial it is maybe more intuitive to simply think of it as a regularisation operator. The regularised linear least squares problem is","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"   A c - y ^2 + lambda  P c ^2","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"where A is the design matrix, y is the vector of observations, c is the vector of parameters, and lambda is a regularisation parameter. The prior matrix P is specified by the user. At present we support diagonal operators P. The diagonal elements of P are the prior variances. The larger the prior variance, the smoother the fitted potential. Although not strictly true, we can think of each basis function as specified by a the parameters (n_t l_t)_t = 1^N, where N is the correlation-order. The corresponding prior matrix element must be a function of those n_t l_t values. We currently support three classes: algebraic, exponential and gaussian.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"TODO: write down the precise definitions.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"In the following we demonstrate the usage of algebraic and gaussian priors. The choices for σl, σn made here may seem \"magical\", but there is a good justification and we plan to automate this in future releases.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Pa2 = algebraic_smoothness_prior(model.basis; p=2)\nPa4 = algebraic_smoothness_prior(model.basis; p=4)\nPg  = gaussian_smoothness_prior( model.basis, σl = (2/r_nn)^2, σn = (0.5/r_nn)^2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Each of these object Pa2, Pa4, Pg are diagonal matrices. For each prior constructed above we now solve the regularised least squares problem. Note how design matrix need only be assembled once if we want to play with many different priors. Most of the time we would just use defaults however and then these steps are all taken care of behind the scenes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"priors = Dict(\"Id\" => I, \"Algebraic(2)\" => Pa2, \"Algebraic(4)\" => Pa4,\"Gaussian\" => Pg)\nrmse = Dict()\npots = Dict()\n\nfor (prior_name, P) in priors\n    print(\"Solving with \", prior_name, \" prior ... \")\n\n    # solve the regularized least squares problem\n    Ã = Diagonal(W) * (A / P)\n    ỹ = Diagonal(W) * Y\n    c̃ = ACEfit.solve(ACEfit.BLR(; verbose=false), Ã, ỹ)[\"C\"]\n    ACE1x._set_params!(model, P \\ c̃)\n\n    # compute errors and store them for later use (don't print them here)\n    errs = ACEpotentials.linear_errors(rawdata, model; verbose=false, datakeys...)\n    rmse[prior_name] = errs[\"rmse\"][\"set\"][\"F\"]\n    pots[prior_name] = model.potential\n    println(\" force=rmse = \", rmse[prior_name])\nend","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"The force RMSE errors are comparable for the three priors, though slightly better for the weaker smoothness priors Algebraic(2) and Id. This is unsurprising, since those priors are less restrictive.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"On the other hand, we expect the stronger priors to generalize better. A typical intuition is that smooth potentials with similar accuracy will be more transferable than rougher potentials. We will show three one-dimensional slices through the fitted potentials: dimer curves, trimer curves and a decohesion curve.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"First, the dimer curves: the utility function ACEpotentials.dimers can be used to generate the data for those curves, which are then plotted using Plots.jl. We also add a vertical line to indicate the nearest neighbour distance. The standard identity prior gives a completely unrealistic dimer curve. The Algebraic(2) regularised potential is missing a repulsive core behaviour. The two remaining smoothness priors give physically sensible dimer curve shapes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"labels = sort(collect(keys(priors)))[[4,1,2,3]]\nplt_dim = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"E [eV]\",\n               xlims = (0, rcut), ylims = (-2, 5))\nfor l in labels\n    D = ACEpotentials.dimers(pots[l], [:Si,])\n    plot!(plt_dim, D[(:Si, :Si)]..., label = l, lw=2)\nend\nvline!([r_nn,], lw=2, ls=:dash, label = L\"r_{\\rm nn}\")\nplt_dim","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Next, we look at a trimer curve. This is generated using ACEpotentials.trimers. Both the Id and Algebraic(2) regularised models contain fairly significant oscillations while the Algebraic(4) and Gaussian models are much smoother. In addition, it appears that the Gaussian regularised model is somewhat more physically realistic on this slice with high energy at small bond-angles (thought the low energy at angle π seems somewhat strange).","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"plt_trim = plot(legend = :topright, xlabel = L\"\\theta\", ylabel = \"E [eV]\",\n               xlims = (0, pi), ylims = (-0.35, 0.8))\nfor l in labels\n    D = ACEpotentials.trimers(pots[l], [:Si,], r_nn,  r_nn)\n    plot!(plt_trim, D[(:Si, :Si, :Si)]..., label = l, lw=2)\nend\nvline!(plt_trim, [1.90241,], lw=2, label = \"equilibrium angle\")\nplt_trim","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Finally, we plot a decohesion curve, which contains more significant many-body effects. Arguably, none of our potentials perform very well on this test. Usually larger datasets, and longer cutoffs help in this case.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"at0 = bulk(:Si, cubic=true)\nplt_dec = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"strain [eV/Å]\",\n                xlim = (0.0, 5.0))\nfor l in labels\n    aa, E, dE = ACEpotentials.decohesion_curve(at0, pots[l])\n    plot!(plt_dec, aa, dE, label = l, lw=2)\nend\nplt_dec","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"EditURL = \"../tutorials/committee.jl\"","category":"page"},{"location":"literate_tutorials/committee/#Committee-Potentials","page":"Committee Potentials","title":"Committee Potentials","text":"","category":"section"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"using Plots, ACEpotentials, Statistics","category":"page"},{"location":"literate_tutorials/committee/#Perform-the-fit","page":"Committee Potentials","title":"Perform the fit","text":"","category":"section"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"load some example training data","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"train, _, _ = ACEpotentials.example_dataset(\"Si_tiny\")\ndata_keys = (energy_key = \"dft_energy\", force_key = \"dft_force\");\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"create model","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"model = acemodel(elements = [:Si,], order = 3, totaldegree = 8);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"create solver, setting a nonzero committee size at present, the SVD factorization is required for committees","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"solver = ACEfit.BLR(committee_size=10, factorization=:svd);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"perform the fit","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"acefit!(model, train; solver=solver, data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"Inspect the total energies vs committee energies and error bars for a few perturbed structures. Note the training set is so small that we don't expect these committees to be particularly useful; this is only to illustrate how they might be used. Also note that the energy E is not in general the mean of co_E but it is the mean of the exact posterior distribution.","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"atoms = bulk(:Si, cubic=true) * 2; rattle = [0.03, 0.1, 0.3]\nplot(; size = (300, 300), xlabel = \"rattle\", ylabel = \"energy [eV]\", ylims = (-10650, -10250),\n      xlims = (0.015, 0.6), xticks = (rattle, string.(rattle)), xscale = :log10)\nfor (i, rt) in enumerate(rattle)\n   rattle!(atoms, rt)\n   E, co_E = ACE1.co_energy(model.potential, atoms)\n   scatter!(rt*ones(10), co_E, c = 1, label=(i==1 ? \"committee\" : \"\"))\n   scatter!([rt,], [E,], yerror = [std(co_E),], c = 2, ms=6, label=(i==1 ? \"mean\" : \"\"))\nend\nplot!()","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"Committee forces are computed analogously. F is a vector of mean forces (i.e. a vector of 3-vectors), while co_F is a list of vectors of committe forces (i.e. a vector of vectors of 3-vectors).","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"F, co_F = ACE1.co_forces(model.potential, atoms)\n@show typeof(F)\n@show typeof(co_F);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"The situation is analogous for committee virials","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"V, co_V = ACE1.co_virial(model.potential, atoms)\n@show typeof(V)\n@show typeof(co_V);\nnothing #hide","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"","category":"page"},{"location":"literate_tutorials/committee/","page":"Committee Potentials","title":"Committee Potentials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"EditURL = \"../tutorials/first_example_model.jl\"","category":"page"},{"location":"literate_tutorials/first_example_model/#First-example","page":"First example","title":"First example","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"This very simple tutorial constructs an ACE1 model for Si by fitting to an empirical potential.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Make sure to first read the installation notes. Now start by importing the required packages:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"using ACEpotentials\nimport Random\nusing LinearAlgebra: norm, Diagonal","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-1:-specify-the-ACE-Model","page":"First example","title":"Step 1: specify the ACE Model","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"The parameters have the following meaning:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"elements: list of chemical species, symbols\norder : correlation order\ntotaldegree: maximum total polynomial degree used for the basis\nrcut : cutoff radius (optional, defaults are provided)","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"model = acemodel(elements = [:Si,],\n                 order = 3,\n                 totaldegree = 10,\n                 rcut = 5.0)\n@show length(model.basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-2:-Generate-a-training-set","page":"First example","title":"Step 2: Generate a training set","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Next we need to generate some training data to estimate the model parameters. Normally one would generate a training set using DFT data, stored as an .xyz file. Here, we create a random training set for simplicity. Please note that this is generally not a good strategy to generate data!","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"gen_dat() generates a single training configuration wrapped in an ACEpotentials.AtomsData structure. Each d::AtomsData contains the structure d.atoms, and energy value and a force vector to train against.\ntrain is then a collection of such random training configurations.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"data_keys = (energy_key = \"energy\", force_key = \"forces\")\n\nfunction gen_dat()\n   sw = StillingerWeber()\n   at = rattle!(bulk(:Si, cubic=true) * rand(2:3), 0.3)\n   set_data!(at, data_keys.energy_key, energy(sw,at))\n   set_data!(at, data_keys.force_key, forces(sw,at))\n   return at\nend\n\nRandom.seed!(0)\ntrain = [gen_dat() for _=1:20];\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-3:-Estimate-Parameters","page":"First example","title":"Step 3: Estimate Parameters","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"We specify a solver and then let ACEfit.jl to do all the work for us. More fine-grained control is possible; see the ACEfit.jl documentation. For sake of illustration we use a Bayesian Ridge Regression solver. This will automatically determine the regularisation for us.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"solver = ACEfit.BLR()\nacefit!(model, train; solver=solver, data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"To see the training errors we can use","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"@info(\"Training Errors\")\nACEpotentials.linear_errors(train, model; data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-4:-Run-some-tests","page":"First example","title":"Step 4: Run some tests","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"At a minimum one should have a test set, check the errors on that test set, and confirm that they are similar as the training errors.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"@info(\"Test Errors\")\ntest =  [gen_dat() for _=1:20]\nACEpotentials.linear_errors(test, model; data_keys...);\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"If we wanted to perform such a test ``manually'' it might look like this:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"@info(\"Manual RMSE Test\")\npotential = model.potential\ntest_energies = [ JuLIP.get_data(at, \"energy\") / length(at) for at in test]\nmodel_energies = [energy(potential, at) / length(at) for at in test]\nrmse_energy = norm(test_energies - model_energies) / sqrt(length(test))\n@show rmse_energy;\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"But in practice, one should run more extensive test simulations to check how robust the fitted potential is.","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-5:-export-the-model","page":"First example","title":"Step 5: export the model","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"The fitted model can be exported to a JSON or YAML file, or to a LAMMPs compatible yace file. We won't go through that in this tutoral. See export2json and export2lammps for further information.","category":"page"},{"location":"literate_tutorials/first_example_model/#Step-6:-Using-the-model","page":"First example","title":"Step 6: Using the model","text":"","category":"section"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Let's do something very simple: relax a vacancy.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"We create a small Si cell, delete an atom and rattle the rest","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"at = bulk(:Si, cubic=true) * 3\ndeleteat!(at, 1)\nrattle!(at, 0.03 * rnn(:Si))","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"we can now minimize the ACE energy.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"set_calculator!(at, potential);\nminimise!(at)\nE_ace = energy(at)","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"If we want a formation energy, we could get it like this.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"at0 = bulk(:Si)\nE0_ace = energy(potential, at0);\nEvac_ace = E_ace - (length(at)-1)/length(at0) * E0_ace\n@show Evac_ace;\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"Note that there are no vacancy structures in the training set, so this is a prediction out of sample. We have no guarantee of the accuracy of this prediction. In fact the prediction is quite far off:","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"sw = StillingerWeber()\nset_calculator!(at, sw)\nminimise!(at; verbose=false);\nE_sw = energy(at)\nE0_sw = energy(sw, bulk(:Si))\nEvac_sw = E_sw - (length(at)-1)/length(at0) * E0_sw\n@show Evac_sw;\nnothing #hide","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"To obtain accurate predictions on a vacancy structure, we must add it to the training set. This iterative model development process goes beyond the scope of this tutorial.","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"","category":"page"},{"location":"literate_tutorials/first_example_model/","page":"First example","title":"First example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"outdated/outdated/#Outdated","page":"Outdated","title":"Outdated","text":"","category":"section"},{"location":"outdated/outdated/","page":"Outdated","title":"Outdated","text":"Several guides and tutorials have become outdated, but may still be of some use. Until we find time to update them, they will appear here:","category":"page"},{"location":"outdated/outdated/","page":"Outdated","title":"Outdated","text":"ACEpotentials Overview\nBasis\nCommand Line\nCommand Line (old)\nData\nFirst Example (JSON)\nFit\nFitting\nHelpers\nSolver","category":"page"},{"location":"gettingstarted/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/installation/#Short-Version","page":"Installation","title":"Short Version","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"These short instructions are intended for users who are already familiar with Julia.  If these instructions don't make sense please see the detailed instructions below. ","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Install Julia if you haven't already. Make sure the General registry is installed and up to date. \nSetup a new project: create a folder to develop your new project, and cd into the folder. This folder will track the packages and versions which the ACEpotentials code requires. Start julia, activate the project and add ACEregistry that includes ACEpotentials, which is the package that we want to install:\nusing Pkg\nPkg.activate(\".\")\nPkg.Registry.add(\"General\")  # only needed when installing Julia for the first time\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/ACEsuit/ACEregistry\"))\nPkg.add(\"ACEpotentials\")\nACEpotentials will come with the most important packages you need, in particular ACE1.jl and ACEfit.jl.\nYou need to activate the project folder when starting julia.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"This can be done by starting julia with julia --project=pathtoproject command, using environment variable export JULIA_PROJECT=pathtoproject or by after starting julia calling","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"activate pathtoproject\"","category":"page"},{"location":"gettingstarted/installation/#Setting-up-the-Python-ASE-calculator","page":"Installation","title":"Setting up the Python ASE calculator","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"warning: Warning\nAt present, it is necessary to have ASE, JuLIP and ACE1 installed in your Julia project to use pyjulip.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"We use a wrapper called pyjulip to call julia and evaluate ACE potentials. In a terminal, with the correct julia project and python environment selected, run the following code:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"python -m pip install julia\npython -c \"import julia; julia.install()\"","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Make sure to use the correct python and pip, e.g. the ones that are in the correct Conda environment. Then, to set up pyjulip:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"git clone https://github.com/casv2/pyjulip.git\ncd pyjulip\npip install .","category":"page"},{"location":"gettingstarted/installation/#Detailed-Instructions","page":"Installation","title":"Detailed Instructions","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"If you have any difficulties with the following setup process, please file an issue. We highly recommend familiarizing oneself with the Julia package manager and how Project management is best done in Julia (there is also a summary in this section of these docs). In particular all projects should manage their own Project.toml file with appropriate version bounds, and where appropriate the Manifest.toml file can be tracked in order to guarantee reproducibility of results.","category":"page"},{"location":"gettingstarted/installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Download and unpack Julia. We require v1.9 or upwards. Add the julia executable to your path with something like export PATH=<julia-directory>/bin:$PATH.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Start the Julia REPL (type julia followed by Enter), switch to package manager by typing ], then install the General registry and the ACE registry:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"registry add https://github.com/JuliaRegistries/General\nregistry add https://github.com/ACEsuit/ACEregistry","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Press Backspace or Ctrl-c to exit the package manager. Use Ctrl-d, or exit() followed by Enter, to close the Julia REPL.","category":"page"},{"location":"gettingstarted/installation/#Setting-up-a-new-ACE1.jl-project","page":"Installation","title":"Setting up a new ACE1.jl project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Create a folder for your new project and change to it. Start the Julia REPL and activate a new project by switching to the package manager with ], and then running","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"activate .","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Now you can install ACEpotentials. Remaining in the package manager, use","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"add ACEpotentials","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Depending on your usage you may also need to add other packages. ","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"<!-- the following packages: `ACE1, JuLIP, ACEfit, ASE`. -->","category":"page"},{"location":"gettingstarted/installation/#Returning-to-a-project","page":"Installation","title":"Returning to a project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"When returning to a project, there are several methods for reactivating it. One is to simply activate . in the package manager, as above. Alternatively set the JULIA_PROJECT environment variable to the directory with Project.toml before starting julia, or call julia as julia --project=<dir>. Special syntax like JULIA_PROJECT=@. or julia --project=@. searches the current directory and its parents for a Project.toml file.","category":"page"},{"location":"gettingstarted/installation/#Trouble-shooting","page":"Installation","title":"Trouble-shooting","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"On some systems ASE.jl and ACEfit.jl is unable to automatically install python dependencies. We found that installing Anaconda and then pointing PyCall.jl to the Anaconda installation (cf PyCall Readme) resolves this. After installing Anaconda, it should then be sufficient to build ASE.jl again.\nIf you cannot use Anaconda python, or if the last point failed, then you can try to install the python dependencies manually before trying to build ASE.jl again. Specifically, it should be sufficient to just install the ase package. Please follow the installation instructions on their website.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"EditURL = \"../tutorials/descriptor.jl\"","category":"page"},{"location":"literate_tutorials/descriptor/#ACE-Descriptors","page":"ACE Descriptors","title":"ACE Descriptors","text":"","category":"section"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"This tutorial demonstrates a simple use of ACE descriptors.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"using ACEpotentials, MultivariateStats, Plots","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Load a tiny silicon dataset, which has the isolated atom, 25 diamond-like (dia) configurations, 25 beta-tin-like (bt) configurations, and 2 liquid (liq) configurations.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"dataset, _, _ = ACEpotentials.example_dataset(\"Si_tiny\");\nnothing #hide","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"An ACE basis specifies a vector of invariant features of atomic environments and can therefore be used as a general descriptor.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"basis = ACE1x.ace_basis(elements = [:Si],\n                        rcut = 5.5,\n                        order = 3,        # body-order - 1\n                        totaldegree = 8);\nnothing #hide","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Compute an averaged structural descriptor for each configuration.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"descriptors = []\nconfig_types = []\nfor atoms in dataset\n    struct_descriptor = sum(site_descriptors(basis, atoms)) / length(atoms)\n    push!(descriptors, struct_descriptor)\n    push!(config_types, atoms.data[\"config_type\"].data)\nend","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Finally, extract the descriptor principal components and plot. Note the segregation by configuration type.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"descriptors = hcat(descriptors...)\nM = fit(PCA, descriptors; maxoutdim=3, pratio=1)\ndescriptors_trans = transform(M, descriptors)\np = scatter(\n    descriptors_trans[1,:], descriptors_trans[2,:], descriptors_trans[3,:],\n    marker=:circle, linewidth=0, group=config_types, legend=:right)\nplot!(p, xlabel=\"PC1\", ylabel=\"PC2\", zlabel=\"PC3\", camera=(20,10))","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"using_ace/lammps/#LAMMPS","page":"LAMMPS","title":"LAMMPS","text":"","category":"section"},{"location":"ACEpotentials/all_exported/#ACEpotentials.jl-API","page":"ACEpotentials.jl API","title":"ACEpotentials.jl API","text":"","category":"section"},{"location":"ACEpotentials/all_exported/#Exported","page":"ACEpotentials.jl API","title":"Exported","text":"","category":"section"},{"location":"ACEpotentials/all_exported/","page":"ACEpotentials.jl API","title":"ACEpotentials.jl API","text":"Modules = [ACEpotentials]\nPrivate = false","category":"page"},{"location":"ACEpotentials/all_exported/#ACEpotentials.acefit!-Tuple{ACE1x.ACE1Model, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.acefit!","text":"function acefit!(model, data; kwargs...) :  provides a simplified interface to fitting the  parameters of a model specified via ACE1Model. The data should be  provided as a collection (AbstractVector) of JuLIP.Atoms structures. \n\nKeyword arguments:\n\nenergy_key, force_key, virial_key specify \n\nthe label of the data to which the parameters will be fitted. \n\nweights specifies the regression weights, default is 30 for energy, 1 for forces and virials\nsolver specifies the lsq solver, default is BLR (BayesianLinearRegression)\nsmoothness specifies the smoothness prior, i.e. how strongly damped   parameters corresponding to high polynomial degrees are; is 2.\nprior specifies a covariance of the prior, if nothing then a smoothness prior   is used, using the smoothness parameter \nrepulsion_restraint specifies whether to add artificial data to the training   set that effectively introduces a restraints encouraging repulsion   in the limit rij -> 0.\nrestraint_weight specifies the weight of the repulsion restraint.\nexport_lammps : path to a file to which the fitted potential will be exported   in a LAMMPS compatible format (yace)\nexport_json : path to a file to which the fitted potential will be exported   in a JSON format, which can be read from Julia or Python\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.export2json-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.export2json","text":"export2json(pathtofile, model; meta = Dict()) : exports the fitted potential to a dictionary  and then saves that to a JSON or YAML file, depending on the ending in the  filename. The dictionary will be of the form \n\nDict{String, Any}(\"potential\" => Dict( ... ), \"meta\" => Dict( ... ) )\n\nwhere potdict is the dictionary specifies the fitted potential. The meta  dictionary may contain additional information e.g. about the dataset or the  basis or the parameters. Its contents are entirely user specified. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.export2lammps-Tuple{Any, ACE1x.ACE1Model}","page":"ACEpotentials.jl API","title":"ACEpotentials.export2lammps","text":"export2lammps(pathtofile, model::ACE1Model) : exports the potential to the .yace format for use in LAMMPS.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.load_ace_potential-Tuple{AbstractString}","page":"ACEpotentials.jl API","title":"ACEpotentials.load_ace_potential","text":"function load_ace_potential(fname::AbstractString; new_format=false, verbose=true)\n\nLoad ACE potential from given file fname.\n\nKwargs\n\nnew_format=false - If true returns potential as ACEmd.ACEpotential format, else use old JuLIP format\nverbose=true     - Display version info on load\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.save_ace_potential-Tuple{Any, ACE1x.ACE1Model}","page":"ACEpotentials.jl API","title":"ACEpotentials.save_ace_potential","text":"save_ace_potential( fname, potential::ACE1x.ACE1Model; save_version_numbers=true)\n\nSave ACE potentials. Prefix is either .json, .yml or .yace, which also determines file format.\n\nKwargs\n\nsaveversionnumbers=true  : If true save version information or relevant packages\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.site_descriptor-Tuple{Any, AbstractAtoms, Integer}","page":"ACEpotentials.jl API","title":"ACEpotentials.site_descriptor","text":"site_descriptor(basis, atoms::AbstractAtoms, i::Integer)\n\nCompute the site descriptor for the ith atom in atoms.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.site_descriptors-Tuple{Any, AbstractAtoms}","page":"ACEpotentials.jl API","title":"ACEpotentials.site_descriptors","text":"site_descriptors(basis, atoms::AbstractAtoms)\n\nCompute site descriptors for all atoms in atoms, returning them as a vector of vectors.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#Not-exported","page":"ACEpotentials.jl API","title":"Not exported","text":"","category":"section"},{"location":"ACEpotentials/all_exported/","page":"ACEpotentials.jl API","title":"ACEpotentials.jl API","text":"Modules = [ACEpotentials]\nPublic = false","category":"page"},{"location":"ACEpotentials/all_exported/#ACEpotentials.IdTransform_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.IdTransform_params","text":"IdTransform_params(;) : returns Dict(\"type\" => \"identity\"), needed to construct ACE1.Transforms.IdTransform.  \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.PolyTransform_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.PolyTransform_params","text":"PolyTransform_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct ACE1.Transforms.PolyTransform. All parameters are passed as keyword argument. Also see?PolyTransform`\n\nImplements the distance transform\n\n   x(r) = Big(frac1 + r_01 + rBig)^p\n\nParameters\n\np = 2 \nr0 = 2.5\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.ace_basis_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.ace_basis_params","text":"ace_basis_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct an ACE basis (RPIBasis).  All parameters are passed as keyword argument. If no default is given then  the argument is required. \n\nParameters\n\nspecies : single species or list of species (mandatory)\nN : correlation order, positive integer (mandatory)\nmaxdeg : maximum degree, positive real number (note the precise notion of      degree is specified by further parameters) (mandatory)\nr0 = 2.5 : rough estimate for nearest neighbour distance\nradial = radial_basis_params(; r0 = r0) : one-particle basis  parameters;      cf ?radial_basis_params for details \ntransform = transform_params(; r0 = r0) : distance transform parameters;      cf ?transform_params() for details\ndegree = degree_params() : class of sparse polynomial degree to select      the basis; see ?degree_params for details \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.at_dimer-Tuple{Any, Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.at_dimer","text":"function at_dimer(r, z1, z0) : generates a dimer with separation r and  atomic numbers z1 and z0.  (can also use symbols or strings)\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.at_trimer-NTuple{6, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.at_trimer","text":"function at_trimer(r1, r2, θ, z0, z1, z2) : generates a trimer with separations r1 and r2, angle θ and atomic numbers z0, z1 and z2  (can also use symbols or strings),  where z0 is the species of the central  atom, z1 at distance r1 and z2 at distance r2.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.atom_energy-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.atom_energy","text":"function atom_energy(IP, z0) : energy of an isolated atom\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.basis_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.basis_params","text":"basis_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct one of the basis.  All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\". \n\nACE (RPI) basis\n\nReturns a dictionary containing the complete set of parameters  required to construct an ACE basis (RPIBasis). All parameters  are passed as keyword argument. If no default is given then  the argument is required. \n\nParameters\n\ntype = \"ace\" \nspecies : single species or list of species (mandatory)\nN : correlation order, positive integer (mandatory)\nmaxdeg : maximum degree, positive real number (note the precise \n\nnotion of degree is specified by further parameters) (mandatory)\n\nr0 = 2.5 : rough estimate for nearest neighbour distance\nradial = radial_basis_params(; r0 = r0) : one-particle basis \n\nparameters; cf ?basis_params of type \"radial\" for details \n\ntransform = transform_params(; r0 = r0) : distance transform \n\nparameters; cf ?transform_params() for details\n\ndegree = degree_params() : class of sparse polynomial degree \n\nto select the basis; see ?degree_params for details \n\nPair basis\n\nReturns a dictionary containing the complete set of parameters  required to construct an pair basis (PolyPairBasis). All  parameters are passed as keyword argument. \n\nParameters\n\ntype = \"pair\"\nspecies : single species or list of species (mandatory)\nmaxdeg : maximum degree, positive real number (note the precise \n\nnotion of degree is specified by further parameters) (mandatory)\n\nr0 = 2.5 : rough estimate for nearest neighbour distance\nrcut = 5.0: outer cutoff, Å \nrin = 0.0: inner cutoff, Å \npcut = 2: outer cutoff parameter;      * pcut=2: function and first derivative go to zero at  the outer cutoff      * pcut=1: function forced to go through zero at the outer cutoff      * pcut=0: no constraint at the outer cutoff\npin = 0: inner cutoff parameter     * pin=2: function and first derivative go to zero at  the inner cutoff     * pin=1: function forced to go through zero at the inner cutoff     * pin=0: no constraint at the inner cutoff\ntransform = transform_params(; r0 = r0) : distance transform \n\nparameters; cf ?transform_params() for details\n\nRadial basis of ACE\n\nReturns a dictionary containing the complete set of parameters  required to construct radial basis for ACE. All parameters are  passed as keyword argument. \n\nParameters\n\ntype = \"radial\"\nr0 = 2.5 : rough estimate for nearest neighbour distance\nrcut = 5.0: outer cutoff, Å \nrin = 0.5 * r0: inner cutoff, Å \npcut = 2: outer cutoff parameter;      * pcut=2: function and first derivative go to zero at  the outer cutoff      * pcut=1: function forced to go through zero at the outer cutoff      * pcut=0: no constraint at the outer cutoff\npin = 2: inner cutoff parameter     * pin=2: function and first derivative go to zero at  the inner cutoff     * pin=1: function forced to go through zero at the inner cutoff     * pin=0: no constraint at the inner cutoff\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.blr_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.blr_params","text":"blr_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a Bayesian  linear regression solver. All parameters are passed as  keyword argument. \n\nParameters\n\nverbose = false\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.data_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.data_params","text":"data_params(; kwargs...)` : returns a dictionary containing the  complete set of parameters required to read data from an .xyz file. j  All parameters are passed as keyword arguments.\n\nParameters\n\nfname : a \"*.xyz\" file with atomistic data (mandatory).\nenergy_key = \"energy\" : key identifying energy for fitting.\nforce_key = \"forces\" : key identifying forces for fitting.\nvirial_key = \"virial\" : key identifying virial tensor for fitting.\nweight_key = \"config_type` : key identifying label for setting the correct weight from weights dictionary. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.db_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.db_params","text":"db_params(; kwargs...)` : returns a dictionary containing all of the parameters needed for making a LsqDB. All parameters are passed  as keyword argumts. \n\nParameters\n\ndata : data parameters, see ?data_params for details (mandatory)\nbasis : dictionary containing dictionaries that specify the basis used in fitting.     For example \njulia   basis = Dict(       \"pair_short\" => Dict( \"type\" => \"pair\", ...),        \"pair_long\" => Dict(\"type\" => \"pair\", ...),        \"manybody\" => Dict(\"type\" => \"ace\", ...),        \"nospecies\" => Dict(\"type\" => \"ace\", species = [\"X\",], ...)\n\nkeys of basis are ignored, so that multiple basis with different specifications  (e.g. smaller and larger cutoffs) can be combined. See ?basis_params for more detail.  \n\nLSQ_DB_fname_stem = \"\" : stem to save LsqDB to. Doesn't get saved if set to an empty    string (\"\"). If LSQ_DB_fname_stem * \"_kron.h5\" file is not present it gets renamed,    a new LsqDB is constructed and saved.  \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.decohesion_curve-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.decohesion_curve","text":"Generate a decohesion curve for testing the smoothness of a potential.  Arguments:\n\nat0 : unit cell \npot : potential implementing energy\n\nKeyword Arguments: \n\ndim = 1 : dimension into which to expand\nmult = 10 : multiplicative factor for expanding the cell in dim direction\naa = :auto : array of stretch values of the lattice parameter to use\nnpoints = 100 : number of points to use in the stretch array (for auto aa)\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.degree_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.degree_params","text":"degree_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a specification for polynomial degree. All parameters are passed as keyword argument  and the kind of parameters required depend on \"type\". \n\nSparsePSHDegree\n\nReturns a dictionary containing the complete set of parameters required  to construct ACE1.RPI.SparsePSHDegree. See ?SparsePSHDegree.\n\nParameters\n\ntype = \"sparse\"\nwL = 1.5\ncsp = 1.0 \nchc = 0.0\nchc = 0.0\nahc = 0.0\nbhc = 0.0\np = 1.0\n\n##SparsePSHDegreeM Returns a dictionary containing the complete set of parameters required  to construct ACE1.RPI.SparsePSHDegree. Also see ?SparsePSHDegreeM. \n\nNB maxdeg of ACE basis (RPIBasis) has to be set to 1.0.\n\nParameters\n\nDd : Dictionary specifying max degrees (mandatory)\nDn = Dict(\"default\" => 1.0) : Dictionary specifying weights for degree \n\nof radial basis functions (n)\n\nDl = Dict(\"default\" => 1.5) : Dictionary specifying weights for degree \n\nof angular basis functions (l)\n\nEach dictionary should have a \"default\" entry. In addition, different degrees  or weights can be specified for each correlation order and/or correlation  order-species combination. For example \n\n\"Dd\" => Dict(\n      \"default\" => 10,\n      3 => 9,\n      (4, \"C\") => 8,\n      (4, \"H\") => 0)\n\nin combination with N=4 and maxdeg=1.0, will set maximum polyonmial degree on  N=1 and N=2 functions to 10, to 9 for N=3 functions and will only allow  N=4 basis functions on carbon atoms, up to polynomial degree 8. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.dimer_energy-NTuple{4, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.dimer_energy","text":"function dimer_energy(pot, r, z1, z0) : energy of a dimer  with separation r and atomic numbers z1 and z0 using the potential pot;  subtracting the 1-body contributions. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.dimers-Tuple{Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.dimers","text":"dimers(potential, elements; kwargs...) :  Generate a dictionary of dimer curves for a given potential. \n\npotential : potential to use to evaluate energy\nelements : list of chemical species, symbols for which the dimers are to be computed\n\nThe function returns a dictionary Ddim such that D[(s1, s2)] contains pairs or arrays (rr, E) which can be plotted plot(rr, E). \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.fill_defaults-Tuple{Dict}","page":"ACEpotentials.jl API","title":"ACEpotentials.fill_defaults","text":"fill_defaults(params::Dict; param_key = \"fit_params\") -> params\n\nRecursively updates any missing entries with default parameters. Accepted param_key values and corresponding functions: \n\n    \"fit_params\" => ACEpotentials.fit_params,\n    \"data\" => ACEpotentials.data_params,\n    \"solver\" => ACEpotentials.solver_params,\n    \"basis\" => ACEpotentials.basis_params,\n    \"ace\" => ACEpotentials.ace_basis_params,  \n    \"pair\" => ACEpotentials.pair_basis_params,\n    \"radial\" => ACEpotentials.radial_basis_params,\n    \"transform\" => ACEpotentials.transform_params, \n    \"degree\" => ACEpotentials.degree_params,\n    \"P\" => ACEpotentials.regularizer_params\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.fit_ace-Tuple{Dict}","page":"ACEpotentials.jl API","title":"ACEpotentials.fit_ace","text":"fit_ace(params::Dict) -> IP, lsqinfo \n\nFunction to set up and fit the least-squares  problem of \"atoms' positions\" -> \"energy, forces, virials\". Takes in a  dictionary with all the parameters. See ?fit_params for details. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.fit_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.fit_params","text":"fit_params(; kwargs...) \n\nReturns a dictionary containing all of the parameters needed to make an ACE potential. All parameters are passed  as keyword argumts. \n\nParameters\n\ndata : data parameters, see ?data_params for details (mandatory)\nbasis : dictionary containing dictionaries that specify the basis used in fitting.     For example \n\nbasis = Dict(\n    \"pair_short\" => Dict( \"type\" => \"pair\", ...), \n    \"pair_long\" => Dict(\"type\" => \"pair\", ...), \n    \"manybody\" => Dict(\"type\" => \"ace\", ...), \n    \"nospecies\" => Dict(\"type\" => \"ace\", species = [\"X\",], ...)\n\nkeys of basis are ignored, so that multiple basis with different specifications  (e.g. smaller and larger cutoffs) can be combined. See ?basis_params for more detail.  \n\nsolver : dictionary containing parameters that specify the solver for    least squares problem (mandatory). See ?solver_params.\ne0 : Dict{String, Float} containing reference values for isolated atoms'   energies (mandatory). \nweights : dictionary of Dict(\"config_type\" => Dict(\"E\" => Float, \"F => Float))entries specifying fitting weights. \"default\" is set to1.0` for all of \"E\", \"F\",   and \"V\" weights. \nP : regularizer parameters (optional), see ?regularizer_params.\nACE_fname = \"ACE_fit.json\" : filename to save ACE to. Potential & info   do not get saved if ACE_fname isnothing() or is set to \"\". Files already parseentry   are renamed and not overwritten. \nLSQ_DB_fname_stem = \"\" : stem to save LsqDB to. Doesn't get saved if set to an empty    string (\"\"). If the file is already present, but fit_from_LSQ_DB is set to false,   the old database is renamed, a new one constructed and saved under the given name. \nfit_from_LSQ_DB = false: whether to fit from a least squares database specified with   LSQ_DB_fname_stem. If LSQ_DB_fname_stem * \"_kron.h5\" file is not present, LsqDB is    constructed from scratch and saved.  \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.generate_ace_basis-Tuple{Dict}","page":"ACEpotentials.jl API","title":"ACEpotentials.generate_ace_basis","text":"Returns ACE1.Utils.rpi_basis \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.generate_pair_basis-Tuple{Dict}","page":"ACEpotentials.jl API","title":"ACEpotentials.generate_pair_basis","text":"Returns PolyPairBasis \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.get_adf-Tuple{AbstractVector{<:Atoms}, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.get_adf","text":"function get_adf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) :\n\nAngular distribution, i.e. list of angles in [0, π] between all pairs of bonds  of length at most r_cut. Keyword arguments:\n\nskip = 3 : only consider every skipth atom in the dataset.\nmaxsamples = 100_000 : maximum number of samples to return.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.get_rdf-Tuple{AbstractVector{<:Atoms}, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.get_rdf","text":"function get_rdf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) : \n\nProduce a list of r values that occur in the dataset, restricted to the cutoff  radius r_cut. Keyword arguments: \n\nrescale = true : resample the data to account for volume scaling, i.e. a distance r will be kept with probability min(1, (r0/r)^2).\nr0 = :min : parameter for resampling. If :min then the minimum r occuring in the dataset is taken. \nmaxsamples = 100_000 : maximum number of samples to return. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.laplacian_regularizer_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.laplacian_regularizer_params","text":"laplacian_regularizer_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a laplacian regularizer.  All parameters are passed as keyword argument. \n\nParameters\n\nrlap_scal = 3.0\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.lsqr_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.lsqr_params","text":"lsqr_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a lsqr solver.  All parameters are passed as keyword argument. \n\nParameters\n\ndamp = 5e-3\natol = 1e-6\ncolim = 1e8\nmaxiter = 1e5\nverbose = false\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.make_ace_db-Tuple{Dict}","page":"ACEpotentials.jl API","title":"ACEpotentials.make_ace_db","text":"make_ace_db(params::Dict) -> LsqDB\n\nMakes a LsqDB from given parameters' dictionary. For params see  ?db_params; parameters from fit_params also work, except  unnecessary entries will be ignored. Returns IPFitting.LsqDB\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.multitransform_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.multitransform_params","text":"multitransform_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct ACE.Transform.multitransform. All parameters are passed as keyword argument. \n\nParameters\n\ntransforms : dictionary specifying transforms for each species pair. Can be\n\ngiven per-pair (i.e. only for (\"element1\", \"element2\") and not for  (\"element2\", \"element1\")) or can be different for (\"element1\", \"element2\") and  (\"element2\", \"element1\"). For example\n\ntransforms = Dict(\n      (\"C\", \"C\") => Dict(\"type\"=> \"polynomial\"),\n      (\"C\", \"H\") => Dict(\"type\"=> \"polynomial\"),\n      (\"H\", \"H\") => Dict(\"type\" => \"polynomial\"))\n\nrin, rcut: values for inner and outer cutoffs, alternative to cutoffs\ncutoffs : dictionary specifying inner and outer cutoffs for each element pair\n\n(either symmetrically or non-symmetrically). Alternative to rin & rcut.  For example\n\ncutoffs => Dict(\n      (\"C\", \"C\") => (1.1, 4.5),\n      (\"C\", \"H\") => (0.9, 4.5),\n      (\"H\", \"H\") => (1.23, 4.5)),\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.pair_basis_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.pair_basis_params","text":"pair_basis_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct an pair basis (PolyPairBasis).  All parameters are passed as keyword argument. \n\nParameters\n\nspecies : single species or list of species (mandatory)\nmaxdeg : maximum degree, positive real number (note the precise notion of degree \n\nis specified by further parameters) (mandatory)\n\nr0 = 2.5 : rough estimate for nearest neighbour distance\nrcut = 5.0: outer cutoff, Å \nrin = 0.0: inner cutoff, Å \npcut = 2: outer cutoff parameter;      * pcut=2: function and first derivative go to zero at  the outer cutoff      * pcut=1: function forced to go through zero at the outer cutoff      * pcut=0: no constraint at the outer cutoff\npin = 0: inner cutoff parameter     * pin=2: function and first derivative go to zero at  the inner cutoff     * pin=1: function forced to go through zero at the inner cutoff     * pin=0: no constraint at the inner cutoff\ntransform = transform_params(; r0 = r0) : distance transform parameters; \n\ncf ?transform_params() for details\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.parse_ace_basis_keys-Tuple{Dict}","page":"ACEpotentials.jl API","title":"ACEpotentials.parse_ace_basis_keys","text":"parse_ace_basis_keys(ace_basis::Dict) -> ace_basis\n\n(\"C\", \"C\")-type tuples are saved to and read back in from JSON as \"(\"C\", \"C\")\" .json.  It's slightly easier to save these to JSON or YAM as \"(C, C)\".  This function converts \"(C, C)\"-type strings back to parameter-friendly (\"C\", \"C\"). \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.qr_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.qr_params","text":"qr_params(; kwargs...) : returns a dictionary containing the complete set of parameters required to construct a qr solver. All parameters are passed as keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.radial_basis_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.radial_basis_params","text":"radial_basis_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct radial basis for ACE.  All parameters are passed as keyword argument. \n\nParameters\n\nr0 = 2.5 : rough estimate for nearest neighbour distance\nrcut = 5.0: outer cutoff, Å \nrin = 0.5 * r0: inner cutoff, Å \npcut = 2: outer cutoff parameter;      * pcut=2: function and first derivative go to zero at  the outer cutoff      * pcut=1: function forced to go through zero at the outer cutoff      * pcut=0: no constraint at the outer cutoff\npin = 2: inner cutoff parameter     * pin=2: function and first derivative go to zero at  the inner cutoff     * pin=1: function forced to go through zero at the inner cutoff     * pin=0: no constraint at the inner cutoff\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.regularizer_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.regularizer_params","text":"regularizer_params(; type = \"laplacian\", kwargs...) : returns a dictionary containing the complete set of parameters required to construct one of the solvers. All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\".\n\nLSQR Parameters (default)\n\ntype = \"laplacian\"\nrlap_scal = 3.0\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.rrqr_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.rrqr_params","text":"rrqr_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a rrqr solver.  All parameters are passed as keyword argument. \n\nParameters\n\nrtol = 1e-5\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.save_fit-Tuple{Any, Any, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.save_fit","text":"save_fit(fname, IP, lsqinfo) \n\nSaves Dict(\"IP\" => IP, \"info\" => lsqinfo) to fname. If fname is already present, it is renamed and dictionary saved to fname. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.sklearn_ard_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.sklearn_ard_params","text":"sklearn_ard_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a scikit-learn  Automatic Relevance Detemrination solver. All parameters are  passed as keyword argument. \n\nParameters\n\nn_iter = 300\ntol = 1e-3\nthreshold_lambda = 1e4\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.sklearn_brr_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.sklearn_brr_params","text":"sklearn_brr_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a scikit-learn  Bayesian ridge regression solver. All parameters are passed as  keyword argument. \n\nParameters\n\nn_iter = 300\ntol = 1e-3\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.solver_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.solver_params","text":"solver_params(; kwargs...) : returns a dictionary containing the complete set of parameters required to construct one of the solvers. All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\".\n\nQR Parameters\n\n'type = \"qr\"`\n\nLSQR Parameters\n\ntype = \"lsqr\"\ndamp = 5e-3\natol = 1e-6\ncolim = 1e8\nmaxiter = 1e5\nverbose = false\n\nRRQR Parameters\n\ntype = \"rrqr\"\nrtol = 1e-5\n\nSKLEARN_BRR\n\ntype = \"sklearn_brr\"\nn_iter = 300\ntol = 1e-3\n\nSKLEARN_ARD\n\ntype = \"sklearn_ard\"\nn_iter = 300\ntol = 1e-3\nthreshold_lambda = 1e4 \n\nBLR\n\ntype = \"blr\"\nverbose = false\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.sparse_degree_M_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.sparse_degree_M_params","text":"sparse_degree_M_params(;kwargs...): Returns a dictionary containing the  complete set of parameters required to construct ACE1.RPI.SparsePSHDegree.  Also see ?SparsePSHDegreeM. \n\nNB maxdeg of ACE basis (RPIBasis) has to be set to 1.0.\n\nParameters\n\nDd : Dictionary specifying max degrees (mandatory)\nDn = Dict(\"default\" => 1.0) : Dictionary specifying weights for degree \n\nof radial basis functions (n)\n\nDl = Dict(\"default\" => 1.5) : Dictionary specifying weights for degree \n\nof angular basis functions (l)\n\nEach dictionary should have a \"default\" entry. In addition, different degrees  or weights can be specified for each correlation order and/or correlation  order-species combination. For example \n\n\"Dd\" => Dict(\n      \"default\" => 10,\n      3 => 9,\n      (4, \"C\") => 8,\n      (4, \"H\") => 0)\n\nin combination with N=4 and maxdeg=1.0, will set maximum polyonmial degree on  N=1 and N=2 functions to 10, to 9 for N=3 functions and will only allow  N=4 basis functions on carbon atoms, up to polynomial degree 8. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.sparse_degree_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.sparse_degree_params","text":"sparse_degree_params(; kwargs...): returns a dictionary containing the  complete set of parameters required to construct ACE1.RPI.SparsePSHDegree. See ?SparsePSHDegree.\n\nParameters\n\nwL = 1.5\ncsp = 1.0 \nchc = 0.0\nchc = 0.0\nahc = 0.0\nbhc = 0.0\np = 1.0\n\nNB p = 1 is current ignored, but we put it in so we can experiment later  with p = 2, p = inf. \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.transform_params-Tuple{}","page":"ACEpotentials.jl API","title":"ACEpotentials.transform_params","text":"transform_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct one of the transforms.  All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\".\n\nPolynomial transform\n\nReturns a dictionary containing the complete set of parameters required  to construct ACE1.Transforms.PolyTransform. All parameters are passed  as keyword argument. Also see?PolyTransform`\n\nImplements the distance transform\n\n   x(r) = Big(frac1 + r_01 + rBig)^p\n\nParameters\n\ntype = \"polynomial\"\np = 2 \nr0 = 2.5\n\nMultitransform\n\nReturns a dictionary containing the complete set of parameters required  to construct ACE.Transform.multitransform. All parameters are passed  as keyword argument. \n\nParameters\n\ntransforms : dictionary specifying transforms for each species pair. Can be\n\ngiven per-pair (i.e. only for (\"element1\", \"element2\") and not for  (\"element2\", \"element1\")) or can be different for (\"element1\", \"element2\") and  (\"element2\", \"element1\"). For example\n\ntransforms = Dict(\n      (\"C\", \"C\") => Dict(\"type\"=> \"polynomial\"),\n      (\"C\", \"H\") => Dict(\"type\"=> \"polynomial\"),\n      (\"H\", \"H\") => Dict(\"type\" => \"polynomial\"))\n\nrin, rcut: values for inner and outer cutoffs, alternative to cutoffs\ncutoffs : dictionary specifying inner and outer cutoffs for each element pair\n\n(either symmetrically or non-symmetrically). Alternative to rin & rcut.  For example\n\ncutoffs => Dict(\n      (\"C\", \"C\") => (1.1, 4.5),\n      (\"C\", \"H\") => (0.9, 4.5),\n      (\"H\", \"H\") => (1.23, 4.5)),\n\nidentity\n\nIdTransform_params(;) : returns Dict(\"type\" => \"identity\"), needed to construct ACE1.Transforms.IdTransform.  \n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.trimer_energy-NTuple{7, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.trimer_energy","text":"function trimer_energy(IP, r1, r2, θ, z0, z1, z2) : computes the energy of a trimer, subtracting the 2-body and 1-body contributions.\n\n\n\n\n\n","category":"method"},{"location":"ACEpotentials/all_exported/#ACEpotentials.trimers-NTuple{4, Any}","page":"ACEpotentials.jl API","title":"ACEpotentials.trimers","text":"trimers(potential, elements, r1, r2; kwargs...) :  Generate a dictionary of trimer curves for a given potential. \n\npotential : potential to use to evaluate energy \nelements : list of chemical species, symbols for which the trimers are to be computed\nr1, r2 : distance between the central atom and the first, second neighbour\n\nThe function returns a dictionary Dtri such that D[(s1, s2, s3)] contains  pairs or arrays (θ, E) which can be plotted plot(θ, E). \n\n\n\n\n\n","category":"method"},{"location":"outdated/Fitting/#ACE1-and-ACEfit","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"ACE1.jl defines functions from the space of local atomic environments mathcalX to the space of real numbers mathbbR. These functions respect physical symmetries such as invariance under rotation of the environment and permutation of equivalent atoms. This set of functions B_nu _nu may be treated as a basis of a space of such symmetric functions, allowing us to express a property of an atomic environment R in mathcalX as follows:","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"y(R) = sum_nu c_nu B_nu(R)","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"Having explicitly constructed such a basis set, the coefficients c_nu can be found by fitting the model to data  (R_i y_i) _i and solving by, for instance, least squares:","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"mathbfc = textarg min_mathbfc sum_i left( y_i - sum_nu c_nu B_nu(R_i) right)^2 + textREG","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"ACE1.jl describes the symmetric basis set; ACEpotentials.jl and ACEfit.jl handle the assembly and solution of the resulting least squares system, and provides a variety of methods for doing so including different regularization methods. ACEfit.jl also defines a generic Data type and ACEpotentials.jl implements a version of this type which represents a labelled atomic configuration.","category":"page"},{"location":"outdated/Fitting/#The-Least-Squares-Database","page":"ACE1 and ACEfit","title":"The Least Squares Database","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"The minimisation problem above can be written:","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"mathbfc = textarg min_mathbfc  mathbfy - Psi mathbfc ^2","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"where y_i are the observations of the true function, and Psi_i nu = B_nu(R_i) is the design matrix. ACEpotentials and ACEfit construct the design matrix and the observation vector (from the basis and training configurations) and stores them in a database: [source]","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"dB = LsqDB(save_name, basis, train)","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"If save_name is the empty string, the least squares system, which can be very large, is not saved to disk. Otherwise, save_name should be a string not including any file extension, which is added by... basis is the ACE1 basis. train is a Vector of ACEpotentials AtomsData objects representing the training set. ","category":"page"},{"location":"outdated/Fitting/#Structure-of-the-Linear-System.","page":"ACE1 and ACEfit","title":"Structure of the Linear System.","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"Observations of the energy, forces and virial stresses of an atomic configuration can be used to train a model. Each scalar observable contributes one row to the linear system: An energy observation therefore contributes a single row, and the forces on all the of the N atoms in a configuration contribute 3N rows. Training configurations can also be distinguised from one another by setting the configtype field in the ACEpotentials AtomsData object. The least squares database recognises the config type of a configuration, which can be used to apply different settings for different config types when fitting.","category":"page"},{"location":"outdated/Fitting/#Solving-the-Linear-System","page":"ACE1 and ACEfit","title":"Solving the Linear System","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"Fitting is performed by calling lsqfit.","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"IP, lsqinfo = lsqfit(dB, solver=solver, weights=weights, Vref=Vref, error_table=true)","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"arguments (see below for details):","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"dB : IPFitting.lsqDB. The least sqaures system to be solved.\nsolver : Dict(). Specifies the solution method.\nweights : Dict(). The weights of the different observations (rows) of the least squares system.\nVref : Dict(). A reference potential.\nerror_table : bool If true a table containing fitting errors is printed and stored in lsqinfo. ","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"returns:","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"IP : The interatomic potential that can be evaluated on a new configuration.\nlsqinfo : A dictionary of information about the least sqaures system and the solution process.","category":"page"},{"location":"outdated/Fitting/#Solvers","page":"ACE1 and ACEfit","title":"Solvers","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"Once the linear system has been formed, several methods exist for solving it. Some involve modifying the above minimisation statement but still require the design matrix and observation vector. Currently there are 4 solvers implemented in IPFitting which are discussed in solvers.","category":"page"},{"location":"outdated/Fitting/#Weights","page":"ACE1 and ACEfit","title":"Weights","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"The weights dictionary can be used to rescale rows of the linear equation to emphasise some observations more than others. For instance, it may be useful to weight the rows of the linear system corresponding to the energy larger than those corresponding to forces, if there are many more force observations than energy observations. Different weight can also be set for different config types. An example for a database containing training data with config types MD and Phonon, might be:","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"weights = Dict(\n        \"MD\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"Phonon\" => Dict(\"E\" => 10.0, \"F\" => 10.0 , \"V\" => 10.0 ))","category":"page"},{"location":"outdated/Fitting/#Reference-potential","page":"ACE1 and ACEfit","title":"Reference potential","text":"","category":"section"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"It is also possible to suply a reference potential V, which acts as a baseline for the prediction. If a reference potential is supplied, the prediction is modelled as","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"y(R) = V(R) + sum_nu c_nu B_nu(R)","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"To implement this, the least squares database subtracts the reference from the observations before forming the linear system. The energy of the uninteracting isolated atoms (a OneBody potential) is good reference potential:","category":"page"},{"location":"outdated/Fitting/","page":"ACE1 and ACEfit","title":"ACE1 and ACEfit","text":"Vref = OneBody(:Ti => -1586.0195, :Al => -105.5954)","category":"page"},{"location":"outdated/basis/#Constructing-Basis","page":"Constructing Basis","title":"Constructing Basis","text":"","category":"section"},{"location":"outdated/basis/","page":"Constructing Basis","title":"Constructing Basis","text":"The top-level function specifying the parameters needed to construct ACE & pair basis is basis_params(). Depending on the basis type, some of the parameters need to be specified by other *params() functions. Namely, radial basis, transform and degree have several different options. ","category":"page"},{"location":"outdated/basis/","page":"Constructing Basis","title":"Constructing Basis","text":"ACEpotentials.basis_params\nACEpotentials.degree_params\nACEpotentials.transform_params","category":"page"},{"location":"outdated/basis/#ACEpotentials.basis_params","page":"Constructing Basis","title":"ACEpotentials.basis_params","text":"basis_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct one of the basis.  All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\". \n\nACE (RPI) basis\n\nReturns a dictionary containing the complete set of parameters  required to construct an ACE basis (RPIBasis). All parameters  are passed as keyword argument. If no default is given then  the argument is required. \n\nParameters\n\ntype = \"ace\" \nspecies : single species or list of species (mandatory)\nN : correlation order, positive integer (mandatory)\nmaxdeg : maximum degree, positive real number (note the precise \n\nnotion of degree is specified by further parameters) (mandatory)\n\nr0 = 2.5 : rough estimate for nearest neighbour distance\nradial = radial_basis_params(; r0 = r0) : one-particle basis \n\nparameters; cf ?basis_params of type \"radial\" for details \n\ntransform = transform_params(; r0 = r0) : distance transform \n\nparameters; cf ?transform_params() for details\n\ndegree = degree_params() : class of sparse polynomial degree \n\nto select the basis; see ?degree_params for details \n\nPair basis\n\nReturns a dictionary containing the complete set of parameters  required to construct an pair basis (PolyPairBasis). All  parameters are passed as keyword argument. \n\nParameters\n\ntype = \"pair\"\nspecies : single species or list of species (mandatory)\nmaxdeg : maximum degree, positive real number (note the precise \n\nnotion of degree is specified by further parameters) (mandatory)\n\nr0 = 2.5 : rough estimate for nearest neighbour distance\nrcut = 5.0: outer cutoff, Å \nrin = 0.0: inner cutoff, Å \npcut = 2: outer cutoff parameter;      * pcut=2: function and first derivative go to zero at  the outer cutoff      * pcut=1: function forced to go through zero at the outer cutoff      * pcut=0: no constraint at the outer cutoff\npin = 0: inner cutoff parameter     * pin=2: function and first derivative go to zero at  the inner cutoff     * pin=1: function forced to go through zero at the inner cutoff     * pin=0: no constraint at the inner cutoff\ntransform = transform_params(; r0 = r0) : distance transform \n\nparameters; cf ?transform_params() for details\n\nRadial basis of ACE\n\nReturns a dictionary containing the complete set of parameters  required to construct radial basis for ACE. All parameters are  passed as keyword argument. \n\nParameters\n\ntype = \"radial\"\nr0 = 2.5 : rough estimate for nearest neighbour distance\nrcut = 5.0: outer cutoff, Å \nrin = 0.5 * r0: inner cutoff, Å \npcut = 2: outer cutoff parameter;      * pcut=2: function and first derivative go to zero at  the outer cutoff      * pcut=1: function forced to go through zero at the outer cutoff      * pcut=0: no constraint at the outer cutoff\npin = 2: inner cutoff parameter     * pin=2: function and first derivative go to zero at  the inner cutoff     * pin=1: function forced to go through zero at the inner cutoff     * pin=0: no constraint at the inner cutoff\n\n\n\n\n\n","category":"function"},{"location":"outdated/basis/#ACEpotentials.degree_params","page":"Constructing Basis","title":"ACEpotentials.degree_params","text":"degree_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct a specification for polynomial degree. All parameters are passed as keyword argument  and the kind of parameters required depend on \"type\". \n\nSparsePSHDegree\n\nReturns a dictionary containing the complete set of parameters required  to construct ACE1.RPI.SparsePSHDegree. See ?SparsePSHDegree.\n\nParameters\n\ntype = \"sparse\"\nwL = 1.5\ncsp = 1.0 \nchc = 0.0\nchc = 0.0\nahc = 0.0\nbhc = 0.0\np = 1.0\n\n##SparsePSHDegreeM Returns a dictionary containing the complete set of parameters required  to construct ACE1.RPI.SparsePSHDegree. Also see ?SparsePSHDegreeM. \n\nNB maxdeg of ACE basis (RPIBasis) has to be set to 1.0.\n\nParameters\n\nDd : Dictionary specifying max degrees (mandatory)\nDn = Dict(\"default\" => 1.0) : Dictionary specifying weights for degree \n\nof radial basis functions (n)\n\nDl = Dict(\"default\" => 1.5) : Dictionary specifying weights for degree \n\nof angular basis functions (l)\n\nEach dictionary should have a \"default\" entry. In addition, different degrees  or weights can be specified for each correlation order and/or correlation  order-species combination. For example \n\n\"Dd\" => Dict(\n      \"default\" => 10,\n      3 => 9,\n      (4, \"C\") => 8,\n      (4, \"H\") => 0)\n\nin combination with N=4 and maxdeg=1.0, will set maximum polyonmial degree on  N=1 and N=2 functions to 10, to 9 for N=3 functions and will only allow  N=4 basis functions on carbon atoms, up to polynomial degree 8. \n\n\n\n\n\n","category":"function"},{"location":"outdated/basis/#ACEpotentials.transform_params","page":"Constructing Basis","title":"ACEpotentials.transform_params","text":"transform_params(; kwargs...) : returns a dictionary containing the  complete set of parameters required to construct one of the transforms.  All parameters are passed as keyword argument and the kind of  parameters required depend on \"type\".\n\nPolynomial transform\n\nReturns a dictionary containing the complete set of parameters required  to construct ACE1.Transforms.PolyTransform. All parameters are passed  as keyword argument. Also see?PolyTransform`\n\nImplements the distance transform\n\n   x(r) = Big(frac1 + r_01 + rBig)^p\n\nParameters\n\ntype = \"polynomial\"\np = 2 \nr0 = 2.5\n\nMultitransform\n\nReturns a dictionary containing the complete set of parameters required  to construct ACE.Transform.multitransform. All parameters are passed  as keyword argument. \n\nParameters\n\ntransforms : dictionary specifying transforms for each species pair. Can be\n\ngiven per-pair (i.e. only for (\"element1\", \"element2\") and not for  (\"element2\", \"element1\")) or can be different for (\"element1\", \"element2\") and  (\"element2\", \"element1\"). For example\n\ntransforms = Dict(\n      (\"C\", \"C\") => Dict(\"type\"=> \"polynomial\"),\n      (\"C\", \"H\") => Dict(\"type\"=> \"polynomial\"),\n      (\"H\", \"H\") => Dict(\"type\" => \"polynomial\"))\n\nrin, rcut: values for inner and outer cutoffs, alternative to cutoffs\ncutoffs : dictionary specifying inner and outer cutoffs for each element pair\n\n(either symmetrically or non-symmetrically). Alternative to rin & rcut.  For example\n\ncutoffs => Dict(\n      (\"C\", \"C\") => (1.1, 4.5),\n      (\"C\", \"H\") => (0.9, 4.5),\n      (\"H\", \"H\") => (1.23, 4.5)),\n\nidentity\n\nIdTransform_params(;) : returns Dict(\"type\" => \"identity\"), needed to construct ACE1.Transforms.IdTransform.  \n\n\n\n\n\n","category":"function"},{"location":"outdated/command_line/#Command-line-interface","page":"Command line interface","title":"Command line interface","text":"","category":"section"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"Perhaps the easiest way to fit an ACE potential is via the command line from a JSON or YAML parameters file: ","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"julia .../ACEpotentials.jl/scripts/ace_fit.jl --params ace_params.json","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"In addition to parameters' file, ace_fit.jl takes an optional --dry-run flag. If it is given, a .size file is produced with the shape of the design matrix, useful for estimating the time and memory requirements before submitting an actual fit. Finally, there is a --num-blas-threads option for setting the number of BLAS threads to use (for fitting). ","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"For the script to use the correct Julia environment, JULIA_PROJECT (a path) must be set to the folder where Julia's Project.toml and Manifest.toml are. ","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"Below are examples of the parameters' files. The first one gives only the mandatory values and the second one has all of the default values filled in. For details on specific values see the appropriate pages of ACEpotentials Internals. Explanation of the top-level dictionary, with links to the nested dictionaries therein are in Fitting ACE. ","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"Example parameters","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"(One can access the test data at the location printed by julia --project=@. -e \"using ACEpotentials; using LazyArtifacts; println(joinpath(artifact\\\"Si_tiny_dataset\\\", \\\"Si_tiny.xyz\\\"))\".)","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"{\n    \"elements\": [\"Si\"],\n    \"order\": 3,\n    \"totaldegree\": 12,\n    \"rcut\": 5.0,\n    \"datafile\": \"Si_tiny.xyz\",\n    \"solver\": \"BayesianLinearRegression\",\n    \"energy_key\": \"dft_energy\",\n    \"force_key\": \"dft_force\",\n    \"virial_key\": \"dft_virial\"\n}","category":"page"},{"location":"outdated/command_line/#TODO","page":"Command line interface","title":"TODO","text":"","category":"section"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"All parameters with default values","category":"page"},{"location":"outdated/command_line/","page":"Command line interface","title":"Command line interface","text":"\n{\n}\n","category":"page"},{"location":"outdated/acepotentials_overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"ACEpotentials.jl has two purposes: (1) to import and re-export ACE1.jl, ACE1x.jl, ACEfit.jl, JuLIP.jl, ACEmd.jl with guaranteed version compatibility; and (2) to have several convenience wrappers for setting up the least-squares problem and solving it.","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"A short summary of packages behind ACEpotentials:","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"ACE1.jl specifies the parameterisation of interatomic potentials in terms of the (linear) atomic cluster expansion; it provides functions to generate invariant basis sets, and to evaluate the resulting interatomic potentials. ACE1x.jl is an extension of ACE1.jl incorporating new experimental features. We expect to merge these packages over time.\nACEfit.jl supplies the functionality for parameter estimation. Presently, it focuses purely on linear models and linear observations. ACEpotentials provides various tools to deal with the typical data to which interatomic potentials are fitted (total energies, forces, virials, etc) and the reading and transforming of training data. A broad range of solvers are available through this ACEfit. \nJuLIP.jl is a simple molecular simulation code in pure Julia, focusing primarily on an infrastructure to develop interatomic potentials. It provides various generic functions on top of which all our packages on this page build. \nACEmd.jl is a new implementation of ACE calculators compatible with Molly.jl. ","category":"page"},{"location":"outdated/acepotentials_overview/#General-structure","page":"Overview","title":"General structure","text":"","category":"section"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"The main convenience functions are:","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"TODO make_ace_db() - make the design matrix (\"ACE database\") for the least-squares problem. \nTODO fit_ace_db() - fit the given ACE database\nfit_ace() - make_ace_db() and fit_ace_db() in one go.","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"See Fitting ACE for more information. ","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"All of these functions take nested dictionaries that specify various parameters in making ACE. For convenience, there are a number of *params functions exported by ACEpotentials that return these dictionaries with complete set of parameters specified. These are: ","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"fit_params() - highest-level parameters' dictionary, compatible with all of make_ace_db(), fit_ace_db() and fit_ace(), see [fit.md];\nbasis_params() - parameters for constructing various bases for the design matrix of the ACE least squares database, see Fitting ACE;\ndegree_params() - for specifying the degree of ACE basis, see Constructing Basis;\ntransform_params() - parameters to specify the transform for a given basis, see Constructing Basis;\ndata_params() - for reading geometries and to-be-fitted property values, see Handling Data; \nregularizer_params() - to set up an extra regularizer, see Regularizers section in Solers;\nsolver_params() - to set up solver for the least-squares problem, see Solvers. ","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"In addition, there are some utility functions:  ","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"save_fit() - save given potential to file, see Fitting ACE;\nfill_defaults() - recursively fills in default values for any of the optional parameters that were left unspecified, see Helper Functions;\nparse_ace_basis_keys() - for parsing \"(element1, number)\" -> (\"element1\", number)-type entries that were read in from .json or .yaml files, see Helper Functions; \ndb_params() - a subset of parameters returned by fit_params(), compatible with make_ace_db() only, see Fitting ACE; \nload_dict() - reads in parameters from .yaml or .json format, see Helper Functions.","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"TODO","category":"page"},{"location":"outdated/acepotentials_overview/","page":"Overview","title":"Overview","text":"functions with different calls (fitacedb) have docs look correctly?","category":"page"},{"location":"gettingstarted/readinglist/#Reading-List","page":"Reading List","title":"Reading List","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"This page contains a curated list of articles that we recommend as initial reading / background reading towards research on MLPs in general, and ACE in particular. The list naturally reflects the authors' personal perspectives and preferences.","category":"page"},{"location":"gettingstarted/readinglist/#General-Background-/-Classics","page":"Reading List","title":"General Background / Classics","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"Bowman/Braams\nBehler/Parinello \nGAP \nMTPs \nANI ","category":"page"},{"location":"gettingstarted/readinglist/#ACE","page":"Reading List","title":"ACE","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]\nPACE","category":"page"},{"location":"gettingstarted/readinglist/#Review-articles","page":"Reading List","title":"Review articles","text":"","category":"section"},{"location":"gettingstarted/readinglist/","page":"Reading List","title":"Reading List","text":"Chem Rev","category":"page"},{"location":"gettingstarted/aceintro/#Introduction-to-ACE-Models","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The purpose of this section is to give a brief summary of the mathematics behind linear ACE parameterisations of invariant atomic properties. It is not required to use the ACEpotentials and ACE1 packages and can be skipped on a first reading.","category":"page"},{"location":"gettingstarted/aceintro/#Invariant-Properties","page":"Introduction to ACE Models","title":"Invariant Properties","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To explain the main ideas in the simplest non-trivial setting, we consider systems of indistinguishable particles. A configuration is an mset R =  bm r_j _j subset mathbbR^3 with arbitary numbers of particles and we wish to develop representation of properties ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   varphibig(R) in mathbbR","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"which are invariant under permutations (already implicit in the fact that R is an mset) and under isometries O(3). To make this explicit we can write this as","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"varphibig(  Q bm r_sigma j _j big)\n=\nvarphibig(  bm r_j _j big) qquad forall Q in O(3) \nquad sigma text a permutation","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To that end we proceed in three steps: ","category":"page"},{"location":"gettingstarted/aceintro/#Density-Projection-/-Atomic-Base","page":"Introduction to ACE Models","title":"Density Projection / Atomic Base","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"We define the \"atomic density\"","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"rho(bm r) = sum_j delta(bm r - bm r_j)","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Then we choose a one-particle basis ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"phi_v(bm r) = phi_nlm(bm r) = R_n(r) Y_l^m(hatbm r)","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"and project rho` onto that basis, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"A_v = A_nlm = langle phi_nlm rho rangle = \n   sum_j phi_nlm(bm r_j)","category":"page"},{"location":"gettingstarted/aceintro/#Density-correlations","page":"Introduction to ACE Models","title":"Density correlations","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Next, we form the N-correlations of the density, rho^otimes N and project them onto the tensor project basis, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   bm A_bm nlm \n   = Biglangle otimes_t = 1^N phi_n_t l_t m_t rho^otimes N Bigrangle \n   = prod_t = 1^N A_n_t l_t m_t","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The reason to introduce these is that in the next step, the symmetrisation step the density project would loose all angular information while the N-correlations retain most (though not all) of it. ","category":"page"},{"location":"gettingstarted/aceintro/#Symmetrisation","page":"Introduction to ACE Models","title":"Symmetrisation","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Finally, we symmetrize the N-correlations, by integrating over the O(3)-Haar measure, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  B_bm nlm propto \n  int_O(3) bm A_bm nlm circ Q  dQ ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of properties of the spherical harmonics one can write this as ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  bm B = mathcalU bm A","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"where bm A is the vector of 1, 2, ..., N correlations (the maximal N is an approximation parameter!) and mathcalU is a sparse matrix (the coupling coefficients).","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"If one symmetrised all possible N-correlations then this would create a spanning set, but one can easily reduce this to an actual basis. This construction then yields a basis of the space of symmetric polynomials. ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Notes: ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of permutation symmetry only ordered bm v tuples are retained","category":"page"},{"location":"gettingstarted/aceintro/#Linear-Dependence","page":"Introduction to ACE Models","title":"Linear Dependence","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The construction described above introduces a lot of linear dependence which is removed in the ACE basis construction in a mixed symbolic / numerical procedure. In the end we no longer index the symmetrized basis functions as B_bm nlm but as B_bm nli with i indexing the linearly independent basis functions from the bm nl block. ","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"EditURL = \"../tutorials/TiAl_model.jl\"","category":"page"},{"location":"literate_tutorials/TiAl_model/#The-acemodel-interface","page":"The acemodel interface","title":"The acemodel interface","text":"","category":"section"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"Start by importing the required libraries","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"using ACEpotentials","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We need a dataset TiAl_tutorial.xyz for this tutorial. Normally we would get the path to a datset and then use read_extxyz to load in the training set.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"# (don't execute this block)\ndata_file = \"path/to/TiAl_tutorial.xyz\"\ndata = read_extxyz(data_file)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"For convenience we provide this dataset as a Julia artifact and make it conveniently accessible via ACEpotentials.example_dataset. We keep only a small subset of the training structures to keep the regression problem small.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"data, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ntrain_data = data[1:5:end];\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"The next step is to generate a model","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"order = 3 : We take 3-correlation, i.e. a 4-body potential,\ntotaldegree = 6 : a very low polynomial degree just for testing\nrcut = 5.5 : this is a typical cutoff radius for metals","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"These three are the most important approximation parameters to explore when trying to improve the fit-accuracy. There are many other parameters to explore, which are documented in ?acemodel. Even further model refinements are possible by studying the internals of ACE1.jl and ACE1x.jl. We also specify a reference potential that will be added to the learned 2-body and many-body potential components. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape and improved robustness in predictions.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"model = acemodel(elements = [:Ti, :Al],\n\t\t\t\t\t  order = 3,\n\t\t\t\t\t  totaldegree = 6,\n\t\t\t\t\t  rcut = 5.5,\n\t\t\t\t\t  Eref = [:Ti => -1586.0195, :Al => -105.5954])\n@show length(model.basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"The next line specifies the regression weights: in the least squares loss different observations are given different weights,","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"  sum_R Big( w^E_R  E(R) - y_R^E ^2\n           + w^F_R  rm forces(R) - y_R^F ^2\n           + w^V_R  rm virial(R) - y_R^V ^2 Big)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"and this is specificed via the following dictionary. The keys correspond to the config_type of the training structures.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"weights = Dict(\n        \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ));\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"To estimate the parameters we still need to choose a solver for the least squares system. In this tutorial we use the LSQR algorithm, for no specific reason at all. Many other solvers are available, and can be explored by looking at the documentation of ACEfit.jl.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"solver = ACEfit.LSQR(damp = 1e-2, atol = 1e-6);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"ACE1.jl has a heuristic smoothness prior built in which assigns to each basis function Bi a scaling parameter si that estimates how \"rough\" that basis function is. The following line generates a regularizer (prior) with si^q on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"P = smoothness_prior(model; p = 4)    #  (p = 4 is in fact the default)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We are now ready to estimate the parameters. We take a subset of the training data to speed up the tutorial. The prior is passed to the acefit! function via the prior keyword argument.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"data_train = data[1:5:end]\nacefit!(model, data_train; solver=solver, prior = P);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We can display an error table as follows:","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"@info(\"Training Error Table\")\nACEpotentials.linear_errors(data_train, model; weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"We should of course also look at test errors, which can be done as follows. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"@info(\"Test Error Table\")\ntest_data = data[2:10:end]\nACEpotentials.linear_errors(test_data, model; weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"If we want to save the fitted potentials to disk to later use we can use one of the following commands: the first saves the potential as an ACE1.jl compatible potential, while the second line exports it to a format that can be ready by the pacemaker code to be used within LAMMPS.","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"save_ace_potential(\"./TiAl_tutorial_pot.json\", model)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"export to lammps (ML-PACE):","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"export2lammps(\"./TiAl_tutorial_pot.yace\", model)","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"","category":"page"},{"location":"literate_tutorials/TiAl_model/","page":"The acemodel interface","title":"The acemodel interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ACEpotentials","category":"page"},{"location":"#ACEpotentials.jl-Documentation","page":"Home","title":"ACEpotentials.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACEpotentials.jl facilitates the creation and use of atomic cluster expansion (ACE) interatomic potentials. For a quick start, we recommend reading the installation instructions, followed by the tutorials. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ACE models are defined in terms of body-ordered invariant features of atomic environments. For mathematical details, see this brief introduction and the references listed below.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACEpotentials.jl ties together several Julia packages implementing different aspects of ACE modelling and fitting (e.g., JuLIP.jl, ACE1.jl, ACE1x.jl, ACEfit.jl, and ACEmd.jl). ACEpotentials re-exports their features, ensuring version compatibility, and provides additional fitting and analysis tools. For example, it provides routines for parsing and manipulating the data to which interatomic potentials are fit (total energies, forces, virials, etc). These pages document ACEpotentialstogether with the relevant parts of the wider ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"JuLIP.jl is simple pure-Julia molecular simulation package that provides infrastructure for interatomic potentials. It is the foundation on which the other packages build.\nACE1.jl parameterizes interatomic potentials in terms of the (linear) atomic cluster expansion. It provides generate invariant basis sets and functions that evaluate the resulting interatomic potentials.\nACE1x.jl is an extension of ACE1.jl incorporating new experimental features. We expect to merge these packages over time.\nACEfit.jl supplies the functionality for parameter estimation. Presently, it focuses purely on linear models and linear observations. A broad range of solvers are available. \nACEmd.jl is a new implementation of ACE calculators compatible with Molly.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: JSON and command line interfaces\nAn earlier version of ACEpotentials.jl contained JSON and command line interfaces that can be used to fit ACE potentials without needing to write Julia scripts. These have not been updated to include the most recent features available from the Julia interfaces. Until this changes, we recommend using ACEpotentials.jl only through the Julia interfaces. If this is a feature important to you, please file an issue or bump an existing issue to accelerate us updating this feature.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]","category":"page"},{"location":"outdated/helpers/#Helper-Functions","page":"Helper Functions","title":"Helper Functions","text":"","category":"section"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"Probably the most useful utility function is fill_defaults() which takes in a dictionary compatible with one of the *params() functions and recursively fills in the default values for non-mandatory functions. ","category":"page"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"The (incomplete) dictionaries may read from a JSON or YAML file. Creating these files with another programming language and then calling a short Julia script to read in and fit using these parameters is the expected way of interfacing with ACE1 from other languages. ","category":"page"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"params = load_dict(\"params.json\")\n# or \nparams = load_dict(\"params.yaml\")","category":"page"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"Some of the ACE basis parameters dictionaries keys and values may be 2-tuples (specifically, the \"multitransform\" and \"sparseM\" degree specification) which are mainly represented as strings in JSON or YAML formats and may not be allowed in other languages used to write these dictionaries to file. The easiest way is to save tuples as \"(1, C)\" (different from string(tuple(1, \"C\"))) and use parse_ace_basis_keys() (also done within fill_defaults()) to parse that into (1, \"C\"). ","category":"page"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"ACEpotentials.parse_ace_basis_keys","category":"page"},{"location":"outdated/helpers/#ACEpotentials.parse_ace_basis_keys","page":"Helper Functions","title":"ACEpotentials.parse_ace_basis_keys","text":"parse_ace_basis_keys(ace_basis::Dict) -> ace_basis\n\n(\"C\", \"C\")-type tuples are saved to and read back in from JSON as \"(\"C\", \"C\")\" .json.  It's slightly easier to save these to JSON or YAM as \"(C, C)\".  This function converts \"(C, C)\"-type strings back to parameter-friendly (\"C\", \"C\"). \n\n\n\n\n\n","category":"function"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"db_params() returns only those parameters needed to construct the least-squares database. ","category":"page"},{"location":"outdated/helpers/","page":"Helper Functions","title":"Helper Functions","text":"ACEpotentials.db_params","category":"page"},{"location":"outdated/helpers/#ACEpotentials.db_params","page":"Helper Functions","title":"ACEpotentials.db_params","text":"db_params(; kwargs...)` : returns a dictionary containing all of the parameters needed for making a LsqDB. All parameters are passed  as keyword argumts. \n\nParameters\n\ndata : data parameters, see ?data_params for details (mandatory)\nbasis : dictionary containing dictionaries that specify the basis used in fitting.     For example \njulia   basis = Dict(       \"pair_short\" => Dict( \"type\" => \"pair\", ...),        \"pair_long\" => Dict(\"type\" => \"pair\", ...),        \"manybody\" => Dict(\"type\" => \"ace\", ...),        \"nospecies\" => Dict(\"type\" => \"ace\", species = [\"X\",], ...)\n\nkeys of basis are ignored, so that multiple basis with different specifications  (e.g. smaller and larger cutoffs) can be combined. See ?basis_params for more detail.  \n\nLSQ_DB_fname_stem = \"\" : stem to save LsqDB to. Doesn't get saved if set to an empty    string (\"\"). If LSQ_DB_fname_stem * \"_kron.h5\" file is not present it gets renamed,    a new LsqDB is constructed and saved.  \n\n\n\n\n\n","category":"function"},{"location":"tutorials/molly/#Using-ACE-potentials-in-Molly","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"Molly is pure Julia MD program that is in development. ACE support for Molly is currently in ACEmd package, which is exported by ACEpotentials. ","category":"page"},{"location":"tutorials/molly/#Things-to-know-about-Molly","page":"Using ACE potentials in Molly","title":"Things to know about Molly","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"Molly expects units to be defined. Our fitting procedure does not define units (implicitly we use eV for energy and Å length), so in order to use Molly, units need to be defined. This is done by wrapping potentials to a structure that holds units in addition to the potential. The units used are defined in Unitful, which is exported by default.","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To wrap units for a potential you can use load_ace_model function, which can take in a potential you have just fitted as an input. You can also load json or yace potential files exported from ACEpotentials.jl or ACE1.jl.","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"pot_with_units = load_ace_model( potential_with_no_units )\n\n# Load potential files\npot_with_units = load_ace_model( \"path to potential file\" )","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"The default units are eV for energy and Å for length. You can change these with","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"load_ace_model( \"path to potential file\";\n                energy_unit = u\"hartree\",\n                length_unit = u\"bohr\",\n                cutoff_unit = u\"pm\" )","category":"page"},{"location":"tutorials/molly/#System-setup","page":"Using ACE potentials in Molly","title":"System setup","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"#To start Molly you need to prepare the Molly system. There are still some ACE specific complications with this. But please refer to Molly documentation ","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"using Molly\nusing ACEpotentials # or ACEmd\nusing AtomsIO\n\n# Load initial structure\ndata = AtomsIO.load_system(\"initial structure file\")\n# or use whatever AtomsBase structure\n# need to have velocity return other than missing\n\n# Load ACE potential\npot = load_ace_model(\"some ace potential\")\n\n# Pack data to Molly compatible format\nsys = Molly.System(data, pot)\n\n# Set up temperature and velocities\ntemp = 298.0u\"K\"\nvel = random_velocities!(sys, temp)\n\n# Add loggers\n# need at least Molly v0.17 for this\nsys = Molly.System(\n    sys;\n    loggers=(temp=TemperatureLogger(100),) # add more loggers here\n)","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"You can also customize system more. For details refer Molly documentation.","category":"page"},{"location":"tutorials/molly/#Set-up-simulation","page":"Using ACE potentials in Molly","title":"Set up simulation","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To setup Molly simulation you need to create simulation object","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"# Set up simulator\nsimulator = VelocityVerlet(\n    dt=1.0u\"fs\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"After this you can run the simulation by","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"# Perform MD for 1000 steps\nsimulate!(sys, simulator, 1000)","category":"page"}]
}
