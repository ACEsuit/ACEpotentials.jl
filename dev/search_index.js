var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/saving-and-loading/#Saving-and-Loading-Potentials","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"warning: Warning\nSaving and loading potentials is currently only supported for the  a workflow that uses JSON / dictionaries to specify models. For anything  \"too creative\" the user is responsible for ensuring reproducability. ","category":"page"},{"location":"gettingstarted/saving-and-loading/#General-Principles","page":"Saving and Loading Potentials","title":"General Principles","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"Loading a saved potentials is only guaranteed if the Julia environment  remains the same. A new project should therefore always work with a specified  Project.toml and Manifest.toml. See out Pkg intro for a brief  introduction and references to further details. ","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"If the manifest changes, but the ACEpotentials version remains the same or  a backward compatible update (cf semver) then in principle a saved potential  should remain loadable. We cannot guarntee this but would consider it a bug  if this is not the case.","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"Normally, we save the entire Julia environment together with a fitted  potential. This way it should always be possible to reconstruct the  environment and hence the potential. More details follow. ","category":"page"},{"location":"gettingstarted/saving-and-loading/#Saving-JSON-specified-potentials","page":"Saving and Loading Potentials","title":"Saving JSON-specified potentials","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"If using the runfit.jl script, then an output folder is specified, where  all information including the full model specification and model parameters  are stored as a JSON file (together with other meta-information). ","category":"page"},{"location":"gettingstarted/saving-and-loading/#Loading-a-JSON-specified-potential","page":"Saving and Loading Potentials","title":"Loading a JSON-specified potential","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"Suppose the result of runfit.jl (or an analogous approach) is saved to  path/result.json. If the original or a compatible Julia environment is  activated, then ","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"model, meta = ACEpotentials.load_model(\"path/result.json\")","category":"page"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"will return a model::ACEPotential structure that should be equivalent  to the original fitted potential. The meta::Dict dictionary contains all  the remaining information saved in result.json. ","category":"page"},{"location":"gettingstarted/saving-and-loading/#Recovering-the-Julia-environment","page":"Saving and Loading Potentials","title":"Recovering the Julia environment","text":"","category":"section"},{"location":"gettingstarted/saving-and-loading/","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"At the moment, this process is not implemented, but the result.json file can loaded into a dictionary which can then be investigated to manually  reconstruct the environment and then load the potential as described in  the previous section. ","category":"page"},{"location":"tutorials/python_ase/#python-ase","page":"python-ase","title":"python-ase","text":"","category":"section"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"An ACEpotentials.jl model can be used in python as an ase calculator. To do this, you will need to install two python packages, julia and pyjulip as documented on the installation page. ","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Python reads the potential.json file directly. To load an ACE potential as an ase calculator, use the following syntax:","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"import pyjulip\ncalc = pyjulip.ACE1(\"first_potential.json\")","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Using that calculator, we can then evaluatuate energies, forces, etc, e.g., ","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"ats = ase.io.read('atoms_object.xyz')\nats.calc = calc\nprint(ats.get_potential_energy())","category":"page"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"See the ase documentation for more details.","category":"page"},{"location":"tutorials/python_ase/#Another-option:-ASE's-LAMMPSlib-calculator","page":"python-ase","title":"Another option: ASE's LAMMPSlib calculator","text":"","category":"section"},{"location":"tutorials/python_ase/","page":"python-ase","title":"python-ase","text":"Alternatively, to avoid direct Julia-Python interaction, one can export to LAMMPS (see LAMMPS) and utilize ASE's LAMMPSlib calculator.","category":"page"},{"location":"gettingstarted/pkg/#Using-the-Julia-Package-Manager","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This is a very brief introduction to the Julia package manager, intended for newcomers to Julia who are here primarily to use the ACEsuit. But it is not really ACE specific at all. ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"<!-- If you plan to use `ACEpotentials.jl` from Python or the command line, then you need not read this. -->","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The package manager provides functionality to organize reproducable Julia projects. A project is specified by a Project.toml where the user specifies which packages are required, and version bounds on those packages. The Package manager can then resolve these dependencies which results in a Manifest.toml where the full Julia environment is precisely specified. This can be used in a workflow as follows:","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"To start a new project that uses ACEpotentials.jl, e.g. to develop a new interatomic potential for TiAl we first create a new folder where the project will live, e.g., ace_TiAl_project. Change to that folder and start the Julia REPL. Type ] to switch to the package manager, then activate a new project in the current directory via activate .\nYou now have an empty project. Start adding the packages you need, often just   add ACEpotentials  will suffice.   Type status to see your required packages listed. (Note this is only a subset of the installed packages!). Exit the REPL and type ls; you will then see a new file Project.toml which lists the project requirements, and a Manifest.toml which lists the actually packages and the version that have been installed.\nSpecify version bounds: We strongly encourage doing this rigorously! Open Project.toml in an editor and under the [compat] section you can now add version bounds, e.g. ACEpotentials = \"0.6.1\" following semver. Please see the Pkg.jl docs for details on how to specify those bounds. Start a Julia REPL again, type ] to switch to the package manager and then up to up- or down-grade all installed packages to the latest version compatible with your bounds.","category":"page"},{"location":"gettingstarted/pkg/#Using-a-Development-Branch-(rarely-required)","page":"Using the Julia Package Manager","title":"Using a Development Branch (rarely required)","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"If you are a user rather than developer it should almost never be required for you to check out a package (or, dev it in the package manager). When developers make changes to - say - ACEpotentials.jl they will always immediately tag another version and then you can adjust your version bounds in your project to update as well as enforce which version to use. However a developer would frequently do this, and occasionally it might be required when iterating between a user and developer for testing. There are multiple ways to achieve this; the following is our recommended procedure: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Suppose for example that a development branch co/dev of ACE1.jl is needed in a project project. Then one should perform the following steps: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Make sure ACE1 has been added to project/Project.toml \nIn a separate folder, /path/to/ , clone ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"cd /path/to\ngit clone git@github.com:ACEsuit/ACE1.jl.git\ngit checkout co/dev","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"so that the repo will now live in /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Go to and activate project, then in a Julia REPL switch to the package manager ] and execute","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"dev /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This will replace the ACE1 package in the Manifest with the version that lives in /path/to/ACE1.jl ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Later on, when you want to go back to the standad Pkg versin control you can simply free ACE1.","category":"page"},{"location":"gettingstarted/pkg/#Further-Notes","page":"Using the Julia Package Manager","title":"Further Notes","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The Project.toml should always be committed to your project git repo. Whether Manifest.toml is also committed is a matter of taste or context. Tracking the Manifest will (normally) ensure future compatibility since it allows you to reconstruct the precise Julia environment that was used when the Manifest was created.","category":"page"},{"location":"gettingstarted/pkg/#Links","page":"Using the Julia Package Manager","title":"Links","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"https://pkgdocs.julialang.org/v1/\nhttps://pkgdocs.julialang.org/v1/compatibility/","category":"page"},{"location":"tutorials/#Tutorials-Overview","page":"Tutorials Overview","title":"Tutorials Overview","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"Basic Julia Workflow : minimal example to fit a potential to an existing dataset using a Julia script \nBasic Shell Workflow : basic workflow for fitting via the command line\nSmoothness Priors : brief introduction to smoothness priors\nBasic Dataset Analysis : basic techniques to visualize training datasets and correlate such observations to the choice of geometric priors\nDescriptors : ACEpotentials can be used as descriptors of atomic environments or structures, which is described here. ","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"<!-- ### Using `ACEpotentials` Potentials in External Software\n* [ACE descriptors](../literate_tutorials/descriptor.md)\n\n\n* [LAMMPS](lammps.md)\n* [Python with `ase`](python_ase.md)\n* [`Molly.jl`](molly.md) -->\n\n<!-- ### Structure analysis with ACE1 descriptors\n\n\n### Committee Potentials\n\n* [Committee Potentials](../literate_tutorials/committee.md)\n\n### Experimental Features\n\n* [Experimental Features](../literate_tutorials/experimental.md) -->","category":"page"},{"location":"tutorials/","page":"Tutorials Overview","title":"Tutorials Overview","text":"<!---\n### JSON Interface and Command line (OUTDATED)\n\nACE potentials can be fitted from the command line using a dictionary stored in a `.json` or `.yaml` file to specify the parameters:\n\n* [TiAl Potential (ACEpotentials)](../literate_tutorials/ACEpotentials_TiAl.md)\n* [TiAl Potential (command line JSON)](../outdated/first_example_json.md)\n\n-->","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"EditURL = \"../tutorials/dataset_analysis.jl\"","category":"page"},{"location":"literate_tutorials/dataset_analysis/#Basic-Dataset-Analysis","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"","category":"section"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"In this tutorial we show some basic tools in ACEpotentials to analyze a dataset and how this connects to a model construction. As usual we start by importing the relevant packages. For plotting we will use Plots.jl and LaTexStrings for nice labels.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"using ACEpotentials, Plots, LaTeXStrings, Unitful\nusing AtomsBuilder: bulk, rattle!\nusing AtomsBuilder.Chemistry: rnn     # estimates nn distance for some elements","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"Let's generate a naive dataset, just some random bulk Si structures that are rattled a bit.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"rand_Si() = rattle!(bulk(:Si, cubic=true) * rand([2,3,4]), 0.25)\nSi_data = [ rand_Si() for _=1:50 ];\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"Two basic distributions we can look at to see how well the data fills in space are the radial and angular distribution functions. For the radial distribution function we use the cutoff of the model (see below). For the angular distribution we use a cutoff just above the nearest neighbour distance to we can clearly see the equilibrium bond-angles.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"r_cut = 6.0 * u\"Å\"\nrdf = ACEpotentials.get_rdf(Si_data, r_cut; rescale = true)\n\nr_cut_adf = 1.25 * rnn(:Si)\nadf = ACEpotentials.get_adf(Si_data, r_cut_adf);\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"We can plot these distributions using the histogram function in Plots.jl. For the RDF we add some vertical lines to indicate the distances and first, second neighbours and so forth to confirm that the peaks are in the right place. For the ADF we add a vertical line to indicate the equilibrium bond angle.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"plt_rdf = histogram(ustrip.(rdf[(:Si, :Si)]), bins=150, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\", yticks = [])\nvline!(ustrip(rnn(:Si)) * [1.0, 1.633, 1.915, 2.3, 2.5], label = \"r1, r2, ...\", lw=3)\n\neq_angle = 1.91 # radians\nplt_adf = histogram(adf, bins=25, label = \"adf\", yticks = [], c = 3,\n                    xlabel = L\"\\theta\", ylabel = \"ADF\", xlims = (0, π))\nvline!([ eq_angle,], label = \"109.5˚\", lw=3)\n\nplot(plt_rdf, plt_adf, layout = (2,1), size = (800, 400))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"One way we can use these distribution functions is to look at fitted potentials relative to where data is given. But even before a potential is fitted we can illustrate some properties of the basis functions used in ACEpotentials. E.g. we can illustrate why we have chosen the distance transforms. First, we generate a default Si model and a second one with modified transform. Note that we are stripping the units from r_cut because ACEpotentials currently expects unitless values; implicitly understood as Å and eV.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"r_cut_ul = ustrip(u\"Å\", r_cut)\n\nmodel1 = ace1_model(elements = [:Si,], order = 3,\n                    totaldegree = 10, rcut = r_cut_ul)\n\nmodel2 = ace1_model(elements = [:Si,], order = 3,\n                    totaldegree = 10, rcut = r_cut_ul,\n                    transform = (:agnesi, 2, 2) );\nnothing #hide","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"We have a utility function get_transforms that extracts the transforms from the model. We can then plot the transform gradients. In regions of r space with high gradient we have higher resolution. We see that the transforms concentrate resolution near the nearest neighbour distance and ensure there is no resolution at all near r = 0. The transform for the second model distributes resolution much more evenly across the radial domain. We use ForwardDiff to differentiate the transforms.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"using ForwardDiff\ntrans1, trans1_pair = ACEpotentials.get_transforms(model1)\ntrans2, trans2_pair = ACEpotentials.get_transforms(model2)\n∇t1 = r -> ForwardDiff.derivative(trans1[(:Si, :Si)], r)\n∇t2 = r -> ForwardDiff.derivative(trans2[(:Si, :Si)], r)\nrp = range(0.0, r_cut_ul, length = 200)\n\nplt_t = plot(rp, abs.(∇t1.(rp)), lw=3,\n             xlabel = L\"r [\\AA]\", label = L\"|t_1'(r)|\",\n             yticks = [], ylabel = \"\", xlims = (0, r_cut_ul))\nplot!(plt_t, rp, abs.(∇t2.(rp)), lw=3, label = L\"|t_2'(r)\")\nvline!([ustrip(rnn(:Si)),], lw=2, label = L\"r_{\\rm nn}\")\n\nplt_rdf = histogram(rdf[(:Si, :Si)], bins=100, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\",\n                     yticks = [], xlims = (0, r_cut_ul))\nvline!([ustrip(rnn(:Si)),], label = L\"r_{\\rm nn}\", lw=3)\n\nplot(plt_t, plt_rdf, layout=grid(2, 1, heights=[0.7, 0.3]), size = (800, 400))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"To finish this tutorial, we quickly demonstrate what happens when there is more than one chemical species present in a dataset.","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"tial_data, _, _ = ACEpotentials.example_dataset(\"TiAl_tutorial\")\n\nrdf = ACEpotentials.get_rdf(tial_data, r_cut)\nplt_TiTi = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 1,\n         ylabel = \"RDF - TiTi\", label = \"\", yticks = [], xlims = (0, r_cut_ul) )\nplt_TiAl = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 2,\n         ylabel = \"RDF - TiAl\", label = \"\", yticks = [], xlims = (0, r_cut_ul) )\nplt_AlAl = histogram(rdf[(:Al, :Al)], bins=100, xlabel = L\"r [\\AA]\", c = 3,\n         ylabel = \"RDF - AlAl\", label = \"\", yticks = [], xlims = (0, r_cut_ul), )\nplot(plt_TiTi, plt_TiAl, plt_AlAl, layout = (3,1), size = (700, 700))","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"","category":"page"},{"location":"literate_tutorials/dataset_analysis/","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/lammps/#ACEpotentials-potentials-in-LAMMPS","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"","category":"section"},{"location":"tutorials/lammps/#Install-LAMMPS-with-the-ML-PACE-package","page":"ACEpotentials potentials in LAMMPS","title":"Install LAMMPS with the ML-PACE package","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"An ACEpotentials.jl potential can be used in LAMMPS if the latter is built with the ML-PACE package. At present, a patched version of that package is required which may be installed as follows:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"git clone -b release https://github.com/lammps/lammps\ncd lammps\nmkdir build\ncd build\nwget -O libpace.tar.gz https://github.com/wcwitt/lammps-user-pace/archive/main.tar.gz\ncmake \\\n    -D PKG_ML-PACE=yes \\\n    -D PACELIB_MD5=$(md5sum libpace.tar.gz | awk '{print $1}') \\\n    ../cmake\nmake -j 4","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"See the LAMMPS documentation for more build options.","category":"page"},{"location":"tutorials/lammps/#Convert-an-ACEpotentials-model-to-yace-format","page":"ACEpotentials potentials in LAMMPS","title":"Convert an ACEpotentials model to yace format","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The ML-PACE package requires a potential in the .yace format. To convert a model saved as .json, use the following:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"using ACEpotentials\npotential_json = \"Si.json\"    # example json filename\npotential_yace = \"Si.yace\"    # example yace filename\nexport2lammps(potential_yace, read_dict(load_dict(potential_json)[\"IP\"]))","category":"page"},{"location":"tutorials/lammps/#Using-yace-potentials-in-LAMMPS","page":"ACEpotentials potentials in LAMMPS","title":"Using yace potentials in LAMMPS","text":"","category":"section"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The syntax for the PACE pair style in LAMMPS, for a potential for I, Cs and Pb, is:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"pair_style      pace\npair_coeff      * * potential.yace I Cs Pb","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"The species ordering after pair_coeff must match the numerical ordering in any .data geometry file. ","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"By default, ACEpotentials models have separate two-body and many-body components. At present, the two-body component is exported via a lookup table which LAMMPs reads directly, meaning two files are created: a potentialname_pairpot.table file for the two-body contribution and a potentialname.yace file for the many-body contribution. The .table file contains a set of lookup tables with a fixed number N (written in the file) of interpolation points. To use the full model in LAMMPS, read N from the file and use the syntax:","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"pair_style      hybrid/overlay pace table spline <N>\npair_coeff      * * pace potential.yace I Cs Pb\npair_coeff      1 1 table potential_pairpot.table I_I\npair_coeff      1 2 table potential_pairpot.table I_Cs\npair_coeff      1 3 table potential_pairpot.table I_Pb\npair_coeff      2 2 table potential_pairpot.table Cs_Cs\npair_coeff      2 3 table potential_pairpot.table Cs_Pb\npair_coeff      3 3 table potential_pairpot.table Pb_Pb","category":"page"},{"location":"tutorials/lammps/","page":"ACEpotentials potentials in LAMMPS","title":"ACEpotentials potentials in LAMMPS","text":"where we are using the ordering I, Cs, Pb.","category":"page"},{"location":"gettingstarted/parallel-fitting/#Parallel-Fitting","page":"Parallel Fitting","title":"Parallel Fitting","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"ACEpotentials and ACEfit may be accelerated with one or more parallelization options.","category":"page"},{"location":"gettingstarted/parallel-fitting/#Distributed-fitting-(multiple-processes)","page":"Parallel Fitting","title":"Distributed fitting (multiple processes)","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Some routines (particularly those that assemble the linear problem) make use of Julia's multi-processing capabilities. These routines automatically utilize any available worker processes, which are initiated in one of two ways.","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"First, one may generate the workers when starting Julia. Setting JULIA_PROJECT beforehand is crucial in this case. The example starts Julia with seven additional worker processes (so, eight processes in total).","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"export JULIA_PROJECT=/path/to/project\njulia --project=path/to/project -p 7","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Alternatively, one may create workers directly within a Julia script. The exeflags argument to addprocs propagates project information, and the @everywhere macro is necessary to ensure all processes load the module. ","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"using Distributed\naddprocs(7, exeflags=\"--project=$(Base.active_project())\")\n@everywhere using ACEpotentials","category":"page"},{"location":"gettingstarted/parallel-fitting/#Parallel-BLAS-or-LAPACK","page":"Parallel Fitting","title":"Parallel BLAS or LAPACK","text":"","category":"section"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Many ACEfit solvers, and possibly other routines, utilize BLAS or LAPACK. To see benefits from threading, one should set one or more of the following environment variables, depending on the particular library used.","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"export OMP_NUM_THREADS=8\nexport MKL_NUM_THREADS=8\nexport OPENBLAS_NUM_THREADS=8\nexport VECLIB_MAXIMUM_THREADS=8","category":"page"},{"location":"gettingstarted/parallel-fitting/","page":"Parallel Fitting","title":"Parallel Fitting","text":"Distributed solution of the linear least squares systems is currently not supported. We would welcome collaboration on this with interested developers. ","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"EditURL = \"../tutorials/smoothness_priors.jl\"","category":"page"},{"location":"literate_tutorials/smoothness_priors/#Smoothness-Priors","page":"Smoothness Priors","title":"Smoothness Priors","text":"","category":"section"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"using ACEpotentials, LinearAlgebra, Plots, LaTeXStrings, Unitful","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"ACEpotentials models make heavy use of smoothness priors, i.e., prior parameter distributions that impose smoothness on the fitted potential. This tutorial demonstrates how to use the smoothness priors implemented in ACEpotentials. We start by reading in a tiny testing dataset, and bring the data into a format that ACEfit likes. Note that using a very limited dataset makes the use of priors particularlty important. In general, the larger and more diverse the dataset, the less important the prior becomes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"rawdata, _, _ = ACEpotentials.example_dataset(\"Si_tiny\")\ndatakeys = (energy_key = \"dft_energy\", force_key = \"dft_force\", virial_key = \"dft_virial\")\n\nrcut = 6.0     # cut off distance\nr_nn = 2.3     # typical nearest neighbour distance\n\nmodel = ace1_model(elements = [:Si],\n                    order = 3, totaldegree = 12,\n                    rcut = rcut, r0 = r_nn,\n                    Eref = Dict(:Si => -158.54496821))\n\ndata = [ AtomsData(at; datakeys..., v_ref = model.model.Vref) for at in rawdata ]\nA, Y, W = ACEfit.assemble(data, model);\nnothing #hide","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"A positive definite matrix P specifies a normal prior distribution in the Bayesian framework, but for the purpose of this tutorial it is maybe more intuitive to simply think of it as a regularisation operator. The regularised linear least squares problem is","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"   A c - y ^2 + lambda  P c ^2","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"where A is the design matrix, y is the vector of observations, c is the vector of parameters, and lambda is a regularisation parameter. The prior matrix P is specified by the user. At present we support diagonal operators P. The diagonal elements of P are the prior variances. The larger the prior variance, the smoother the fitted potential. Although not strictly true, we can think of each basis function as specified by a the parameters (n_t l_t)_t = 1^N, where N is the correlation-order, i.e., corresponding prior matrix element must be a function of those n_t l_t values,","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"   P_bf k bf k = gamma(bf k)","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"We currently provide convenient interfaces for three classes: algebraic, exponential and gaussian. Technically, (but loosely speaking) an algebraic prior declares that the target function has p derivatives (for some parameter p), the exponential prior declares that the target function is analytic, while the gaussian prior declares that the target function is entire. In practice, especially for small datasets when the model is underdetermined, one may use a stronger prior than is justified by our knowledge about the target function. For large and diverse datasets it can happen that too strong a prior will adversely affect the fit accuracy. For the definition of the three main prior classes, see the documentation for","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"?algebraic_smoothness_prior\n?exp_smoothness_prior\n?gaussian_smoothness_prior","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"In the following we demonstrate the usage of algebraic and gaussian priors. The choices for σl, σn made here may seem \"magical\", but there is a good justification and we plan to automate this in future releases.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Pa2 = algebraic_smoothness_prior(model; p=2)\nPa4 = algebraic_smoothness_prior(model; p=4)\nPg  = gaussian_smoothness_prior( model; wl = (2/r_nn)^2, wn = (0.5/r_nn)^2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Each of these object Pa2, Pa4, Pg are diagonal matrices. For each prior constructed above we now solve the regularised least squares problem. Note how design matrix need only be assembled once if we want to play with many different priors. Most of the time we would just use defaults however and then these steps are all taken care of behind the scenes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"priors = Dict(\"Id\" => I, \"Algebraic(2)\" => Pa2, \"Algebraic(4)\" => Pa4,\"Gaussian\" => Pg)\nrmse = Dict()\npots = Dict()\n\nfor (prior_name, P) in priors\n    print(\"Solving with \", prior_name, \" prior ... \")\n\n    # solve the regularized least squares problem\n    Ã = Diagonal(W) * (A / P)\n    ỹ = Diagonal(W) * Y\n    c̃ = ACEfit.solve(ACEfit.BLR(; verbose=false), Ã, ỹ)[\"C\"]\n    _modl = deepcopy(model)\n    set_parameters!(_modl, P \\ c̃)\n\n    # compute errors and store them for later use (don't print them here)\n    errs = linear_errors(rawdata, model; verbose=false, datakeys...)\n    rmse[prior_name] = errs[\"rmse\"][\"set\"][\"F\"]\n    pots[prior_name] = _modl\n    println(\" force=rmse = \", rmse[prior_name])\nend","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"The force RMSE errors are comparable for the three priors, though slightly better for the weaker smoothness priors Algebraic(2) and Id. This is unsurprising, since those priors are less restrictive.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"On the other hand, we expect the stronger priors to generalize better. A typical intuition is that smooth potentials with similar accuracy will be more transferable than rougher potentials. We will show three one-dimensional slices through the fitted potentials: dimer curves, trimer curves and a decohesion curve.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"First, the dimer curves: the utility function ACEpotentials.dimers can be used to generate the data for those curves, which are then plotted using Plots.jl. We also add a vertical line to indicate the nearest neighbour distance. The standard identity prior gives a completely unrealistic dimer curve. The Algebraic(2) regularised potential is missing a repulsive core behaviour. The two remaining smoothness priors give physically sensible dimer curve shapes.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"labels = sort(collect(keys(priors)))[[4,1,2,3]]\nplt_dim = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"E [eV]\",\n               xlims = (0, rcut), ylims = (-2, 5))\nfor l in labels\n    D = ACEpotentials.dimers(pots[l], [:Si,])\n    plot!(plt_dim, D[(:Si, :Si)]..., label = l, lw=2)\nend\nvline!([r_nn,], lw=2, ls=:dash, label = L\"r_{\\rm nn}\")\nplt_dim","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Next, we look at a trimer curve. This is generated using ACEpotentials.trimers. Both the Id and Algebraic(2) regularised models contain fairly significant oscillations while the Algebraic(4) and Gaussian models are much smoother. In addition, it appears that the Gaussian regularised model is somewhat more physically realistic on this slice with high energy at small bond-angles (thought the low energy at angle π seems somewhat strange).","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"plt_trim = plot(legend = :topright, xlabel = L\"\\theta\", ylabel = \"E [eV]\",\n               xlims = (0, pi), ylims = (-0.6, 0.2))\nfor l in labels\n    D = ACEpotentials.trimers(pots[l], [:Si,], r_nn*u\"Å\",  r_nn*u\"Å\")\n    plot!(plt_trim, D[(:Si, :Si, :Si)]..., label = l, lw=2)\nend\nvline!(plt_trim, [1.90241,], lw=2, label = \"equilibrium angle\")\nplt_trim","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"Finally, we plot a decohesion curve, which contains more significant many-body effects. Arguably, none of our potentials perform very well on this test. Usually larger datasets, and longer cutoffs help in this case.","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"using AtomsBuilder  # gives us `bulk`\n\nat0 = bulk(:Si, cubic=true)\nplt_dec = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"strain [eV/Å]\",\n                xlim = (0.0, 5.0))\nfor l in labels\n    rr, E, dE = ACEpotentials.decohesion_curve(at0, pots[l])\n    plot!(plt_dec, ustrip.(rr), ustrip.(dE), label = l, lw=2)\nend\nplt_dec","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"","category":"page"},{"location":"literate_tutorials/smoothness_priors/","page":"Smoothness Priors","title":"Smoothness Priors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"EditURL = \"../tutorials/basic_julia_workflow.jl\"","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/#Basic-Workflow","page":"Basic Workflow","title":"Basic Workflow","text":"","category":"section"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"This short tutorial introduces the minimal workflow for people working purely in Julia. There are (or are in development) separate tutorials on using ACEpotentials via shell scripts or via Python, and tutorials on more advanced usage.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"Start by importing ACEpotentials (and possibly other required libraries)","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"using ACEpotentials","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"We need a dataset TiAl_tutorial.xyz for this tutorial. Normally we would get the path to a datset and then use read_extxyz to load in the training set.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"# (don't execute this block)\ndata_file = \"path/to/TiAl_tutorial.xyz\"\ndata = read_extxyz(data_file)","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"For convenience we provide this dataset as a Julia artifact and make it accessible via ACEpotentials.example_dataset. We keep only a small subset of the structures for training and testing to keep the regression problem small.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"data, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ntrain_data = data[1:5:end];\ntest_data = data[2:10:end];\nnothing #hide","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"The next step is to generate a model. Here we generate a linear ACE model using the ACE1compat interface, which generates models that are essentially equivalent to those provided by the discontinued ACE1.jl package.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"order = 3 : We take 3-correlation, i.e. a 4-body potential,\ntotaldegree = 6 : a very low polynomial degree just for testing\nrcut = 5.5 : this is a typical cutoff radius for metals","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"These three are the most important approximation parameters to explore when trying to improve the fit-accuracy. There are many other parameters to explore, which are documented in ?acemodel. Even further model refinements are possible by studying the internals of ACE1.jl and ACE1x.jl. We also specify a reference potential that will be added to the learned 2-body and many-body potential components. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape and improved robustness in predictions.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"hyperparams = (elements = [:Ti, :Al],\n\t\t\t\t\torder = 3,\n\t\t\t\t\ttotaldegree = 6,\n\t\t\t\t\trcut = 5.5,\n\t\t\t\t\tEref = [:Ti => -1586.0195, :Al => -105.5954])\nmodel = ace1_model(; hyperparams...)\n@show length_basis(model);\nnothing #hide","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"The next line specifies the regression weights: in the least squares loss different observations are given different weights,","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"  sum_R Big( w_ER^2  E(R) - y_R^E ^2\n           + w_FR^2  rm forces(R) - y_R^F ^2\n           + w_VR^2  rm virial(R) - y_R^V ^2 Big)","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"and this is specificed via the following dictionary. The keys correspond to the config_type of the training structures.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"weights = Dict(\n        \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ));\nnothing #hide","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"To estimate the parameters we still need to choose a solver for the least squares system. In this tutorial we use a Bayesian linear regression, which is the recommended default at the moment. Many other solvers are available, and can be explored by looking at the documentation of ACEfit.jl.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"solver = ACEfit.BLR()","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"ACEpotentials provides a heuristic smoothness prior which assigns to each basis function Bi a scaling parameter si that estimates how \"rough\" that basis function is. The following line generates a regularizer (prior) with si^q on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"P = algebraic_smoothness_prior(model; p = 4)    #  (p = 4 is in fact the default)","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"We are now ready to estimate the parameters. We take a subset of the training data to speed up the tutorial. The prior is passed to the acefit! function via the prior keyword argument.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"result = acefit!(train_data, model; solver=solver, prior = P, weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"We can display an error table as follows:","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"@info(\"Training Error Table\")\nerr_train = ACEpotentials.linear_errors(train_data, model; weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"We should of course also look at test errors, which can be done as follows. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"@info(\"Test Error Table\")\nerr_test = ACEpotentials.linear_errors(test_data, model; weights=weights);\nnothing #hide","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"If we want to save the fitted potentials to disk to later use we can simply save the hyperparameters and the parameters. At the moment this must be done manually but a more complete and convenient interface for this will be provided, also adding various sanity checks.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"using JSON\nopen(\"TiAl_model.json\", \"w\") do f\n\t JSON.print(f, Dict(\"hyperparams\" => hyperparams, \"params\" => model.ps))\nend","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"To load the model back from disk it is safest to work within the same Julia project, i.e. the same version of all packages; ideally the the Manifest should not be changed. One then generates the model again, loads the parameters from disk and then sets them in the model. Again, this will be automated in the future.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"Finally, we delete the model to clean up.","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"rm(\"TiAl_model.json\")","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"","category":"page"},{"location":"literate_tutorials/basic_julia_workflow/","page":"Basic Workflow","title":"Basic Workflow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"all_exported/#ACEpotentials.jl-API","page":"Reference","title":"ACEpotentials.jl API","text":"","category":"section"},{"location":"all_exported/#Exported","page":"Reference","title":"Exported","text":"","category":"section"},{"location":"all_exported/","page":"Reference","title":"Reference","text":"Modules = [ACEpotentials, ACEpotentials.Models, ACEpotentials.ACE1compat]\nPrivate = false","category":"page"},{"location":"all_exported/#ACEpotentials.acefit!-Tuple{AbstractArray{<:AtomsBase.AbstractSystem}, Any}","page":"Reference","title":"ACEpotentials.acefit!","text":"acefit!(rawdata, model; kwargs...)\n\nprovides a convenient interface to fitting the parameters of an ACE model.  The data should be provided as a collection of AbstractSystem structures. \n\nKeyword arguments:\n\nenergy_key, force_key, virial_key specify \n\nthe label of the data to which the parameters will be fitted. \n\nweights specifies the regression weights, default is 30 for energy, 1 for forces and virials\nsolver specifies the lsq solver, default is BLR (BayesianLinearRegression)\nsmoothness specifies the smoothness prior, i.e. how strongly damped   parameters corresponding to high polynomial degrees are; is 2.\nprior specifies a covariance of the prior, if nothing then a smoothness prior   is used, using the smoothness parameter \nrepulsion_restraint specifies whether to add artificial data to the training   set that effectively introduces a restraints encouraging repulsion   in the limit rij -> 0.\nrestraint_weight specifies the weight of the repulsion restraint.\nexport_lammps : path to a file to which the fitted potential will be exported   in a LAMMPS compatible format (yace)\nexport_json : path to a file to which the fitted potential will be exported   in a JSON format, which can be read from Julia or Python\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.site_descriptors-Tuple{AtomsBase.AbstractSystem, ACEpotentials.Models.ACEPotential}","page":"Reference","title":"ACEpotentials.site_descriptors","text":"site_descriptors(system::AbstractSystem, model::ACEPotential;\n                 domain, nlist)\n\nCompute site descriptors for all atoms in system, returning them as a vector of vectors. If the optional kw argument domain is passed as a list of  integers (atom indices), then only the site descriptors for those atoms are  computed and returned. The neighbourlist nlist can be supplied optionally as a kw arg, otherwise it is recomputed. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#Not-exported","page":"Reference","title":"Not exported","text":"","category":"section"},{"location":"all_exported/","page":"Reference","title":"Reference","text":"Modules = [ACEpotentials, ACEpotentials.Models, ACEpotentials.ACE1compat]\nPublic = false","category":"page"},{"location":"all_exported/#ACEpotentials.at_dimer-Tuple{Any, Any, Any}","page":"Reference","title":"ACEpotentials.at_dimer","text":"function at_dimer(r, z1, z0) : generates a dimer with separation r and  atomic numbers z1 and z0.  (can also use symbols or strings)\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.at_trimer-NTuple{6, Any}","page":"Reference","title":"ACEpotentials.at_trimer","text":"function at_trimer(r1, r2, θ, z0, z1, z2) : generates a trimer with separations r1 and r2, angle θ and atomic numbers z0, z1 and z2  (can also use symbols or strings),  where z0 is the species of the central  atom, z1 at distance r1 and z2 at distance r2.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.atom_energy-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.atom_energy","text":"function atom_energy(IP, z0) : energy of an isolated atom\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.copy_runfit-Tuple{Any}","page":"Reference","title":"ACEpotentials.copy_runfit","text":"  copy_runfit(dest)\n\nCopies the runfit.jl script and an example model parameter file to dest. If called from the destination directory, use \n\nACEpotentials.copy_runfit(@__DIR__())\n\nThis is intended to setup a local project directory with the necessary  scripts to run a fitting job.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.decohesion_curve-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.decohesion_curve","text":"Generate a decohesion curve for testing the smoothness of a potential.  Arguments:\n\nat0 : unit cell \npot : potential implementing energy\n\nKeyword Arguments: \n\ndim = 1 : dimension into which to expand\nmult = 10 : multiplicative factor for expanding the cell in dim direction\naa = :auto : array of stretch values of the lattice parameter to use\nnpoints = 100 : number of points to use in the stretch array (for auto aa)\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.dimer_energy-NTuple{4, Any}","page":"Reference","title":"ACEpotentials.dimer_energy","text":"function dimer_energy(pot, r, z1, z0) : energy of a dimer  with separation r and atomic numbers z1 and z0 using the potential pot;  subtracting the 1-body contributions. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.dimers-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.dimers","text":"dimers(potential, elements; kwargs...) :  Generate a dictionary of dimer curves for a given potential. \n\npotential : potential to use to evaluate energy\nelements : list of chemical species, symbols for which the dimers are to be computed\n\nThe function returns a dictionary Ddim such that D[(s1, s2)] contains pairs or arrays (rr, E) which can be plotted plot(rr, E). \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.get_adf-Tuple{AbstractVector{<:AtomsBase.AbstractSystem}, Any}","page":"Reference","title":"ACEpotentials.get_adf","text":"function get_adf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) :\n\nAngular distribution, i.e. list of angles in [0, π] between all pairs of bonds  of length at most r_cut. Keyword arguments:\n\nskip = 3 : only consider every skipth atom in the dataset.\nmaxsamples = 100_000 : maximum number of samples to return.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.get_rdf-Tuple{AbstractVector{<:AtomsBase.AbstractSystem}, Any}","page":"Reference","title":"ACEpotentials.get_rdf","text":"function get_rdf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) : \n\nProduce a list of r values that occur in the dataset, restricted to the cutoff  radius r_cut. Keyword arguments: \n\nrescale = true : resample the data to account for volume scaling, i.e. a distance r will be kept with probability min(1, (r0/r)^2).\nr0 = :min : parameter for resampling. If :min then the minimum r occuring in the dataset is taken. \nmaxsamples = 100_000 : maximum number of samples to return. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.make_model-Tuple{Dict}","page":"Reference","title":"ACEpotentials.make_model","text":"  make_model(model_dict::Dict)\n\nUser-facing script to generate a model from a dictionary. See documentation  for details.       \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.save_model-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.save_model","text":"  save_model(model, filename; kwargs...)\n\nsave model constructor, model parameters, and other information to a JSON file. \n\nmodel : the model to be saved\nfilename : the name of the file to which the model will be saved\nmodel_spec : the arguments used to construct the model; without this            the model cannot be reconstructed unless the original script is available\nerrors : the fitting / test errors computed during the fitting \nverbose : print information about the saving process     \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.trimer_energy-NTuple{7, Any}","page":"Reference","title":"ACEpotentials.trimer_energy","text":"function trimer_energy(IP, r1, r2, θ, z0, z1, z2) : computes the energy of a trimer, subtracting the 2-body and 1-body contributions.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.trimers-NTuple{4, Any}","page":"Reference","title":"ACEpotentials.trimers","text":"trimers(potential, elements, r1, r2; kwargs...) :  Generate a dictionary of trimer curves for a given potential. \n\npotential : potential to use to evaluate energy \nelements : list of chemical species, symbols for which the trimers are to be computed\nr1, r2 : distance between the central atom and the first, second neighbour\n\nThe function returns a dictionary Dtri such that D[(s1, s2, s3)] contains  pairs or arrays (θ, E) which can be plotted plot(θ, E). \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.AADot","page":"Reference","title":"ACEpotentials.Models.AADot","text":"Implementation of AA ⋅ θ; for easier use within the FastACE.\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models.ACE1_PolyEnvelope1sR","page":"Reference","title":"ACEpotentials.Models.ACE1_PolyEnvelope1sR","text":"The pair basis radial envelope implemented in ACE1.jl \n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models.NormalizedTransform","page":"Reference","title":"ACEpotentials.Models.NormalizedTransform","text":"Maps the transform trans to the standardized interval [-1, 1]\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models.OneBody","page":"Reference","title":"ACEpotentials.Models.OneBody","text":"mutable struct OneBody{T}\n\nthis should not normally be constructed by a user, but instead E0 should be passed to the relevant model constructor, which will construct it.\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models._AA_dot-Tuple{Any, Any, Any}","page":"Reference","title":"ACEpotentials.Models._AA_dot","text":"This naive code is not supposed to be fast, it is only used to generate a  dynamic polynomial representating the operation AA ⋅ c -> εᵢ \n\nThe generated (giant) polynomial is then used to generate optimized  evaluation and gradient code. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models._make_smatrix-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.Models._make_smatrix","text":"Takes an object and converts it to an SMatrix{NZ, NZ} via the following rules: \n\nif obj is already an SMatrix{NZ, NZ} then it just return obj\nif obj is an AbstractMatrix and size(obj) == (NZ, NZ) then it   converts it to an SMatrix{NZ, NZ} with the same entries.\notherwise it generates an SMatrix{NZ, NZ} filled with the value obj.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.agnesi_transform-NTuple{4, Any}","page":"Reference","title":"ACEpotentials.Models.agnesi_transform","text":"function agnesi_transform: constructs a generalized agnesi transform. \n\ntrans = agnesi_transform(r0, p, q)\n\nwith q >= p. This generates an AnalyticTransform object that implements \n\n   x(r) = frac11 + a (rr_0)^q  (1 + (rr0)^(q-p))\n\nwith default a chosen such that x(r) is maximised at r = r_0. But a may also be specified directly as a keyword argument. \n\nThe transform satisfies \n\n   x(r) sim frac11 + a (rr_0)^p quad textas quad r to 0 \n   quad textand \n   quad \n   x(r) sim frac11 + a (rr_0)^p  quad textas r to infty\n\nAs default parameters we recommend p = 2, q = 4 and the defaults for a.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.get_nnll_spec-Tuple{ACEpotentials.Models.ACEModel}","page":"Reference","title":"ACEpotentials.Models.get_nnll_spec","text":"Get the specification of the BBbasis as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int}.\n\nParameters\n\nmodel : an ACEModel\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.get_nnll_spec-Union{Tuple{ACEpotentials.Models.SparseEquivTensor{T}}, Tuple{T}} where T","page":"Reference","title":"ACEpotentials.Models.get_nnll_spec","text":"Get the specification of the BBbasis as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int}.\n\nParameters\n\ntensor : a SparseEquivTensor, possibly from ACEModel\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.set_onehot_weights!-Tuple{ACEpotentials.Models.LearnableRnlrzzBasis, Any}","page":"Reference","title":"ACEpotentials.Models.set_onehot_weights!","text":"Set the radial weights as they would be in a linear ACE model. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.sparse_AA_spec-Tuple{}","page":"Reference","title":"ACEpotentials.Models.sparse_AA_spec","text":"This is one of the most important functions to generate an ACE model with  sparse AA basis. It generates the AA basis specification as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int, m::Int}.\n\nParameters\n\norder : maximum correlation order \nr_spec : radial basis specification in the format Vector{@NamedTuple{a::Int64, b::Int64}}\nmax_level : maximum level of the basis, either a single scalar, or an iterable (one for each order)\nlevel : a function that computes the level of a basis element; see e.g. TotalDegree and EuclideanDegree\n\n\n\n\n\n","category":"method"},{"location":"gettingstarted/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/installation/#Short-Version","page":"Installation","title":"Short Version","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"These short instructions are intended for users who are already familiar with Julia.  If these instructions don't make sense please see the detailed instructions below. ","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Install Julia (1.10) if you haven't already. Make sure the General registry is installed and up to date. (or uncomment the relevant line in the script below)\nSetup a new project: create a folder to develop your new project, and cd into the folder. This folder will track the packages and versions which the ACEpotentials code requires. Start julia, activate the project and add ACEregistry that includes ACEpotentials, which is the package that we want to install:\nusing Pkg\nPkg.activate(\".\")\n# uncomment the next line if the General registry is not yet installed,\n# e.g. if using Julia for the first time.\n# Pkg.Registry.add(\"General\")  \nPkg.Registry.add(RegistrySpec(url=\"https://github.com/ACEsuit/ACEregistry\"))\nPkg.add(\"ACEpotentials\")\nACEpotentials will come with the most important packages you need, in particular ACEfit.jl and various AtomsBase.jl related packages. \nYou need to activate a project folder when starting julia.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"This can be done by starting julia with julia --project=pathtoproject command, using an environment variable export JULIA_PROJECT=pathtoproject or, after starting julia, calling","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"activate pathtoproject\"","category":"page"},{"location":"gettingstarted/installation/#Detailed-Instructions","page":"Installation","title":"Detailed Instructions","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"If you have any difficulties with the following setup process, please file an issue. We highly recommend familiarizing oneself with the Julia package manager and how Project management is best done in Julia (there is also a summary in this section of these docs). In particular all projects should manage their own Project.toml file with appropriate version bounds, and where appropriate the Manifest.toml file can be tracked in order to guarantee reproducibility of results.","category":"page"},{"location":"gettingstarted/installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Download and unpack Julia. We require v1.10 or upwards. Add the julia executable to your path with something like export PATH=<julia-directory>/bin:$PATH.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Start the Julia REPL (type julia followed by Enter), switch to package manager by typing ], then install the General registry and the ACE registry:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"registry add https://github.com/JuliaRegistries/General\nregistry add https://github.com/ACEsuit/ACEregistry","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Press Backspace or Ctrl-c to exit the package manager. Use Ctrl-d, or exit() followed by Enter, to close the Julia REPL.","category":"page"},{"location":"gettingstarted/installation/#Setting-up-a-new-ACEpotentials.jl-project","page":"Installation","title":"Setting up a new ACEpotentials.jl project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Create a folder for your new project and change to it. Start the Julia REPL and activate a new project by switching to the package manager with ], and then running","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"activate .","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Now you can install ACEpotentials. Remaining in the package manager, use","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"add ACEpotentials","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Depending on your usage you may also need to add other packages, e.g. AtomsBase, Molly, DFTK etc.","category":"page"},{"location":"gettingstarted/installation/#Returning-to-a-project","page":"Installation","title":"Returning to a project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"When returning to a project, there are several methods for reactivating it. One is to simply activate . in the package manager, as above. Alternatively set the JULIA_PROJECT environment variable to the directory with Project.toml before starting julia, or call julia as julia --project=<dir>. Special syntax like JULIA_PROJECT=@. or julia --project=@. searches the current directory and its parents for a Project.toml file.","category":"page"},{"location":"gettingstarted/installation/#Setting-up-the-Python-ASE-calculator","page":"Installation","title":"Setting up the Python ASE calculator","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"warning: Warning\nThe current version of ACEpotentials does not have a tested ASE interface. If you need an ASE interface, consider using a version  < 0.8 of ACEpotentials.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"We use a wrapper called pyjulip to call julia and evaluate ACE potentials. In a terminal, with the correct julia project and python environment selected, run the following code:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"python -m pip install julia\npython -c \"import julia; julia.install()\"","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"Make sure to use the correct python and pip, e.g. the ones that are in the correct Conda environment. Then, to set up pyjulip:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"git clone https://github.com/casv2/pyjulip.git\ncd pyjulip\npip install .","category":"page"},{"location":"gettingstarted/installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation","title":"Installation","text":"There are currently no known recurring problems with ACEpotentials installation.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"EditURL = \"../tutorials/descriptor.jl\"","category":"page"},{"location":"literate_tutorials/descriptor/#ACE-Descriptors","page":"ACE Descriptors","title":"ACE Descriptors","text":"","category":"section"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"This tutorial demonstrates a simple use of ACE descriptors.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"using ACEpotentials, MultivariateStats, Plots","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Load a tiny silicon dataset, which has the isolated atom, 25 diamond-like (dia) configurations, 25 beta-tin-like (bt) configurations, and 2 liquid (liq) configurations.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"dataset, _, _ = ACEpotentials.example_dataset(\"Si_tiny\");\nnothing #hide","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"An ACE basis specifies a vector of invariant features of atomic environments and can therefore be used as a general descriptor.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"model = ace1_model(elements = [:Si],\n                rcut = 5.5,\n                order = 3,        # body-order - 1\n                totaldegree = 8);\nnothing #hide","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Compute an averaged structural descriptor for each configuration.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"descriptors = []\nconfig_types = []\nfor sys in dataset\n    sys_descriptor = sum(site_descriptors(sys, model)) / length(sys)\n    push!(descriptors, sys_descriptor)\n    push!(config_types, sys[:config_type])\nend","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"Finally, extract the descriptor principal components and plot. Note the segregation by configuration type.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"descriptors = reduce(hcat, descriptors)\nM = fit(PCA, descriptors; maxoutdim=3, pratio=1)\ndescriptors_trans = transform(M, descriptors)\np = scatter(\n    descriptors_trans[1,:], descriptors_trans[2,:], descriptors_trans[3,:],\n    marker=:circle, linewidth=0, group=config_types, legend=:right)\nplot!(p, xlabel=\"PC1\", ylabel=\"PC2\", zlabel=\"PC3\", camera=(20,10))","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"The basis used above uses defaults that are suitable for regression of a potential energy surface, but other defaults might be better when using the ACE descriptor for other tasks such as classification. The following short script shows how to make some changes of this kind:","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"model = ace1_model(elements = [:Si,], order = 3, totaldegree = 10,\n       pair_transform = (:agnesi, 1, 4),\n       pair_envelope = (:x, 0, 2),\n       transform = (:agnesi, 1, 4),\n       envelope = (:x, 0, 2),\n       r0 = :bondlen, # default, could specify explicitly\n       )","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"[pair_]transform = (:agnesi, 1, 4) : this generates a transform that behaves as t' ~ r^3 near zero and t' ~ r^-2 near the cutoff\n[pair_]envelope = (:x, 0, 2) : this generates an envelope that is ~ (x - xcut)^2 at the cutoff and just ~ 1 for r -> 0.","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"","category":"page"},{"location":"literate_tutorials/descriptor/","page":"ACE Descriptors","title":"ACE Descriptors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gettingstarted/aceintro/#Introduction-to-ACE-Models","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"This section summarises the mathematics behind linear ACE parameterisations of invariant atomic properties. It is not required to use the ACEpotentials package and can be skipped on a first reading.","category":"page"},{"location":"gettingstarted/aceintro/#Invariant-Properties","page":"Introduction to ACE Models","title":"Invariant Properties","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To explain the main ideas in the simplest non-trivial setting, we consider systems of indistinguishable particles. A configuration is an mset R =  bm r_j _j subset mathbbR^3 with arbitary numbers of particles and we wish to develop representation of properties ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   varphibig(R) in mathbbR","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"which are invariant under permutations (already implicit in the fact that R is an mset) and under isometries O(3). To make this explicit we can write this as","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"varphibig(  Q bm r_sigma j _j big)\n=\nvarphibig(  bm r_j _j big) qquad forall Q in O(3) \nquad sigma text a permutation","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To that end we proceed in three steps: ","category":"page"},{"location":"gettingstarted/aceintro/#Density-Projection-/-Atomic-Base","page":"Introduction to ACE Models","title":"Density Projection / Atomic Base","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"We define the \"atomic density\"","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"rho(bm r) = sum_j delta(bm r - bm r_j)","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Then we choose a one-particle basis ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"phi_v(bm r) = phi_nlm(bm r) = R_n(r) Y_l^m(hatbm r)","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"and project rho onto that basis, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"A_v = A_nlm = langle phi_nlm rho rangle = \n   sum_j phi_nlm(bm r_j)","category":"page"},{"location":"gettingstarted/aceintro/#Density-correlations","page":"Introduction to ACE Models","title":"Density correlations","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Next, we form the N-correlations of the density, rho^otimes N and project them onto the tensor project basis, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   bm A_mathbfnlm\n   = Biglangle otimes_t = 1^N phi_n_t l_t m_t rho^otimes N Bigrangle \n   = prod_t = 1^N A_n_t l_t m_t","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The reason to introduce these is that in the next step, the symmetrisation step, the density project would lose all angular information while the N-correlations retain most (though not all) of it. ","category":"page"},{"location":"gettingstarted/aceintro/#Symmetrisation","page":"Introduction to ACE Models","title":"Symmetrisation","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Finally, we symmetrise the N-correlations, by integrating over the O(3)-Haar measure, ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  B_mathbfnlm propto \n  int_O(3) bm A_mathbfnlm circ Q  dQ ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of properties of the spherical harmonics one can write this as ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  bm B = mathcalU bm A","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"where bm A is the vector of 1, 2, ..., N correlations (the maximal N is an approximation parameter!) and mathcalU is a sparse matrix (the coupling coefficients).","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"If one symmetrised all possible N-correlations then this would create a spanning set, but one can easily reduce this to an actual basis. This construction then yields a basis of the space of symmetric polynomials. ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Notes: ","category":"page"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of permutation symmetry only ordered bm v tuples are retained","category":"page"},{"location":"gettingstarted/aceintro/#Linear-Dependence","page":"Introduction to ACE Models","title":"Linear Dependence","text":"","category":"section"},{"location":"gettingstarted/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The construction described above introduces a lot of linear dependence which is removed in the ACE basis construction in a mixed symbolic / numerical procedure. In the end we no longer index the symmetrized basis functions as B_bm nlm but as B_mathbfnli with i indexing the linearly independent basis functions from the mathbfnl block. ","category":"page"},{"location":"tutorials/molly/#Using-ACE-potentials-in-Molly","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"Molly is pure Julia MD program that is in development. ACE support for Molly is currently in ACEmd package, which is exported by ACEpotentials.","category":"page"},{"location":"tutorials/molly/#Things-to-know-about-Molly","page":"Using ACE potentials in Molly","title":"Things to know about Molly","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"Molly expects units to be defined. Our fitting procedure does not define units (implicitly we use eV for energy and Å length), so in order to use Molly, units need to be defined. This is done by wrapping potentials to a structure that holds units in addition to the potential. The units used are defined in Unitful, which is exported by default.","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To wrap units for a potential you can use load_ace_model function, which can take in a potential you have just fitted as an input. You can also load json or yace potential files exported from ACEpotentials.jl or ACE1.jl.","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"using ACEpotentials\n\n# Load potential from file\npotential = load_potential( \"path to potential file\"; new_format=true )","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"The default units are eV for energy and Å for length. You can change these with","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"pot_new_units = ACEpotential(\n    old_potential.potentials;\n    energy_unit = u\"hartree\",\n    length_unit = u\"bohr\",\n    cutoff_unit = u\"pm\"\n)","category":"page"},{"location":"tutorials/molly/#System-setup","page":"Using ACE potentials in Molly","title":"System setup","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To start Molly you need to prepare the Molly system. There are still some ACE specific complications with this. But please refer to Molly documentation","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"using Molly\nusing ACEpotentials\nusing AtomsIO\n\n# Load initial structure\ndata = AtomsIO.load_system(\"initial structure file\")\n# or use whatever AtomsBase structure\n# need to have velocity return other than missing\n\n# Load ACE potential\npot = load_potential(\"some ace potential file\"; new_format=true)\n\n# Pack data to Molly compatible format\nsys = Molly.System(data, pot)\n\n# Set up temperature and velocities\ntemp = 298.0u\"K\"\nvel = random_velocities!(sys, temp)\n\n# Add loggers\n# need at least Molly v0.17 for this\nsys = Molly.System(\n    sys;\n    loggers=(temp=TemperatureLogger(100),) # add more loggers here\n)","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"You can also customize system more. For details refer Molly documentation.","category":"page"},{"location":"tutorials/molly/#Set-up-simulation","page":"Using ACE potentials in Molly","title":"Set up simulation","text":"","category":"section"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"To setup Molly simulation you need to create simulation object","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"# Set up simulator\nsimulator = VelocityVerlet(\n    dt=1.0u\"fs\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"After this you can run the simulation by","category":"page"},{"location":"tutorials/molly/","page":"Using ACE potentials in Molly","title":"Using ACE potentials in Molly","text":"# Perform MD for 1000 steps\nsimulate!(sys, simulator, 1000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ACEpotentials","category":"page"},{"location":"#ACEpotentials.jl-Documentation","page":"Home","title":"ACEpotentials.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACEpotentials.jl facilitates the creation and use of atomic cluster expansion (ACE) interatomic potentials. For a quick start, we recommend reading the installation instructions, followed by the tutorials. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ACE models are defined in terms of body-ordered invariant features of atomic environments. For mathematical details, see this brief introduction and the references listed below.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACEpotentials.jl ties together several Julia packages implementing different aspects of ACE modelling and fitting and provides some additional fitting and analysis tools for convenience. For example, it provides routines for parsing and manipulating the data to which interatomic potentials are fit (total energies, forces, virials, etc). Moreover, it integrates ACE potentials with the JuliaMolSim eco-system. These pages document ACEpotentialstogether with the relevant parts of the wider ecosystem.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]\nW. C. Witt, C. van der Oord, E. Gelžinyté, T. Järvinen, A. Ross, J. P. Darby, C. H. Ho, W. J. Baldwin, M. Sachs, J. Kermode, N. Bernstein, G. Csányi, and C. Ortner. ACEpotentials.jl: A Julia Implementation of the Atomic Cluster Expansion. J. Chem. Phys., 159:164101, 2023. [DOI] [arxiv]","category":"page"},{"location":"#Key-Dependencies","page":"Home","title":"Key Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Polynomials4ML.jl : basic kernels for embeddings and tensors\nEquivariantModels.jl : tools for equivariant model building\nRepLieGroups.jl : coupling coefficients for equivariant tensors\nACEfit.jl : unified interface to various regression algorithms\nAtomsBase.jl : community interface for atomic structures / systems\nAtomsCalculators.jl : community interface for computing properties of systems\nExtXYZ.jl : reading and writing extended xyz format","category":"page"},{"location":"#Useful-Related-Packages","page":"Home","title":"Useful Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Molly.jl : main molecular dynamics package in Julia\nDFTK.jl : pure Julia plane wave DFT code\nGeometryOptimization.jl and GeomOpt.jl ","category":"page"},{"location":"tutorials/scripting/#Basic-Shell-Workflow","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"","category":"section"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"This short introduces a basic workflow where models are specified via  JSON files and model fitting is achieved via a shell script. ","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"At the start of a new project we ","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"create a project folder \nactivate a Julia project in that folder \nadd ACEpotentials to the Julia project \ngenerate a fitting script and example model specification file","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"mkdir myace\ncd myace\njulia --project=. -e 'using Pkg; Pkg.add(\"ACEpotentials\"); using ACEpotentials; ACEpotentials.copy_runfit(@__DIR__())'","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"This should create two new files in the myace folder: ","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"runfit.jl\nexample_params.json","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"Copy (or move) the example_params.json file to a new filename, e.g. ","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"cp example_params.json myace_params_1.json","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"then edit that file to specify the model hyperparameters,  the fitting method (see also ACEfit.jl), and the path to the dataset (or, datasets if validation  and or test sets are also provided). To produce a fit, use ","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"julia --project=. runfit.jl -p myace_params_1.json -o results_1","category":"page"},{"location":"tutorials/scripting/","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"This will write all outputs to the ./results_1 folder, in particular results.json which contains the model specification, the fitted model parameters, and a dictionary of computed errors (rmse, mae). The list of required outputs and the output filename(s) can be changed in the model spec json. ","category":"page"}]
}
