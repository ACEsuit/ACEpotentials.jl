var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/saving-and-loading/#Saving-and-Loading-Potentials","page":"Saving and Loading Potentials","title":"Saving and Loading Potentials","text":"warning: Warning\nSaving and loading potentials is currently only supported for the  a workflow that uses JSON / dictionaries to specify models. For anything  more \"creative\" the user is responsible for ensuring reproducability. ","category":"section"},{"location":"gettingstarted/saving-and-loading/#General-Principles","page":"Saving and Loading Potentials","title":"General Principles","text":"Loading a saved potentials is only guaranteed if the Julia environment  remains the same. A new project should therefore always work with a specified  Project.toml and Manifest.toml. See out Pkg intro for a brief  introduction and references to further details. \n\nIf the manifest changes, but the ACEpotentials version remains the same or  a backward compatible update (cf semver) then in principle a saved potential  should remain loadable. We cannot guarntee this but would consider it a bug  if this is not the case.\n\nNormally, we save the entire Julia environment together with a fitted  potential. This way it should always be possible to reconstruct the  environment and hence the potential. More details follow. ","category":"section"},{"location":"gettingstarted/saving-and-loading/#Saving-JSON-specified-potentials","page":"Saving and Loading Potentials","title":"Saving JSON-specified potentials","text":"If using the runfit.jl script, then an output folder is specified, where  all information including the full model specification and model parameters  are stored as a JSON file (together with other meta-information). ","category":"section"},{"location":"gettingstarted/saving-and-loading/#Loading-a-JSON-specified-potential","page":"Saving and Loading Potentials","title":"Loading a JSON-specified potential","text":"Suppose the result of runfit.jl (or an analogous approach) is saved to  path/result.json. If the original or a compatible Julia environment is  activated, then \n\nmodel, meta = ACEpotentials.load_model(\"path/result.json\")\n\nwill return a model::ACEPotential structure that should be equivalent  to the original fitted potential. The meta::Dict dictionary contains all  the remaining information saved in result.json. ","category":"section"},{"location":"gettingstarted/saving-and-loading/#Recovering-the-Julia-environment","page":"Saving and Loading Potentials","title":"Recovering the Julia environment","text":"At the moment, this process is not implemented, but the result.json file can loaded into a dictionary which can then be investigated to manually  reconstruct the environment and then load the potential as described in  the previous section. ","category":"section"},{"location":"gettingstarted/pkg/#Using-the-Julia-Package-Manager","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This is a very brief introduction to the Julia package manager, intended for newcomers to Julia who are here primarily to use the ACEsuit. But it is not really ACE specific at all. \n\n<!-- If you plan to use `ACEpotentials.jl` from Python or the command line, then you need not read this. -->\n\nThe package manager provides functionality to organize reproducable Julia projects. A project is specified by a Project.toml where the user specifies which packages are required, and version bounds on those packages. The Package manager can then resolve these dependencies which results in a Manifest.toml where the full Julia environment is precisely specified. This can be used in a workflow as follows:\n\nTo start a new project that uses ACEpotentials.jl, e.g. to develop a new interatomic potential for TiAl we first create a new folder where the project will live, e.g., ace_TiAl_project. Change to that folder and start the Julia REPL. Type ] to switch to the package manager, then activate a new project in the current directory via activate .\nYou now have an empty project. Start adding the packages you need, often just   add ACEpotentials  will suffice.   Type status to see your required packages listed. (Note this is only a subset of the installed packages!). Exit the REPL and type ls; you will then see a new file Project.toml which lists the project requirements, and a Manifest.toml which lists the actually packages and the version that have been installed.\nSpecify version bounds: We strongly encourage doing this rigorously! Open Project.toml in an editor and under the [compat] section you can now add version bounds, e.g. ACEpotentials = \"0.6.1\" following semver. Please see the Pkg.jl docs for details on how to specify those bounds. Start a Julia REPL again, type ] to switch to the package manager and then up to up- or down-grade all installed packages to the latest version compatible with your bounds.","category":"section"},{"location":"gettingstarted/pkg/#Using-a-Development-Branch-(rarely-required)","page":"Using the Julia Package Manager","title":"Using a Development Branch (rarely required)","text":"If you are a user rather than developer it should almost never be required for you to check out a package (or, dev it in the package manager). When developers make changes to - say - ACEpotentials.jl they will always immediately tag another version and then you can adjust your version bounds in your project to update as well as enforce which version to use. However a developer would frequently do this, and occasionally it might be required when iterating between a user and developer for testing. There are multiple ways to achieve this; the following is our recommended procedure: \n\nSuppose for example that a development branch co/dev of ACEpotentials.jl is needed in a project project. Then one should perform the following steps: \n\nMake sure ACEpotentials has been added to project/Project.toml \nIn a separate folder, /path/to/ , clone ACEpotentials.jl\n\ncd /path/to\ngit clone git@github.com:ACEsuit/ACEpotentials.jl.git\ngit checkout co/dev\n\nso that the repo will now live in /path/to/ACEpotentials.jl\n\nGo to and activate project, then in a Julia REPL switch to the package manager ] and execute\n\ndev /path/to/ACEpotentials.jl\n\nThis will replace the ACEpotentials package in the Manifest with the version that lives in /path/to/ACEpotentials.jl \n\nLater on, when you want to go back to the standad Pkg versin control you can simply free ACEpotentials.","category":"section"},{"location":"gettingstarted/pkg/#Further-Notes","page":"Using the Julia Package Manager","title":"Further Notes","text":"The Project.toml should always be committed to your project git repo. Whether Manifest.toml is also committed is a matter of taste or context. Tracking the Manifest will (normally) ensure future compatibility since it allows you to reconstruct the precise Julia environment that was used when the Manifest was created.","category":"section"},{"location":"gettingstarted/pkg/#Links","page":"Using the Julia Package Manager","title":"Links","text":"https://pkgdocs.julialang.org/v1/\nhttps://pkgdocs.julialang.org/v1/compatibility/","category":"section"},{"location":"literate_tutorials/asp/#Sparse-Solvers","page":"Sparse Solvers","title":"Sparse Solvers","text":"This short tutorial introduces the use of the Lasso Homotopy (ASP) and Orthogonal Matching Pursuit (OMP) solvers. These are sparse solvers that compute the entire regularization path, providing insight into how the support evolves as the regularization parameter changes. For more details on the algorithms and their implementation, see ActiveSetPursuit.jl\n\nWe start by importing ACEpotentials (and possibly other required libraries)\n\nusing ACEpotentials\nusing Random, Plots\nusing ACEpotentials.Models: fast_evaluator\nusing SparseArrays\nusing Plots\n\nSince sparse solvers automatically select the most relevant features, we usually begin with a model that has a large basis. Here, for demonstration purposes, we use a relatively small model.\n\nmodel = ace1_model(elements = [:Si], order = 3, totaldegree = 12)\nP = algebraic_smoothness_prior(model; p = 4)\n\nNext, we load a dataset. We split the dataset into training, validation, and test sets. The training set is used to compute the solution path, the validation set is used to select the best solution, and the test set is used to evaluate the final model.\n\n_train_data, test_data, _ = ACEpotentials.example_dataset(\"Zuo20_Si\")\nshuffle!(_train_data);\n_train_data = _train_data[1:100]  # Limit the dataset size for this tutorial\nisplit = floor(Int, 0.8 * length(_train_data))\ntrain_data = _train_data[1:isplit]\nval_data = _train_data[isplit+1:end]\n\nWe can now assemble the linear system for the training and validation sets.\n\nAt, yt, Wt = ACEpotentials.assemble(train_data, model);\nAv, yv, Wv = ACEpotentials.assemble(val_data, model);\nnothing #hide\n\nWe can now compute sparse solution paths using the ASP and OMP solvers. These solvers support customizable selection criteria for choosing a solution along the path.\n\nThe select keyword controls which solution is returned:\n\n:final selects the final iterate on the path.\n(:bysize, n) selects the solution with exactly n active parameters.\n(:byerror, Îµ) selects the smallest solution whose validation error is within a factor Îµ of the minimum validation error.\n\nThe tsvd keyword controls whether the solution is post-processed using truncated SVD. This is often beneficial for ASP, as â„“1-regularization can shrink coefficients toward zero too aggressively.\n\nThe actMax keyword controls the maximum number of active parameters in the solution.\n\nsolver_asp = ACEfit.ASP(; P = P, select = :final, tsvd = true, actMax = 100,  loglevel = 0);\nasp_result = ACEfit.solve(solver_asp, Wt .* At, Wt .* yt, Wv .* Av, Wv .* yv);\nnothing #hide\n\nWe can also compute the OMP path, which is a greedy algorithm that selects the most relevant features iteratively.\n\nsolver_omp = ACEfit.OMP(; P = P, select = :final, tsvd = false, actMax = 100, loglevel = 0);\nomp_result = ACEfit.solve(solver_omp, Wt .* At, Wt .* yt, Wv .* Av, Wv .* yv);\nnothing #hide\n\nTo demonstrate the use of the sparse solvers, we will generate models with different numbers of active parameters. We can select the final model, a model with 500 active parameters, and a model with a validation error within 1.3 times the minimum validation error. We can use the ACEfit.asp_select function to select the desired models from the result.\n\nasp_final = set_parameters!( deepcopy(model),\n                  ACEfit.asp_select(asp_result, :final)[1]);\nasp_size_50  = set_parameters!( deepcopy(model),\n                  ACEfit.asp_select(asp_result, (:bysize, 50))[1]);\nasp_error13  = set_parameters!( deepcopy(model),\n                  ACEfit.asp_select(asp_result, (:byerror, 1.3))[1]);\nnothing #hide\n\nNOTE: fastevaluator temporarily disabled due to incompatibility with upstream SparseACEbasis (requires major refactoring) potfinal = fastevaluator(aspfinal; aastatic = false); pot50 = fastevaluator(aspsize50; aastatic = true); pot13 = fastevaluator(asperror13; aastatic = true);\n\nUse the models directly for now\n\nerr_13 = ACEpotentials.compute_errors(test_data,  asp_error13);\nerr_50 = ACEpotentials.compute_errors(test_data,  asp_size_50);\nerr_fin = ACEpotentials.compute_errors(test_data, asp_final);\nnothing #hide\n\nSimilarly, we can compute the errors for the OMP models.\n\nomp_final = set_parameters!( deepcopy(model),\n                  ACEfit.asp_select(omp_result, :final)[1]);\nomp_50  = set_parameters!( deepcopy(model),\n                  ACEfit.asp_select(omp_result, (:bysize, 50))[1]);\nomp_13  = set_parameters!( deepcopy(model),\n                  ACEfit.asp_select(omp_result, (:byerror, 1.3))[1]);\nnothing #hide\n\nNOTE: fastevaluator temporarily disabled due to incompatibility with upstream SparseACEbasis (requires major refactoring) potfin = fastevaluator(ompfinal; aastatic = false); pot50 = fastevaluator(omp50; aastatic = true); pot13 = fastevaluator(omp13; aa_static = true);\n\nUse the models directly for now\n\nerr_13 = ACEpotentials.compute_errors(test_data,  omp_13);\nerr_50 = ACEpotentials.compute_errors(test_data,  omp_50);\nerr_fin = ACEpotentials.compute_errors(test_data, omp_final);\nnothing #hide\n\nFinally, we can visualize the results along the solution path. We plot the validation error as a function of the number of active parameters for both ASP and OMP.\n\npath_asp = asp_result[\"path\"];\npath_omp = omp_result[\"path\"];\n\nnz_counts_asp = [nnz(p.solution) for p in path_asp];\nnz_counts_omp = [nnz(p.solution) for p in path_omp];\n\nrmses_asp = [p.rmse for p in path_asp];\nrmses_omp = [p.rmse for p in path_omp];\n\nplot(nz_counts_asp, rmses_asp;\n     xlabel = \"# Nonzero Coefficients\",\n     ylabel = \"RMSE\",\n     title = \"RMSE vs Sparsity Level\",\n     marker = :o,\n     grid = true, yscale = :log10, label = \"ASP\")\nplot!(nz_counts_omp, rmses_omp; marker = :o, label = \"OMP\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"literate_tutorials/etace_tutorial/#ETACE-Models-Tutorial","page":"ETACE Models Tutorial","title":"ETACE Models Tutorial","text":"This tutorial demonstrates how to use the EquivariantTensors (ET) backend for ACE models in ACEpotentials.jl. The ET backend provides:\n\nGraph-based evaluation (edge-centric computation)\nAutomatic differentiation via Zygote\nGPU-ready architecture via KernelAbstractions\nLux.jl layer integration\n\nWe cover two approaches:\n\nConverting from an existing ACE model - The recommended approach\nCreating an ETACE model from scratch - For advanced users\n\n# Load required packages\nusing ACEpotentials, StaticArrays, Lux, AtomsBase, AtomsBuilder, Unitful\nusing AtomsCalculators, Random, LinearAlgebra\n\nM = ACEpotentials.Models\nETM = ACEpotentials.ETModels\nimport EquivariantTensors as ET\nimport Polynomials4ML as P4ML\n\nrng = Random.MersenneTwister(1234)\n\n============================================================================= Part 1: Converting from an Existing ACE Model (Recommended) =============================================================================\n\nThe simplest way to get an ETACE model is to convert from a standard ACE model. This approach ensures consistency with the familiar ACE model construction API.\n\n# Define model hyperparameters\nelements = (:Si, :O)\norder = 3          # correlation order (body-order = order + 1)\nmax_level = 10     # total polynomial degree\nmaxl = 6           # maximum angular momentum\nrcut = 5.5         # cutoff radius in Angstrom\n\n# Create the standard ACE model\nrin0cuts = M._default_rin0cuts(elements)\nrin0cuts = (x -> (rin = x.rin, r0 = x.r0, rcut = rcut)).(rin0cuts)\n\n# Note: pair_learnable=true is required for ET conversion\n# (default uses splines which aren't yet supported by convert2et)\nmodel = M.ace_model(;\n   elements = elements,\n   order = order,\n   Ytype = :solid,\n   level = M.TotalDegree(),\n   max_level = max_level,\n   maxl = maxl,\n   pair_maxn = max_level,\n   rin0cuts = rin0cuts,\n   E0s = Dict(:Si => -0.846, :O => -1.023),  # reference energies\n   pair_learnable = true   # required for ET conversion\n)\n\n# Initialize parameters with Lux\nps, st = Lux.setup(rng, model)\n\n@info \"Standard ACE model created\"\n@info \"  Number of basis functions: $(M.length_basis(model))\"\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Method-A:-Convert-full-model-(E0-Pair-Many-body)-to-StackedCalculator","page":"ETACE Models Tutorial","title":"Method A: Convert full model (E0 + Pair + Many-body) to StackedCalculator","text":"# convert2et_full creates a StackedCalculator combining:\n#   - ETOneBody (reference energies per species)\n#   - ETPairModel (pair potential)\n#   - ETACE (many-body ACE potential)\n\net_calc_full = ETM.convert2et_full(model, ps, st; rng=rng)\n\n@info \"Full conversion to StackedCalculator\"\n@info \"  Contains: ETOneBody + ETPairPotential + ETACEPotential\"\n@info \"  Total linear parameters: $(ETM.length_basis(et_calc_full))\"\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Method-B:-Convert-only-the-many-body-ACE-component","page":"ETACE Models Tutorial","title":"Method B: Convert only the many-body ACE component","text":"# convert2et creates just the ETACE model (many-body only, no E0 or pair)\net_ace = ETM.convert2et(model)\net_ace_ps, et_ace_st = Lux.setup(rng, et_ace)\n\n# Copy parameters from the original model\nETM.copy_ace_params!(et_ace_ps, ps, model)\n\n# Wrap in calculator for AtomsCalculators interface\net_ace_calc = ETM.ETACEPotential(et_ace, et_ace_ps, et_ace_st, rcut)\n\n@info \"Many-body only conversion\"\n@info \"  ETACE basis size: $(ETM.length_basis(et_ace_calc))\"\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Method-C:-Convert-only-the-pair-potential","page":"ETACE Models Tutorial","title":"Method C: Convert only the pair potential","text":"# convertpair creates an ETPairModel\net_pair = ETM.convertpair(model)\net_pair_ps, et_pair_st = Lux.setup(rng, et_pair)\n\n# Copy parameters from the original model\nETM.copy_pair_params!(et_pair_ps, ps, model)\n\n# Wrap in calculator\net_pair_calc = ETM.ETPairPotential(et_pair, et_pair_ps, et_pair_st, rcut)\n\n@info \"Pair potential only conversion\"\n@info \"  ETPairModel basis size: $(ETM.length_basis(et_pair_calc))\"\n\n============================================================================= Part 2: Using ETACE Calculators =============================================================================\n\n# Create a test system\nsys = AtomsBuilder.bulk(:Si) * (2, 2, 1)\nrattle!(sys, 0.1u\"Ã…\")\nAtomsBuilder.randz!(sys, [:Si => 0.5, :O => 0.5])\n\n@info \"Test system: $(length(sys)) atoms\"\n\n# Evaluate energy, forces, virial using AtomsCalculators interface\nE = AtomsCalculators.potential_energy(sys, et_calc_full)\nF = AtomsCalculators.forces(sys, et_calc_full)\nV = AtomsCalculators.virial(sys, et_calc_full)\n\n@info \"Energy evaluation with full ETACE calculator\"\n@info \"  Energy: $E\"\n@info \"  Max force magnitude: $(maximum(norm.(F)))\"\n\n# Combined evaluation (more efficient)\nefv = AtomsCalculators.energy_forces_virial(sys, et_calc_full)\n@info \"  Combined EFV evaluation successful\"\n\n============================================================================= Part 3: Training Assembly (for Linear Fitting) =============================================================================\n\nThe ETACE calculators support training assembly functions for ACEfit integration. These compute the design matrix rows for linear least squares fitting.\n\n# Energy-only basis evaluation (fastest)\nE_basis = ETM.potential_energy_basis(sys, et_ace_calc)\n@info \"Energy basis: $(length(E_basis)) components\"\n\n# Full energy, forces, virial basis\nefv_basis = ETM.energy_forces_virial_basis(sys, et_ace_calc)\n@info \"EFV basis shapes:\"\n@info \"  Energy:  $(size(efv_basis.energy))\"\n@info \"  Forces:  $(size(efv_basis.forces))\"\n@info \"  Virial:  $(size(efv_basis.virial))\"\n\n# Get/set linear parameters\nparams = ETM.get_linear_parameters(et_ace_calc)\n@info \"Linear parameters: $(length(params)) values\"\n\n# Parameters can be updated for fitting:\n# ETM.set_linear_parameters!(et_ace_calc, new_params)\n\n============================================================================= Part 4: Creating an ETACE Model from Scratch (Advanced) =============================================================================\n\nFor advanced users who want direct control over the model architecture. This requires understanding the EquivariantTensors.jl API.\n\n# Define model parameters\nscratch_elements = [:Si, :O]\nscratch_maxn = 6      # number of radial basis functions\nscratch_maxl = 4      # maximum angular momentum\nscratch_order = 2     # correlation order\nscratch_rcut = 5.5    # cutoff radius\n\n# Species information\nzlist = ChemicalSpecies.(scratch_elements)\nNZ = length(zlist)\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Build-the-radial-embedding-(Rnl)","page":"ETACE Models Tutorial","title":"Build the radial embedding (Rnl)","text":"# Radial specification (n, l pairs)\nRnl_spec = [(n=n, l=l) for n in 1:scratch_maxn for l in 0:scratch_maxl]\n\n# Distance transform: r -> transformed coordinate y\n# Using standard Agnesi transform parameters\nf_trans = let rcut = scratch_rcut\n   (x, st) -> begin\n      r = norm(x.ð«)\n      # Simple polynomial transform (normalized to [-1, 1])\n      y = 1 - 2 * r / rcut\n      return y\n   end\nend\ntrans = ET.NTtransformST(f_trans, NamedTuple())\n\n# Envelope function: smooth cutoff\nf_env = y -> (1 - y^2)^2  # quartic envelope\n\n# Polynomial basis (Chebyshev)\npolys = P4ML.ChebBasis(scratch_maxn)\nPenv = P4ML.wrapped_basis(Lux.BranchLayer(\n   polys,\n   Lux.WrappedFunction(y -> f_env.(y)),\n   fusion = Lux.WrappedFunction(Pe -> Pe[2] .* Pe[1])\n))\n\n# Species-pair selector for radial weights\nselector_ij = let zlist = tuple(zlist...)\n   xij -> ET.catcat2idx(zlist, xij.z0, xij.z1)\nend\n\n# Linear layer: P(yij) -> W[(Zi, Zj)] * P(yij)\nlinl = ET.SelectLinL(scratch_maxn, length(Rnl_spec), NZ^2, selector_ij)\n\n# Complete radial embedding\nrbasis = ET.EmbedDP(trans, Penv, linl)\nrembed = ET.EdgeEmbed(rbasis)\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Build-the-angular-embedding-(Ylm)","page":"ETACE Models Tutorial","title":"Build the angular embedding (Ylm)","text":"# Spherical harmonics basis\nylm_basis = P4ML.real_sphericalharmonics(scratch_maxl)\nYlm_spec = P4ML.natural_indices(ylm_basis)\n\n# Angular embedding: edge direction -> spherical harmonics\nybasis = ET.EmbedDP(\n   ET.NTtransformST((x, st) -> x.ð«, NamedTuple()),\n   ylm_basis\n)\nyembed = ET.EdgeEmbed(ybasis)\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Build-the-many-body-basis-(sparse-ACE)","page":"ETACE Models Tutorial","title":"Build the many-body basis (sparse ACE)","text":"# Define the many-body specification\n# This specifies which (n,l) combinations appear in each correlation\n# For simplicity, use all 1-correlations up to given degree\nmb_spec = [[(n=n, l=l)] for n in 1:scratch_maxn for l in 0:scratch_maxl]\n\n# Create sparse equivariant tensor (ACE basis)\nmb_basis = ET.sparse_equivariant_tensor(\n   L = 0,                # scalar (invariant) output\n   mb_spec = mb_spec,\n   Rnl_spec = Rnl_spec,\n   Ylm_spec = Ylm_spec,\n   basis = real          # real-valued basis\n)\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Build-the-readout-layer","page":"ETACE Models Tutorial","title":"Build the readout layer","text":"# Species selector for readout\nselector_i = let zlist = zlist\n   x -> ET.cat2idx(zlist, x.z)\nend\n\n# Readout: basis values -> site energies\nreadout = ET.SelectLinL(\n   mb_basis.lens[1],     # input dimension (basis length)\n   1,                    # output dimension (site energy)\n   NZ,                   # number of species categories\n   selector_i\n)\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#Assemble-the-ETACE-model","page":"ETACE Models Tutorial","title":"Assemble the ETACE model","text":"scratch_etace = ETM.ETACE(rembed, yembed, mb_basis, readout)\n\n# Initialize with Lux\nscratch_ps, scratch_st = Lux.setup(rng, scratch_etace)\n\n@info \"ETACE model created from scratch\"\n@info \"  Radial basis size: $(length(Rnl_spec))\"\n@info \"  Angular basis size: $(length(Ylm_spec))\"\n@info \"  Many-body basis size: $(mb_basis.lens[1])\"\n\n# Wrap in calculator\nscratch_calc = ETM.ETACEPotential(scratch_etace, scratch_ps, scratch_st, scratch_rcut)\n\n# Test evaluation\nE_scratch = AtomsCalculators.potential_energy(sys, scratch_calc)\n@info \"Scratch model energy: $E_scratch\"\n\n============================================================================= Part 5: Creating One-Body and Pair Models from Scratch =============================================================================\n\n","category":"section"},{"location":"literate_tutorials/etace_tutorial/#ETOneBody:-Reference-energies","page":"ETACE Models Tutorial","title":"ETOneBody: Reference energies","text":"# Define reference energies per species\nE0_dict = Dict(ChemicalSpecies(:Si) => -0.846,\n               ChemicalSpecies(:O) => -1.023)\n\n# Category function extracts species from atom state\ncatfun = x -> x.z  # x.z is the ChemicalSpecies\n\n# Create one-body model\net_onebody = ETM.one_body(E0_dict, catfun)\n_, onebody_st = Lux.setup(rng, et_onebody)\n\n# Wrap in calculator (uses small cutoff since no neighbors needed)\nonebody_calc = ETM.ETOneBodyPotential(et_onebody, nothing, onebody_st, 3.0)\n\n@info \"ETOneBody model created\"\n@info \"  Reference energies: $E0_dict\"\n\nE_onebody = AtomsCalculators.potential_energy(sys, onebody_calc)\n@info \"  One-body energy for test system: $E_onebody\"\n\n============================================================================= Part 6: Combining Models with StackedCalculator =============================================================================\n\nStackedCalculator combines multiple calculators by summing their contributions.\n\n# Stack our from-scratch models\ncombined_calc = ETM.StackedCalculator((onebody_calc, scratch_calc))\n\n@info \"StackedCalculator created\"\n@info \"  Components: ETOneBody + ETACE\"\n@info \"  Total basis size: $(ETM.length_basis(combined_calc))\"\n\n# Evaluate combined model\nE_combined = AtomsCalculators.potential_energy(sys, combined_calc)\n@info \"  Combined energy: $E_combined\"\n\n# Training assembly works on StackedCalculator too\nefv_combined = ETM.energy_forces_virial_basis(sys, combined_calc)\n@info \"  Combined EFV basis shapes: E=$(size(efv_combined.energy)), F=$(size(efv_combined.forces))\"\n\n@info \"Tutorial complete!\"\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/#Tutorials-Overview","page":"Tutorials Overview","title":"Tutorials Overview","text":"Basic Julia Workflow : minimal example to fit a potential to an existing dataset using a Julia script\nBasic Shell Workflow : basic workflow for fitting via the command line\nSmoothness Priors : brief introduction to smoothness priors\nBasic Dataset Analysis : basic techniques to visualize training datasets and correlate such observations to the choice of geometric priors\nDescriptors : ACEpotentials can be used as descriptors of atomic environments or structures, which is described here.\nSparse Solvers : basic tutorial on using the ASP and OMP solvers.\nETACE Models : using the EquivariantTensors backend for ACE models, including conversion from standard ACE models and creating ETACE models from scratch.","category":"section"},{"location":"literate_tutorials/dataset_analysis/#Basic-Dataset-Analysis","page":"Basic Dataset Analysis","title":"Basic Dataset Analysis","text":"In this tutorial we show some basic tools in ACEpotentials to analyze a dataset and how this connects to a model construction. As usual we start by importing the relevant packages. For plotting we will use Plots.jl and LaTexStrings for nice labels.\n\nusing ACEpotentials, Plots, LaTeXStrings, Unitful\nusing AtomsBuilder: bulk, rattle!\nusing AtomsBuilder.Chemistry: rnn     # estimates nn distance for some elements\n\nLet's generate a naive dataset, just some random bulk Si structures that are rattled a bit.\n\nrand_Si() = rattle!(bulk(:Si, cubic=true) * rand([2,3,4]), 0.25)\nSi_data = [ rand_Si() for _=1:50 ];\nnothing #hide\n\nTwo basic distributions we can look at to see how well the data fills in space are the radial and angular distribution functions. For the radial distribution function we use the cutoff of the model (see below). For the angular distribution we use a cutoff just above the nearest neighbour distance to we can clearly see the equilibrium bond-angles.\n\nr_cut = 6.0 * u\"Ã…\"\nrdf = ACEpotentials.get_rdf(Si_data, r_cut; rescale = true)\n\nr_cut_adf = 1.25 * rnn(:Si)\nadf = ACEpotentials.get_adf(Si_data, r_cut_adf);\nnothing #hide\n\nWe can plot these distributions using the histogram function in Plots.jl. For the RDF we add some vertical lines to indicate the distances and first, second neighbours and so forth to confirm that the peaks are in the right place. For the ADF we add a vertical line to indicate the equilibrium bond angle.\n\nplt_rdf = histogram(ustrip.(rdf[(:Si, :Si)]), bins=150, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\", yticks = [])\nvline!(ustrip(rnn(:Si)) * [1.0, 1.633, 1.915, 2.3, 2.5], label = \"r1, r2, ...\", lw=3)\n\neq_angle = 1.91 # radians\nplt_adf = histogram(adf, bins=25, label = \"adf\", yticks = [], c = 3,\n                    xlabel = L\"\\theta\", ylabel = \"ADF\", xlims = (0, Ï€))\nvline!([ eq_angle,], label = \"109.5Ëš\", lw=3)\n\nplot(plt_rdf, plt_adf, layout = (2,1), size = (800, 400))\n\nOne way we can use these distribution functions is to look at fitted potentials relative to where data is given. But even before a potential is fitted we can illustrate some properties of the basis functions used in ACEpotentials. E.g. we can illustrate why we have chosen the distance transforms. First, we generate a default Si model and a second one with modified transform. Note that we are stripping the units from r_cut because ACEpotentials currently expects unitless values; implicitly understood as Ã… and eV.\n\nr_cut_ul = ustrip(u\"Ã…\", r_cut)\n\nmodel1 = ace1_model(elements = [:Si,], order = 3,\n                    totaldegree = 10, rcut = r_cut_ul)\n\nmodel2 = ace1_model(elements = [:Si,], order = 3,\n                    totaldegree = 10, rcut = r_cut_ul,\n                    transform = (:agnesi, 2, 2) );\nnothing #hide\n\nWe have a utility function get_transforms that extracts the transforms from the model. We can then plot the transform gradients. In regions of r space with high gradient we have higher resolution. We see that the transforms concentrate resolution near the nearest neighbour distance and ensure there is no resolution at all near r = 0. The transform for the second model distributes resolution much more evenly across the radial domain. We use ForwardDiff to differentiate the transforms.\n\nusing ForwardDiff\ntrans1, trans1_pair = ACEpotentials.get_transforms(model1)\ntrans2, trans2_pair = ACEpotentials.get_transforms(model2)\nâˆ‡t1 = r -> ForwardDiff.derivative(trans1[(:Si, :Si)], r)\nâˆ‡t2 = r -> ForwardDiff.derivative(trans2[(:Si, :Si)], r)\nrp = range(0.0, r_cut_ul, length = 200)\n\nplt_t = plot(rp, abs.(âˆ‡t1.(rp)), lw=3,\n             xlabel = L\"r [\\AA]\", label = L\"|t_1'(r)|\",\n             yticks = [], ylabel = \"\", xlims = (0, r_cut_ul))\nplot!(plt_t, rp, abs.(âˆ‡t2.(rp)), lw=3, label = L\"|t_2'(r)\")\nvline!([ustrip(rnn(:Si)),], lw=2, label = L\"r_{\\rm nn}\")\n\nplt_rdf = histogram(rdf[(:Si, :Si)], bins=100, label = \"rdf\",\n                     xlabel = L\"r [\\AA]\", ylabel = \"RDF\",\n                     yticks = [], xlims = (0, r_cut_ul))\nvline!([ustrip(rnn(:Si)),], label = L\"r_{\\rm nn}\", lw=3)\n\nplot(plt_t, plt_rdf, layout=grid(2, 1, heights=[0.7, 0.3]), size = (800, 400))\n\nTo finish this tutorial, we quickly demonstrate what happens when there is more than one chemical species present in a dataset.\n\ntial_data, _, _ = ACEpotentials.example_dataset(\"TiAl_tutorial\")\n\nrdf = ACEpotentials.get_rdf(tial_data, r_cut)\nplt_TiTi = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 1,\n         ylabel = \"RDF - TiTi\", label = \"\", yticks = [], xlims = (0, r_cut_ul) )\nplt_TiAl = histogram(rdf[(:Ti, :Ti)], bins=100, xlabel = \"\", c = 2,\n         ylabel = \"RDF - TiAl\", label = \"\", yticks = [], xlims = (0, r_cut_ul) )\nplt_AlAl = histogram(rdf[(:Al, :Al)], bins=100, xlabel = L\"r [\\AA]\", c = 3,\n         ylabel = \"RDF - AlAl\", label = \"\", yticks = [], xlims = (0, r_cut_ul), )\nplot(plt_TiTi, plt_TiAl, plt_AlAl, layout = (3,1), size = (700, 700))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"gettingstarted/parallel-fitting/#Parallel-Fitting","page":"Parallel Fitting","title":"Parallel Fitting","text":"ACEpotentials and ACEfit may be accelerated with one or more parallelization options.","category":"section"},{"location":"gettingstarted/parallel-fitting/#Distributed-fitting-(multiple-processes)","page":"Parallel Fitting","title":"Distributed fitting (multiple processes)","text":"Some routines (particularly those that assemble the linear problem) make use of Julia's multi-processing capabilities. These routines automatically utilize any available worker processes, which are initiated in one of two ways.\n\nFirst, one may generate the workers when starting Julia. Setting JULIA_PROJECT beforehand is crucial in this case. The example starts Julia with seven additional worker processes (so, eight processes in total).\n\nexport JULIA_PROJECT=/path/to/project\njulia --project=path/to/project -p 7\n\nAlternatively, one may create workers directly within a Julia script. The exeflags argument to addprocs propagates project information, and the @everywhere macro is necessary to ensure all processes load the module. \n\nusing Distributed\naddprocs(7, exeflags=\"--project=$(Base.active_project())\")\n@everywhere using ACEpotentials","category":"section"},{"location":"gettingstarted/parallel-fitting/#Parallel-BLAS-or-LAPACK","page":"Parallel Fitting","title":"Parallel BLAS or LAPACK","text":"Many ACEfit solvers, and possibly other routines, utilize BLAS or LAPACK. To see benefits from threading, one should set one or more of the following environment variables, depending on the particular library used.\n\nexport OMP_NUM_THREADS=8\nexport MKL_NUM_THREADS=8\nexport OPENBLAS_NUM_THREADS=8\nexport VECLIB_MAXIMUM_THREADS=8\n\nDistributed solution of the linear least squares systems is currently not supported. We would welcome collaboration on this with interested developers. ","category":"section"},{"location":"literate_tutorials/smoothness_priors/#Smoothness-Priors","page":"Smoothness Priors","title":"Smoothness Priors","text":"using ACEpotentials, LinearAlgebra, Plots, LaTeXStrings, Unitful\n\nACEpotentials models make heavy use of smoothness priors, i.e., prior parameter distributions that impose smoothness on the fitted potential. This tutorial demonstrates how to use the smoothness priors implemented in ACEpotentials. We start by reading in a tiny testing dataset, and bring the data into a format that ACEfit likes. Note that using a very limited dataset makes the use of priors particularlty important. In general, the larger and more diverse the dataset, the less important the prior becomes.\n\nrawdata, _, _ = ACEpotentials.example_dataset(\"Si_tiny\")\ndatakeys = (energy_key = \"dft_energy\", force_key = \"dft_force\", virial_key = \"dft_virial\")\n\nrcut = 6.0     # cut off distance\nr_nn = 2.3     # typical nearest neighbour distance\n\nmodel = ace1_model(elements = [:Si],\n                    order = 3, totaldegree = 12,\n                    rcut = rcut, r0 = r_nn,\n                    Eref = Dict(:Si => -158.54496821))\n\ndata = [ AtomsData(at; datakeys..., v_ref = model.model.Vref) for at in rawdata ]\nA, Y, W = ACEfit.assemble(data, model);\nnothing #hide\n\nA positive definite matrix P specifies a normal prior distribution in the Bayesian framework, but for the purpose of this tutorial it is maybe more intuitive to simply think of it as a regularisation operator. The regularised linear least squares problem is\n\n   A c - y ^2 + lambda  P c ^2\n\nwhere A is the design matrix, y is the vector of observations, c is the vector of parameters, and lambda is a regularisation parameter. The prior matrix P is specified by the user. At present we support diagonal operators P. The diagonal elements of P are the prior variances. The larger the prior variance, the smoother the fitted potential. Although not strictly true, we can think of each basis function as specified by a the parameters (n_t l_t)_t = 1^N, where N is the correlation-order, i.e., corresponding prior matrix element must be a function of those n_t l_t values,\n\n   P_bf k bf k = gamma(bf k)\n\nWe currently provide convenient interfaces for three classes: algebraic, exponential and gaussian. Technically, (but loosely speaking) an algebraic prior declares that the target function has p derivatives (for some parameter p), the exponential prior declares that the target function is analytic, while the gaussian prior declares that the target function is entire. In practice, especially for small datasets when the model is underdetermined, one may use a stronger prior than is justified by our knowledge about the target function. For large and diverse datasets it can happen that too strong a prior will adversely affect the fit accuracy. For the definition of the three main prior classes, see the documentation for\n\n?algebraic_smoothness_prior\n?exp_smoothness_prior\n?gaussian_smoothness_prior\n\nIn the following we demonstrate the usage of algebraic and gaussian priors. The choices for Ïƒl, Ïƒn made here may seem \"magical\", but there is a good justification and we plan to automate this in future releases.\n\nPa2 = algebraic_smoothness_prior(model; p=2)\nPa4 = algebraic_smoothness_prior(model; p=4)\nPg  = gaussian_smoothness_prior( model; wl = (2/r_nn)^2, wn = (0.5/r_nn)^2);\nnothing #hide\n\nEach of these object Pa2, Pa4, Pg are diagonal matrices. For each prior constructed above we now solve the regularised least squares problem. Note how design matrix need only be assembled once if we want to play with many different priors. Most of the time we would just use defaults however and then these steps are all taken care of behind the scenes.\n\npriors = Dict(\"Id\" => I, \"Algebraic(2)\" => Pa2, \"Algebraic(4)\" => Pa4,\"Gaussian\" => Pg)\nrmse = Dict()\npots = Dict()\n\nfor (prior_name, P) in priors\n    print(\"Solving with \", prior_name, \" prior ... \")\n\n    # solve the regularized least squares problem\n    AÌƒ = Diagonal(W) * (A / P)\n    yÌƒ = Diagonal(W) * Y\n    cÌƒ = ACEfit.solve(ACEfit.BLR(; verbose=false), AÌƒ, yÌƒ)[\"C\"]\n    _modl = deepcopy(model)\n    set_parameters!(_modl, P \\ cÌƒ)\n\n    # compute errors and store them for later use (don't print them here)\n    errs = compute_errors(rawdata, model; verbose=false, datakeys...)\n    rmse[prior_name] = errs[\"rmse\"][\"set\"][\"F\"]\n    pots[prior_name] = _modl\n    println(\" force=rmse = \", rmse[prior_name])\nend\n\nThe force RMSE errors are comparable for the three priors, though slightly better for the weaker smoothness priors Algebraic(2) and Id. This is unsurprising, since those priors are less restrictive.\n\nOn the other hand, we expect the stronger priors to generalize better. A typical intuition is that smooth potentials with similar accuracy will be more transferable than rougher potentials. We will show three one-dimensional slices through the fitted potentials: dimer curves, trimer curves and a decohesion curve.\n\nFirst, the dimer curves: the utility function ACEpotentials.dimers can be used to generate the data for those curves, which are then plotted using Plots.jl. We also add a vertical line to indicate the nearest neighbour distance. The standard identity prior gives a completely unrealistic dimer curve. The Algebraic(2) regularised potential is missing a repulsive core behaviour. The two remaining smoothness priors give physically sensible dimer curve shapes.\n\nlabels = sort(collect(keys(priors)))[[4,1,2,3]]\nplt_dim = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"E [eV]\",\n               xlims = (0, rcut), ylims = (-2, 5))\nfor l in labels\n    D = ACEpotentials.dimers(pots[l], [:Si,])\n    plot!(plt_dim, D[(:Si, :Si)]..., label = l, lw=2)\nend\nvline!([r_nn,], lw=2, ls=:dash, label = L\"r_{\\rm nn}\")\nplt_dim\n\nNext, we look at a trimer curve. This is generated using ACEpotentials.trimers. Both the Id and Algebraic(2) regularised models contain fairly significant oscillations while the Algebraic(4) and Gaussian models are much smoother. In addition, it appears that the Gaussian regularised model is somewhat more physically realistic on this slice with high energy at small bond-angles (thought the low energy at angle Ï€ seems somewhat strange).\n\nplt_trim = plot(legend = :topright, xlabel = L\"\\theta\", ylabel = \"E [eV]\",\n               xlims = (0, pi), ylims = (-0.6, 0.2))\nfor l in labels\n    D = ACEpotentials.trimers(pots[l], [:Si,], r_nn*u\"Ã…\",  r_nn*u\"Ã…\")\n    plot!(plt_trim, D[(:Si, :Si, :Si)]..., label = l, lw=2)\nend\nvline!(plt_trim, [1.90241,], lw=2, label = \"equilibrium angle\")\nplt_trim\n\nFinally, we plot a decohesion curve, which contains more significant many-body effects. Arguably, none of our potentials perform very well on this test. Usually larger datasets, and longer cutoffs help in this case.\n\nusing AtomsBuilder  # gives us `bulk`\n\nat0 = bulk(:Si, cubic=true)\nplt_dec = plot(legend = :topright, xlabel = L\"r [\\AA]\", ylabel = \"strain [eV/Ã…]\",\n                xlim = (0.0, 5.0))\nfor l in labels\n    rr, E, dE = ACEpotentials.decohesion_curve(at0, pots[l])\n    plot!(plt_dec, ustrip.(rr), ustrip.(dE), label = l, lw=2)\nend\nplt_dec\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"literate_tutorials/basic_julia_workflow/#Basic-Workflow","page":"Basic Workflow","title":"Basic Workflow","text":"This short tutorial introduces the minimal workflow for people working purely in Julia. There are (or are in development) separate tutorials on using ACEpotentials via shell scripts or via Python, and tutorials on more advanced usage.\n\nStart by importing ACEpotentials (and possibly other required libraries)\n\nusing ACEpotentials\n\nWe need a dataset TiAl_tutorial.xyz for this tutorial. Normally we would get the path to a datset and then use read_extxyz to load in the training set.\n\n# (don't execute this block)\nusing ExtXYZ\ndata_file = \"path/to/TiAl_tutorial.xyz\"\ndata = ExtXYZ.load(data_file)\n\nFor convenience we provide this dataset as a Julia artifact and make it accessible via ACEpotentials.example_dataset. We keep only a small subset of the structures for training and testing to keep the regression problem small.\n\ndata, _, meta = ACEpotentials.example_dataset(\"TiAl_tutorial\")\ntrain_data = data[1:5:end];\ntest_data = data[2:10:end];\nnothing #hide\n\nThe next step is to generate a model. Here we generate a linear ACE model using the ACE1compat interface, which generates models that are essentially equivalent to those provided by the discontinued ACE1.jl package.\n\norder = 3 : We take 3-correlation, i.e. a 4-body potential,\ntotaldegree = 6 : a very low polynomial degree just for testing\nrcut = 5.5 : this is a typical cutoff radius for metals\n\nThese three are the most important approximation parameters to explore when trying to improve the fit-accuracy. There are many other parameters to explore, which are documented in ?acemodel. Even further model refinements are possible by studying the internals of ACE1.jl and ACE1x.jl. We also specify a reference potential that will be added to the learned 2-body and many-body potential components. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape and improved robustness in predictions.\n\nhyperparams = (elements = [:Ti, :Al],\n\t\t\t\t\torder = 3,\n\t\t\t\t\ttotaldegree = 6,\n\t\t\t\t\trcut = 5.5,\n\t\t\t\t\tEref = [:Ti => -1586.0195, :Al => -105.5954])\nmodel = ace1_model(; hyperparams...)\n@show length_basis(model);\nnothing #hide\n\nThe next line specifies the regression weights: in the least squares loss different observations are given different weights,\n\n  sum_R Big( w_ER^2  E(R) - y_R^E ^2\n           + w_FR^2  rm forces(R) - y_R^F ^2\n           + w_VR^2  rm virial(R) - y_R^V ^2 Big)\n\nand this is specificed via the following dictionary. The keys correspond to the config_type of the training structures.\n\nweights = Dict(\n        \"FLD_TiAl\" => Dict(\"E\" => 60.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ));\nnothing #hide\n\nTo estimate the parameters we still need to choose a solver for the least squares system. In this tutorial we use a Bayesian linear regression, which is the recommended default at the moment. Many other solvers are available, and can be explored by looking at the documentation of ACEfit.jl.\n\nsolver = ACEfit.BLR()\n\nACEpotentials provides a heuristic smoothness prior which assigns to each basis function Bi a scaling parameter si that estimates how \"rough\" that basis function is. The following line generates a regularizer (prior) with si^q on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.\n\nP = algebraic_smoothness_prior(model; p = 4)    #  (p = 4 is in fact the default)\n\nWe are now ready to estimate the parameters. We take a subset of the training data to speed up the tutorial. The prior is passed to the acefit! function via the prior keyword argument.\n\nresult = acefit!(train_data, model; solver=solver, prior = P, weights=weights);\nnothing #hide\n\nWe can display an error table as follows:\n\n@info(\"Training Error Table\")\nerr_train = ACEpotentials.compute_errors(train_data, model; weights=weights);\nnothing #hide\n\nWe should of course also look at test errors, which can be done as follows. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.\n\n@info(\"Test Error Table\")\nerr_test = ACEpotentials.compute_errors(test_data, model; weights=weights);\nnothing #hide\n\nIf we want to save the fitted potentials to disk to later use we can simply save the hyperparameters and the parameters. At the moment this must be done manually but a more complete and convenient interface for this will be provided, also adding various sanity checks.\n\nusing JSON\nopen(\"TiAl_model.json\", \"w\") do f\n\t JSON.print(f, Dict(\"hyperparams\" => hyperparams, \"params\" => model.ps))\nend\n\nTo load the model back from disk it is safest to work within the same Julia project, i.e. the same version of all packages; ideally the the Manifest should not be changed. One then generates the model again, loads the parameters from disk and then sets them in the model. Again, this will be automated in the future.\n\nFinally, we delete the model to clean up.\n\nrm(\"TiAl_model.json\")","category":"section"},{"location":"literate_tutorials/basic_julia_workflow/#Fast-Evaluator","page":"Basic Workflow","title":"Fast Evaluator","text":"ACEpotentials.jl provides an experimental \"fast evaluator\". This tries to merge some of the operations in the full model resulting in a \"slimmer\" and usually faster evaluator. In some cases the performance gain can be multiple factors up to an order of magnitude. This is particularly important when using a parameter estimation solver that sparsifies. In that case, the performance gain can be significant.\n\nTo construct the fast evaluator, simply use\n\nfpot = fast_evaluator(model)\n\nAn optional keyword argument aa_static = true can be used to optimize the n-correlation layer for very small models (at most a few hundred parameters). For larger models this leads to a stack overflow.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"all_exported/#ACEpotentials.jl-API","page":"Reference","title":"ACEpotentials.jl API","text":"","category":"section"},{"location":"all_exported/#Exported","page":"Reference","title":"Exported","text":"","category":"section"},{"location":"all_exported/#Not-exported","page":"Reference","title":"Not exported","text":"","category":"section"},{"location":"all_exported/#ACEpotentials.acefit!-Tuple{AbstractArray{<:AtomsBase.AbstractSystem}, Any}","page":"Reference","title":"ACEpotentials.acefit!","text":"acefit!(rawdata, model; kwargs...)\n\nprovides a convenient interface to fitting the parameters of an ACE model.  The data should be provided as a collection of AbstractSystem structures. \n\nKeyword arguments:\n\nenergy_key, force_key, virial_key specify \n\nthe label of the data to which the parameters will be fitted. \n\nweights specifies the regression weights, default is 30 for energy, 1 for forces and virials\nsolver specifies the lsq solver, default is BLR (BayesianLinearRegression)\nsmoothness specifies the smoothness prior, i.e. how strongly damped   parameters corresponding to high polynomial degrees are; is 2.\nprior specifies a covariance of the prior, if nothing then a smoothness prior   is used, using the smoothness parameter \nrepulsion_restraint specifies whether to add artificial data to the training   set that effectively introduces a restraints encouraging repulsion   in the limit rij -> 0.\nrestraint_weight specifies the weight of the repulsion restraint.\nexport_lammps : path to a file to which the fitted potential will be exported   in a LAMMPS compatible format (yace)\nexport_json : path to a file to which the fitted potential will be exported   in a JSON format, which can be read from Julia or Python\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.site_descriptors-Tuple{AtomsBase.AbstractSystem, ACEpotentials.Models.ACEPotential}","page":"Reference","title":"ACEpotentials.site_descriptors","text":"site_descriptors(system::AbstractSystem, model::ACEPotential;\n                 domain, nlist)\n\nCompute site descriptors for all atoms in system, returning them as a vector of vectors. If the optional kw argument domain is passed as a list of  integers (atom indices), then only the site descriptors for those atoms are  computed and returned. The neighbourlist nlist can be supplied optionally as a kw arg, otherwise it is recomputed. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.at_dimer-Tuple{Any, Any, Any}","page":"Reference","title":"ACEpotentials.at_dimer","text":"function at_dimer(r, z1, z0) : generates a dimer with separation r and  atomic numbers z1 and z0.  (can also use symbols or strings)\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.at_trimer-NTuple{6, Any}","page":"Reference","title":"ACEpotentials.at_trimer","text":"function at_trimer(r1, r2, Î¸, z0, z1, z2) : generates a trimer with separations r1 and r2, angle Î¸ and atomic numbers z0, z1 and z2  (can also use symbols or strings),  where z0 is the species of the central  atom, z1 at distance r1 and z2 at distance r2.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.atom_energy-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.atom_energy","text":"function atom_energy(IP, z0) : energy of an isolated atom\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.copy_runfit","page":"Reference","title":"ACEpotentials.copy_runfit","text":"  copy_runfit(dest = pwd())\n\nCopies the runfit.jl script and an example model parameter file to dest. If called from the destination directory, use \n\nACEpotentials.copy_runfit()\n\nThis is intended to setup a local project directory with the necessary  scripts to run a fitting job.\n\n\n\n\n\n","category":"function"},{"location":"all_exported/#ACEpotentials.copy_tutorial","page":"Reference","title":"ACEpotentials.copy_tutorial","text":"  copy_tutorial(dest = pwd())\n\nConverts the ACEpotential-Tutorial.jl and ACE+AtomsBase.jl literate  notebooks to jupyter notebooks and copies them to the folder dest.\n\n\n\n\n\n","category":"function"},{"location":"all_exported/#ACEpotentials.decohesion_curve-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.decohesion_curve","text":"Generate a decohesion curve for testing the smoothness of a potential.  Arguments:\n\nat0 : unit cell \npot : potential implementing energy\n\nKeyword Arguments: \n\ndim = 1 : dimension into which to expand\nmult = 10 : multiplicative factor for expanding the cell in dim direction\naa = :auto : array of stretch values of the lattice parameter to use\nnpoints = 100 : number of points to use in the stretch array (for auto aa)\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.dimer_energy-NTuple{4, Any}","page":"Reference","title":"ACEpotentials.dimer_energy","text":"function dimer_energy(pot, r, z1, z0) : energy of a dimer  with separation r and atomic numbers z1 and z0 using the potential pot;  subtracting the 1-body contributions. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.dimers-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.dimers","text":"dimers(potential, elements; kwargs...) :  Generate a dictionary of dimer curves for a given potential. \n\npotential : potential to use to evaluate energy\nelements : list of chemical species, symbols for which the dimers are to be computed\n\nThe function returns a dictionary Ddim such that D[(s1, s2)] contains pairs or arrays (rr, E) which can be plotted plot(rr, E). \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.get_adf-Tuple{AbstractVector{<:AtomsBase.AbstractSystem}, Any}","page":"Reference","title":"ACEpotentials.get_adf","text":"function get_adf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) :\n\nAngular distribution, i.e. list of angles in [0, Ï€] between all pairs of bonds  of length at most r_cut. Keyword arguments:\n\nskip = 3 : only consider every skipth atom in the dataset.\nmaxsamples = 100_000 : maximum number of samples to return.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.get_rdf-Tuple{AbstractVector{<:AtomsBase.AbstractSystem}, Any}","page":"Reference","title":"ACEpotentials.get_rdf","text":"function get_rdf(data::AbstractVector{<: Atoms}, r_cut; kwargs...) : \n\nProduce a list of r values that occur in the dataset, restricted to the cutoff  radius r_cut. Keyword arguments: \n\nrescale = true : resample the data to account for volume scaling, i.e. a distance r will be kept with probability min(1, (r0/r)^2).\nr0 = :min : parameter for resampling. If :min then the minimum r occuring in the dataset is taken. \nmaxsamples = 100_000 : maximum number of samples to return. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.make_model-Tuple{AbstractDict}","page":"Reference","title":"ACEpotentials.make_model","text":"  make_model(model_dict::AbstractDict)\n\nUser-facing script to generate a model from a dictionary. See documentation  for details.       \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.save_model-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.save_model","text":"  save_model(model, filename; kwargs...)\n\nsave model constructor, model parameters, and other information to a JSON file. \n\nmodel : the model to be saved\nfilename : the name of the file to which the model will be saved\nmodel_spec : the arguments used to construct the model; without this            the model cannot be reconstructed unless the original script is available\nerrors : the fitting / test errors computed during the fitting \nverbose : print information about the saving process     \nsave_project : save Project.toml and Manifest.toml for reproducibility\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.trimer_energy-NTuple{7, Any}","page":"Reference","title":"ACEpotentials.trimer_energy","text":"function trimer_energy(IP, r1, r2, Î¸, z0, z1, z2) : computes the energy of a trimer, subtracting the 2-body and 1-body contributions.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.trimers-NTuple{4, Any}","page":"Reference","title":"ACEpotentials.trimers","text":"trimers(potential, elements, r1, r2; kwargs...) :  Generate a dictionary of trimer curves for a given potential. \n\npotential : potential to use to evaluate energy \nelements : list of chemical species, symbols for which the trimers are to be computed\nr1, r2 : distance between the central atom and the first, second neighbour\n\nThe function returns a dictionary Dtri such that D[(s1, s2, s3)] contains  pairs or arrays (Î¸, E) which can be plotted plot(Î¸, E). \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.ACE1_PolyEnvelope1sR","page":"Reference","title":"ACEpotentials.Models.ACE1_PolyEnvelope1sR","text":"The pair basis radial envelope implemented in ACE1.jl \n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models.NormalizedTransform","page":"Reference","title":"ACEpotentials.Models.NormalizedTransform","text":"Maps the transform trans to the standardized interval [-1, 1]\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models.OneBody","page":"Reference","title":"ACEpotentials.Models.OneBody","text":"mutable struct OneBody{T}\n\nthis should not normally be constructed by a user, but instead E0 should be passed to the relevant model constructor, which will construct it.\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.Models._make_smatrix-Tuple{Any, Any}","page":"Reference","title":"ACEpotentials.Models._make_smatrix","text":"Takes an object and converts it to an SMatrix{NZ, NZ} via the following rules: \n\nif obj is already an SMatrix{NZ, NZ} then it just return obj\nif obj is an AbstractMatrix and size(obj) == (NZ, NZ) then it   converts it to an SMatrix{NZ, NZ} with the same entries.\notherwise it generates an SMatrix{NZ, NZ} filled with the value obj.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models._mm_filter-Tuple{AbstractVector, Integer}","page":"Reference","title":"ACEpotentials.Models._mm_filter","text":"Helper function to check if any signed combination of mm satisfies |sum| <= L. Adapted from EquivariantModels.jl for migration to EquivariantTensors.jl.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models._rpe_filter_real-Tuple{Integer}","page":"Reference","title":"ACEpotentials.Models._rpe_filter_real","text":"_rpe_filter_real(L::Integer)\n\nFilter for real spherical harmonics basis with equivariance level L. Replacement for EquivariantModels.RPEfilterreal.\n\nChecks:\n\nm-quantum number compatibility (via lazy signed m-set)\nParity condition: sum(l) + L must be even\nSpecial case: for L=0 with single element, l must be 0\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.agnesi_transform-NTuple{4, Any}","page":"Reference","title":"ACEpotentials.Models.agnesi_transform","text":"function agnesi_transform: constructs a generalized agnesi transform. \n\ntrans = agnesi_transform(r0, p, q)\n\nwith q >= p. This generates an AnalyticTransform object that implements \n\n   x(r) = frac11 + a (rr_0)^q  (1 + (rr0)^(q-p))\n\nwith default a chosen such that x(r) is maximised at r = r_0. But a may also be specified directly as a keyword argument. \n\nThe transform satisfies \n\n   x(r) sim frac11 + a (rr_0)^p quad textas quad r to 0 \n   quad textand \n   quad \n   x(r) sim frac11 + a (rr_0)^p  quad textas r to infty\n\nAs default parameters we recommend p = 2, q = 4 and the defaults for a.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.get_nnll_spec-Tuple{ACEpotentials.Models.ACEModel}","page":"Reference","title":"ACEpotentials.Models.get_nnll_spec","text":"Get the specification of the BBbasis as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int}.\n\nParameters\n\nmodel : an ACEModel\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.set_onehot_weights!-Tuple{ACEpotentials.Models.LearnableRnlrzzBasis, Any}","page":"Reference","title":"ACEpotentials.Models.set_onehot_weights!","text":"Set the radial weights as they would be in a linear ACE model. \n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.sparse_AA_spec-Tuple{}","page":"Reference","title":"ACEpotentials.Models.sparse_AA_spec","text":"This is one of the most important functions to generate an ACE model with  sparse AA basis. It generates the AA basis specification as a list (Vector) of vectors of @NamedTuple{n::Int, l::Int, m::Int}.\n\nParameters\n\norder : maximum correlation order \nr_spec : radial basis specification in the format Vector{@NamedTuple{a::Int64, b::Int64}}\nmax_level : maximum level of the basis, either a single scalar, or an iterable (one for each order)\nlevel : a function that computes the level of a basis element; see e.g. TotalDegree and EuclideanDegree\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.ETACEPotential","page":"Reference","title":"ACEpotentials.ETModels.ETACEPotential","text":"ETACEPotential\n\nAtomsCalculators-compatible calculator wrapping an ETACE model. This is a type alias for WrappedSiteCalculator{<:ETACE, PS, ST}.\n\nAccess underlying components via:\n\ncalc.model - The ETACE model\ncalc.ps - Model parameters\ncalc.st - Model state\ncalc.rcut - Cutoff radius in Ã…ngstrÃ¶m\ncalc.co_ps - Committee parameters (optional)\n\nExample\n\ncalc = ETACEPotential(et_model, ps, st, 5.5)\nE = potential_energy(sys, calc)\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.ETModels.ETOneBodyPotential","page":"Reference","title":"ACEpotentials.ETModels.ETOneBodyPotential","text":"ETOneBodyPotential\n\nAtomsCalculators-compatible calculator wrapping an ETOneBody model. This is a type alias for WrappedSiteCalculator{<:ETOneBody, PS, ST}.\n\nETOneBody has no learnable parameters, so training assembly returns empty results:\n\nlength_basis(calc) returns 0\nenergy_forces_virial_basis(sys, calc) returns empty arrays\nForces and virial are always zero (energy only depends on atom types)\n\nExample\n\net_onebody = one_body(Dict(:Si => -0.846), x -> x.z)\n_, st = Lux.setup(rng, et_onebody)\ncalc = ETOneBodyPotential(et_onebody, nothing, st, 3.0)\nE = potential_energy(sys, calc)\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.ETModels.ETPairPotential","page":"Reference","title":"ACEpotentials.ETModels.ETPairPotential","text":"ETPairPotential\n\nAtomsCalculators-compatible calculator wrapping an ETPairModel. This is a type alias for WrappedSiteCalculator{<:ETPairModel, PS, ST}.\n\nSupports training assembly functions:\n\nlength_basis(calc) - Total linear parameters\nenergy_forces_virial_basis(sys, calc) - Full EFV design row\npotential_energy_basis(sys, calc) - Energy design row\nget_linear_parameters(calc) / set_linear_parameters!(calc, Î¸)\n\nExample\n\net_pair = convertpair(model)\nps, st = Lux.setup(rng, et_pair)\ncalc = ETPairPotential(et_pair, ps, st, 5.5)\nE = potential_energy(sys, calc)\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.ETModels.EnvRBranchL","page":"Reference","title":"ACEpotentials.ETModels.EnvRBranchL","text":"struct EnvRBranchL\n\nAn auxiliary layer that is basically a branch layer needed to build   radial bases, with additional evaluate_ed functionality, needed for  Jacobians. \n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.ETModels.StackedCalculator","page":"Reference","title":"ACEpotentials.ETModels.StackedCalculator","text":"StackedCalculator{N, C<:Tuple}\n\nCombines multiple AtomsCalculators by summing their energy, forces, and virial. Each calculator in the tuple must implement the AtomsCalculators interface.\n\nThis allows combining site-based calculators (via WrappedSiteCalculator) with calculators that don't have site decompositions (e.g., Coulomb, dispersion).\n\nThe implementation uses compile-time loop unrolling for efficiency when the number of calculators is small and known at compile time.\n\nExample\n\n# Wrap site energy models\nE0_calc = WrappedSiteCalculator(E0Model(Dict(:Si => -0.846)))\nace_calc = WrappedSiteCalculator(WrappedETACE(et_model, ps, st, 5.5))\n\n# Stack them (could also add Coulomb, dispersion, etc.)\ncalc = StackedCalculator((E0_calc, ace_calc))\n\nE = potential_energy(sys, calc)\nF = forces(sys, calc)\n\nFields\n\ncalcs::Tuple - Tuple of N calculators implementing AtomsCalculators interface\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.ETModels.WrappedSiteCalculator","page":"Reference","title":"ACEpotentials.ETModels.WrappedSiteCalculator","text":"WrappedSiteCalculator{M, PS, ST}\n\nWraps any ETACE-pattern model (ETACE, ETPairModel, ETOneBody) and provides the AtomsCalculators interface.\n\nAll wrapped models must implement the ETACE interface:\n\nmodel(G, ps, st) â†’ (site_energies, st)\nsite_grads(model, G, ps, st) â†’ edge gradients\n\nMutable to allow parameter updates during training.\n\nExample\n\n# With ETACE model\ncalc = WrappedSiteCalculator(et_model, ps, st, 5.5)\n\n# With ETOneBody (upstream)\net_onebody = ETM.one_body(Dict(:Si => -0.846), x -> x.z)\n_, onebody_st = Lux.setup(rng, et_onebody)\ncalc = WrappedSiteCalculator(et_onebody, nothing, onebody_st, 3.0)\n\nE = potential_energy(sys, calc)\nF = forces(sys, calc)\n\nFields\n\nmodel - ETACE-pattern model (ETACE, ETPairModel, or ETOneBody)\nps - Model parameters (can be nothing for ETOneBody)\nst - Model state\nrcut::Float64 - Cutoff radius for graph construction (Ã…)\nco_ps - Optional committee parameters for uncertainty quantification\n\n\n\n\n\n","category":"type"},{"location":"all_exported/#ACEpotentials.ETModels.convert2et_full-Tuple{Any, Any, Any}","page":"Reference","title":"ACEpotentials.ETModels.convert2et_full","text":"convert2et_full(model, ps, st; rng=default_rng()) -> StackedCalculator\n\nConvert a complete ACE model (E0 + Pair + Many-body) to an ETACE-based StackedCalculator. This creates a calculator that combines:\n\nETOneBody - reference energies per species\nETPairModel - pair potential\nETACE - many-body ACE potential\n\nThe returned StackedCalculator is fully compatible with AtomsCalculators and can be used for energy, forces, and virial evaluation.\n\nArguments\n\nmodel: ACE model (from ACEpotentials.Models)\nps: Model parameters (from Lux.setup)\nst: Model state (from Lux.setup)\nrng: Random number generator (default: default_rng())\n\nReturns\n\nStackedCalculator combining ETOneBody, ETPairModel, and ETACE\n\nExample\n\nmodel = ace_model(elements=[:Si], order=3, totaldegree=8)\nps, st = Lux.setup(rng, model)\n# ... fit model ...\ncalc = convert2et_full(model, ps, st)\nE = potential_energy(sys, calc)\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.copy_ace_params!-Tuple{Any, Any, Any}","page":"Reference","title":"ACEpotentials.ETModels.copy_ace_params!","text":"copy_ace_params!(et_ps, ps, model)\n\nCopy many-body (ACE) parameters from ACE model format to ETACE format.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.copy_pair_params!-Tuple{Any, Any, Any}","page":"Reference","title":"ACEpotentials.ETModels.copy_pair_params!","text":"copy_pair_params!(et_ps, ps, model)\n\nCopy pair potential parameters from ACE model format to ETPairModel format. Based on parameter mapping from test/etmodels/test_etpair.jl.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.get_linear_parameters-Tuple{ACEpotentials.ETModels.StackedCalculator}","page":"Reference","title":"ACEpotentials.ETModels.get_linear_parameters","text":"get_linear_parameters(calc::StackedCalculator)\n\nGet concatenated linear parameters from all stacked calculators.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.get_linear_parameters-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETACE}","page":"Reference","title":"ACEpotentials.ETModels.get_linear_parameters","text":"get_linear_parameters(calc::ETACEPotential)\n\nExtract the linear parameters (readout weights) as a flat vector. Parameters are ordered as: [W[1,:,1]; W[1,:,2]; ... ; W[1,:,nspecies]]\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.get_linear_parameters-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETOneBody}","page":"Reference","title":"ACEpotentials.ETModels.get_linear_parameters","text":"get_linear_parameters(calc::ETOneBodyPotential)\n\nReturn empty vector - ETOneBody has no learnable parameters.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.get_linear_parameters-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETPairModel}","page":"Reference","title":"ACEpotentials.ETModels.get_linear_parameters","text":"get_linear_parameters(calc::ETPairPotential)\n\nExtract the linear parameters (readout weights) as a flat vector.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.one_body-Tuple{Dict, Any}","page":"Reference","title":"ACEpotentials.ETModels.one_body","text":"one_body(D::Dict, catfun)\n\nCreate a one-body energy model that assigns to each atom an energy based on  a categorical variable that is extracted from the atom state via  catfun. The dictionary D contains category-value pairs. The one-body  energy assigned to an atom with state x is D[catfun(x)].\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.set_linear_parameters!-Tuple{ACEpotentials.ETModels.StackedCalculator, AbstractVector}","page":"Reference","title":"ACEpotentials.ETModels.set_linear_parameters!","text":"set_linear_parameters!(calc::StackedCalculator, Î¸::AbstractVector)\n\nSet linear parameters for all stacked calculators from concatenated vector.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.set_linear_parameters!-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETACE, AbstractVector}","page":"Reference","title":"ACEpotentials.ETModels.set_linear_parameters!","text":"set_linear_parameters!(calc::ETACEPotential, Î¸::AbstractVector)\n\nSet the linear parameters (readout weights) from a flat vector.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.set_linear_parameters!-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETOneBody, AbstractVector}","page":"Reference","title":"ACEpotentials.ETModels.set_linear_parameters!","text":"set_linear_parameters!(calc::ETOneBodyPotential, Î¸::AbstractVector)\n\nNo-op for ETOneBody (no learnable parameters).\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.ETModels.set_linear_parameters!-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETPairModel, AbstractVector}","page":"Reference","title":"ACEpotentials.ETModels.set_linear_parameters!","text":"set_linear_parameters!(calc::ETPairPotential, Î¸::AbstractVector)\n\nSet the linear parameters (readout weights) from a flat vector.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.energy_forces_virial_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.StackedCalculator}","page":"Reference","title":"ACEpotentials.Models.energy_forces_virial_basis","text":"energy_forces_virial_basis(sys::AbstractSystem, calc::StackedCalculator)\n\nCompute concatenated basis for all stacked calculators.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.energy_forces_virial_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETACE}","page":"Reference","title":"ACEpotentials.Models.energy_forces_virial_basis","text":"energy_forces_virial_basis(sys::AbstractSystem, calc::ETACEPotential)\n\nCompute the basis functions for energy, forces, and virial. Returns a named tuple with:\n\nenergy::Vector{Float64} - length = length_basis(calc)\nforces::Matrix{SVector{3,Float64}} - size = (natoms, length_basis)\nvirial::Vector{SMatrix{3,3,Float64}} - length = length_basis(calc)\n\nThe linear combination of basis values with parameters gives:   E = dot(energy, params)   F = forces * params   V = sum(params .* virial)\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.energy_forces_virial_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETOneBody}","page":"Reference","title":"ACEpotentials.Models.energy_forces_virial_basis","text":"energy_forces_virial_basis(sys::AbstractSystem, calc::ETOneBodyPotential)\n\nReturn empty arrays - ETOneBody has no learnable parameters.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.energy_forces_virial_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETPairModel}","page":"Reference","title":"ACEpotentials.Models.energy_forces_virial_basis","text":"energy_forces_virial_basis(sys::AbstractSystem, calc::ETPairPotential)\n\nCompute the basis functions for energy, forces, and virial for pair potential.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.length_basis-Tuple{ACEpotentials.ETModels.StackedCalculator}","page":"Reference","title":"ACEpotentials.Models.length_basis","text":"length_basis(calc::StackedCalculator)\n\nReturn total number of linear parameters across all stacked calculators.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.length_basis-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETACE}","page":"Reference","title":"ACEpotentials.Models.length_basis","text":"length_basis(calc::ETACEPotential)\n\nReturn the number of linear parameters in the model (nbasis * nspecies).\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.length_basis-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETOneBody}","page":"Reference","title":"ACEpotentials.Models.length_basis","text":"length_basis(calc::ETOneBodyPotential)\n\nReturn 0 - ETOneBody has no learnable linear parameters.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.length_basis-Tuple{ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETPairModel}","page":"Reference","title":"ACEpotentials.Models.length_basis","text":"length_basis(calc::ETPairPotential)\n\nReturn the number of linear parameters in the pair model (nbasis * nspecies).\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.potential_energy_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.StackedCalculator}","page":"Reference","title":"ACEpotentials.Models.potential_energy_basis","text":"potential_energy_basis(sys::AbstractSystem, calc::StackedCalculator)\n\nCompute concatenated energy basis for all stacked calculators.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.potential_energy_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETACE}","page":"Reference","title":"ACEpotentials.Models.potential_energy_basis","text":"potential_energy_basis(sys::AbstractSystem, calc::ETACEPotential)\n\nCompute only the energy basis (faster when forces/virial not needed).\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.potential_energy_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETOneBody}","page":"Reference","title":"ACEpotentials.Models.potential_energy_basis","text":"potential_energy_basis(sys::AbstractSystem, calc::ETOneBodyPotential)\n\nReturn empty array - ETOneBody has no learnable parameters.\n\n\n\n\n\n","category":"method"},{"location":"all_exported/#ACEpotentials.Models.potential_energy_basis-Tuple{AtomsBase.AbstractSystem, ACEpotentials.ETModels.WrappedSiteCalculator{MOD} where MOD<:ACEpotentials.ETModels.ETPairModel}","page":"Reference","title":"ACEpotentials.Models.potential_energy_basis","text":"potential_energy_basis(sys::AbstractSystem, calc::ETPairPotential)\n\nCompute only the energy basis for pair potential.\n\n\n\n\n\n","category":"method"},{"location":"gettingstarted/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/installation/#Short-Version","page":"Installation","title":"Short Version","text":"These short instructions are intended for users who are already familiar with Julia.  If these instructions don't make sense please see the detailed instructions below. \n\nInstall Julia (1.10) if you haven't already. Make sure the General registry is installed and up to date. (or uncomment the relevant line in the script below)\nSetup a new project: create a folder to develop your new project, and cd into the folder. This folder will track the packages and versions which the ACEpotentials code requires. Start julia, activate the project and add ACEregistry that includes ACEpotentials, which is the package that we want to install:\nusing Pkg\nPkg.activate(\".\")\n# uncomment the next line if the General registry is not yet installed,\n# e.g. if using Julia for the first time.\n# Pkg.Registry.add(\"General\")  \nPkg.Registry.add(RegistrySpec(url=\"https://github.com/ACEsuit/ACEregistry\"))\nPkg.add(\"ACEpotentials\")\nACEpotentials will come with the most important packages you need, in particular ACEfit.jl and various AtomsBase.jl related packages. \nYou need to activate a project folder when starting julia.\n\nThis can be done by starting julia with julia --project=pathtoproject command, using an environment variable export JULIA_PROJECT=pathtoproject or, after starting julia, calling\n\nusing Pkg\npkg\"activate pathtoproject\"","category":"section"},{"location":"gettingstarted/installation/#Detailed-Instructions","page":"Installation","title":"Detailed Instructions","text":"If you have any difficulties with the following setup process, please file an issue. We highly recommend familiarizing oneself with the Julia package manager and how Project management is best done in Julia (there is also a summary in this section of these docs). In particular all projects should manage their own Project.toml file with appropriate version bounds, and where appropriate the Manifest.toml file can be tracked in order to guarantee reproducibility of results.","category":"section"},{"location":"gettingstarted/installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"Download and unpack Julia. We require v1.10 or upwards. Add the julia executable to your path with something like export PATH=<julia-directory>/bin:$PATH.\n\nStart the Julia REPL (type julia followed by Enter), switch to package manager by typing ], then install the General registry and the ACE registry:\n\nregistry add https://github.com/JuliaRegistries/General\nregistry add https://github.com/ACEsuit/ACEregistry\n\nPress Backspace or Ctrl-c to exit the package manager. Use Ctrl-d, or exit() followed by Enter, to close the Julia REPL.","category":"section"},{"location":"gettingstarted/installation/#Setting-up-a-new-ACEpotentials.jl-project","page":"Installation","title":"Setting up a new ACEpotentials.jl project","text":"Create a folder for your new project and change to it. Start the Julia REPL and activate a new project by switching to the package manager with ], and then running\n\nactivate .\n\nNow you can install ACEpotentials. Remaining in the package manager, use\n\nadd ACEpotentials\n\nDepending on your usage you may also need to add other packages, e.g. AtomsBase, Molly, DFTK etc.","category":"section"},{"location":"gettingstarted/installation/#Returning-to-a-project","page":"Installation","title":"Returning to a project","text":"When returning to a project, there are several methods for reactivating it. One is to simply activate . in the package manager, as above. Alternatively set the JULIA_PROJECT environment variable to the directory with Project.toml before starting julia, or call julia as julia --project=<dir>. Special syntax like JULIA_PROJECT=@. or julia --project=@. searches the current directory and its parents for a Project.toml file.","category":"section"},{"location":"gettingstarted/installation/#Setting-up-the-tutorial","page":"Installation","title":"Setting up the tutorial","text":"As in the instructions described above, install Julia, then create a new folder, start new julia project and in that project add ACEpotentials and IJulia, then copy the tutorial to the local folder:\n\njulia -e 'using Pkg; Pkg.add(\"ACEpotentials\"); Pkg.add(\"IJulia\")'\njulia -e 'using ACEpotentials; ACEpotentials.copy_tutorial(@__DIR__())'\n\nStart Jupyter, e.g. via \n\njupyter notebook \n\nOpen the tutorial notebook. If a Julia kernel can be selected make sure it is 1.10 or higher. The follow the instructions in the notebook. ","category":"section"},{"location":"gettingstarted/installation/#Setting-up-the-Python-ASE-calculator","page":"Installation","title":"Setting up the Python ASE calculator","text":"warning: Warning\nThe current version of ACEpotentials does not have a tested ASE interface. If you need an ASE interface, consider using a version  < 0.8 of ACEpotentials.\n\nWe use a wrapper called pyjulip to call julia and evaluate ACE potentials. In a terminal, with the correct julia project and python environment selected, run the following code:\n\npython -m pip install julia\npython -c \"import julia; julia.install()\"\n\nMake sure to use the correct python and pip, e.g. the ones that are in the correct Conda environment. Then, to set up pyjulip:\n\ngit clone https://github.com/casv2/pyjulip.git\ncd pyjulip\npip install .","category":"section"},{"location":"gettingstarted/installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"There are currently no known recurring problems with ACEpotentials installation.","category":"section"},{"location":"literate_tutorials/descriptor/#ACE-Descriptors","page":"ACE Descriptors","title":"ACE Descriptors","text":"This tutorial demonstrates a simple use of ACE descriptors.\n\nusing ACEpotentials, MultivariateStats, Plots\n\nLoad a tiny silicon dataset, which has the isolated atom, 25 diamond-like (dia) configurations, 25 beta-tin-like (bt) configurations, and 2 liquid (liq) configurations.\n\ndataset, _, _ = ACEpotentials.example_dataset(\"Si_tiny\");\nnothing #hide\n\nAn ACE basis specifies a vector of invariant features of atomic environments and can therefore be used as a general descriptor.\n\nmodel = ace1_model(elements = [:Si],\n                rcut = 5.5,\n                order = 3,        # body-order - 1\n                totaldegree = 8);\nnothing #hide\n\nCompute an averaged structural descriptor for each configuration.\n\ndescriptors = []\nconfig_types = []\nfor sys in dataset\n    sys_descriptor = sum(site_descriptors(sys, model)) / length(sys)\n    push!(descriptors, sys_descriptor)\n    push!(config_types, sys[:config_type])\nend\n\nFinally, extract the descriptor principal components and plot. Note the segregation by configuration type.\n\ndescriptors = reduce(hcat, descriptors)\nM = fit(PCA, descriptors; maxoutdim=3, pratio=1)\ndescriptors_trans = transform(M, descriptors)\np = scatter(\n    descriptors_trans[1,:], descriptors_trans[2,:], descriptors_trans[3,:],\n    marker=:circle, linewidth=0, group=config_types, legend=:right)\nplot!(p, xlabel=\"PC1\", ylabel=\"PC2\", zlabel=\"PC3\", camera=(20,10))\n\nThe basis used above uses defaults that are suitable for regression of a potential energy surface, but other defaults might be better when using the ACE descriptor for other tasks such as classification. The following short script shows how to make some changes of this kind:\n\nmodel = ace1_model(elements = [:Si,], order = 3, totaldegree = 10,\n       pair_transform = (:agnesi, 1, 4),\n       pair_envelope = (:x, 0, 2),\n       transform = (:agnesi, 1, 4),\n       envelope = (:x, 0, 2),\n       r0 = :bondlen, # default, could specify explicitly\n       )\n\n[pair_]transform = (:agnesi, 1, 4) : this generates a transform that behaves as t' ~ r^3 near zero and t' ~ r^-2 near the cutoff\n[pair_]envelope = (:x, 0, 2) : this generates an envelope that is ~ (x - xcut)^2 at the cutoff and just ~ 1 for r -> 0.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"gettingstarted/aceintro/#Introduction-to-ACE-Models","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"This section summarises the mathematics behind linear ACE parameterisations of invariant atomic properties. It is not required to use the ACEpotentials package and can be skipped on a first reading.","category":"section"},{"location":"gettingstarted/aceintro/#Invariant-Properties","page":"Introduction to ACE Models","title":"Invariant Properties","text":"To explain the main ideas in the simplest non-trivial setting, we consider systems of indistinguishable particles. A configuration is an mset R =  bm r_j _j subset mathbbR^3 with arbitary numbers of particles and we wish to develop representation of properties \n\n   varphibig(R) in mathbbR\n\nwhich are invariant under permutations (already implicit in the fact that R is an mset) and under isometries O(3). To make this explicit we can write this as\n\nvarphibig(  Q bm r_sigma j _j big)\n=\nvarphibig(  bm r_j _j big) qquad forall Q in O(3) \nquad sigma text a permutation\n\nTo that end we proceed in three steps: ","category":"section"},{"location":"gettingstarted/aceintro/#Density-Projection-/-Atomic-Base","page":"Introduction to ACE Models","title":"Density Projection / Atomic Base","text":"We define the \"atomic density\"\n\nrho(bm r) = sum_j delta(bm r - bm r_j)\n\nThen we choose a one-particle basis \n\nphi_v(bm r) = phi_nlm(bm r) = R_n(r) Y_l^m(hatbm r)\n\nand project rho onto that basis, \n\nA_v = A_nlm = langle phi_nlm rho rangle = \n   sum_j phi_nlm(bm r_j)","category":"section"},{"location":"gettingstarted/aceintro/#Density-correlations","page":"Introduction to ACE Models","title":"Density correlations","text":"Next, we form the N-correlations of the density, rho^otimes N and project them onto the tensor project basis, \n\n   bm A_mathbfnlm\n   = Biglangle otimes_t = 1^N phi_n_t l_t m_t rho^otimes N Bigrangle \n   = prod_t = 1^N A_n_t l_t m_t\n\nThe reason to introduce these is that in the next step, the symmetrisation step, the density project would lose all angular information while the N-correlations retain most (though not all) of it. ","category":"section"},{"location":"gettingstarted/aceintro/#Symmetrisation","page":"Introduction to ACE Models","title":"Symmetrisation","text":"Finally, we symmetrise the N-correlations, by integrating over the O(3)-Haar measure, \n\n  B_mathbfnlm propto \n  int_O(3) bm A_mathbfnlm circ Q  dQ \n\nBecause of properties of the spherical harmonics one can write this as \n\n  bm B = mathcalU bm A\n\nwhere bm A is the vector of 1, 2, ..., N correlations (the maximal N is an approximation parameter!) and mathcalU is a sparse matrix (the coupling coefficients).\n\nIf one symmetrised all possible N-correlations then this would create a spanning set, but one can easily reduce this to an actual basis. This construction then yields a basis of the space of symmetric polynomials. \n\nNotes: \n\nBecause of permutation symmetry only ordered bm v tuples are retained","category":"section"},{"location":"gettingstarted/aceintro/#Linear-Dependence","page":"Introduction to ACE Models","title":"Linear Dependence","text":"The construction described above introduces a lot of linear dependence which is removed in the ACE basis construction in a mixed symbolic / numerical procedure. In the end we no longer index the symmetrized basis functions as B_bm nlm but as B_mathbfnli with i indexing the linearly independent basis functions from the mathbfnl block. ","category":"section"},{"location":"tutorials/scripting/#Basic-Shell-Workflow","page":"Basic Shell Workflow","title":"Basic Shell Workflow","text":"This short introduces a basic workflow where models are specified via  JSON files and model fitting is achieved via a shell script. \n\nAt the start of a new project we \n\ncreate a project folder \nactivate a Julia project in that folder \nadd ACEpotentials to the Julia project \ngenerate a fitting script and example model specification file\n\nmkdir myace\ncd myace\njulia --project=. -e 'using Pkg; Pkg.add(\"ACEpotentials\"); using ACEpotentials; ACEpotentials.copy_runfit(@__DIR__())'\n\nThis should create two new files in the myace folder: \n\nrunfit.jl\nexample_params.json\n\nCopy (or move) the example_params.json file to a new filename, e.g. \n\ncp example_params.json myace_params_1.json\n\nthen edit that file to specify the model hyperparameters,  the fitting method (see also ACEfit.jl), and the path to the dataset (or, datasets if validation  and or test sets are also provided). To produce a fit, use \n\njulia --project=. runfit.jl -p myace_params_1.json -o results_1\n\nThis will write all outputs to the ./results_1 folder, in particular results.json which contains the model specification, the fitted model parameters, and a dictionary of computed errors (rmse, mae). The list of required outputs and the output filename(s) can be changed in the model spec json. ","category":"section"},{"location":"#ACEpotentials.jl-Documentation","page":"Home","title":"ACEpotentials.jl Documentation","text":"ACEpotentials.jl facilitates the creation and use of atomic cluster expansion (ACE) interatomic potentials. For a quick start, we recommend reading the installation instructions, followed by the tutorials. \n\nACE models are defined in terms of body-ordered invariant features of atomic environments. For mathematical details, see this brief introduction and the references listed below.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"ACEpotentials.jl ties together several Julia packages implementing different aspects of ACE modelling and fitting and provides some additional fitting and analysis tools for convenience. For example, it provides routines for parsing and manipulating the data to which interatomic potentials are fit (total energies, forces, virials, etc). Moreover, it integrates ACE potentials with the JuliaMolSim eco-system. These pages document ACEpotentialstogether with the relevant parts of the wider ecosystem.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]\nW. C. Witt, C. van der Oord, E. GelÅ¾inytÃ©, T. JÃ¤rvinen, A. Ross, J. P. Darby, C. H. Ho, W. J. Baldwin, M. Sachs, J. Kermode, N. Bernstein, G. CsÃ¡nyi, and C. Ortner. ACEpotentials.jl: A Julia Implementation of the Atomic Cluster Expansion. J. Chem. Phys., 159:164101, 2023. [DOI] [arxiv]","category":"section"},{"location":"#Key-Dependencies","page":"Home","title":"Key Dependencies","text":"Polynomials4ML.jl : basic kernels for embeddings and tensors\nEquivariantTensors.jl : tools to build equivariant tensors\nACEfit.jl : unified interface to various regression algorithms\nAtomsBase.jl : community interface for atomic structures / systems\nAtomsCalculators.jl : community interface for computing properties of systems\nExtXYZ.jl : reading and writing extended xyz format","category":"section"},{"location":"#Useful-Related-Packages","page":"Home","title":"Useful Related Packages","text":"Molly.jl : main molecular dynamics package in Julia\nDFTK.jl : pure Julia plane wave DFT code\nGeometryOptimization.jl and GeomOpt.jl ","category":"section"}]
}
